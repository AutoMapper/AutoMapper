// <auto-generated/>
/*
The MIT License (MIT)

Copyright (c) 2016-2023 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// ReSharper disable CoVariantArrayConversion

// #define LIGHT_EXPRESSION
// #define DEBUG_INFO_LOCAL_VARIABLE_USAGE
#if DEBUG && NET6_0_OR_GREATER
#define DEMIT
#endif
#if LIGHT_EXPRESSION || !NET45
#define SUPPORTS_ARGUMENT_PROVIDER
#endif
#if LIGHT_EXPRESSION
namespace FastExpressionCompiler.LightExpression
{
    using FastExpressionCompiler.LightExpression.ImTools;
    using static FastExpressionCompiler.LightExpression.ImTools.FHashMap;
    using static FastExpressionCompiler.LightExpression.Expression;
    using PE = FastExpressionCompiler.LightExpression.ParameterExpression;
#else
namespace FastExpressionCompiler
{
    using FastExpressionCompiler.ImTools;
    using static FastExpressionCompiler.ImTools.FHashMap;
    using static System.Linq.Expressions.Expression;
    using PE = System.Linq.Expressions.ParameterExpression;
#endif
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Expressions;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Threading;
    using System.Text;
    using System.Runtime.CompilerServices;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using static System.Environment;
    using System.Collections.ObjectModel;

    /// <summary>The flags for the compiler</summary>
    [Flags]
    public enum CompilerFlags : byte
    {
        /// <summary>The default flags: Invocation lambda is inlined, no debug info</summary>
        Default = 0,
        /// <summary>Prevents the inlining of the lambda in the Invocation expression to optimize for the multiple same lambda compiled once</summary>
        NoInvocationLambdaInlining = 1,
        /// <summary>Adds the Expression, ExpressionString, and CSharpString to the delegate closure for the debugging inspection</summary>
        EnableDelegateDebugInfo = 1 << 1,
        /// <summary>When the flag is set then instead of the returning `null` the specific exception is thrown*346</summary>
        ThrowOnNotSupportedExpression = 1 << 2
    }

    /// <summary>FEC Not Supported exception</summary>
    public sealed class NotSupportedExpressionException : InvalidOperationException
    {
        /// <summary>The reason</summary>
        public readonly ExpressionCompiler.Result Reason;
        /// <summary>Constructor</summary>
        public NotSupportedExpressionException(ExpressionCompiler.Result reason) : base(reason.ToString()) => Reason = reason;
        /// <summary>Constructor</summary>
        public NotSupportedExpressionException(ExpressionCompiler.Result reason, string message) : base(reason + ": " + message) => Reason = reason;
    }

    /// <summary>The interface is implemented by the compiled delegate Target if `CompilerFlags.EnableDelegateDebugInfo` is set.</summary>
    public interface IDelegateDebugInfo
    {
        /// <summary>The lambda expression object that was compiled to the delegate</summary>
        LambdaExpression Expression { get; }
        /// <summary>The lambda expression construction syntax C# code</summary>
        string ExpressionString { get; }
        /// <summary>The equivalent C# code of the lambda expression</summary>
        string CSharpString { get; }

        // todo: @feature add the debug info to the nested lambdas
        // /// <summary>Total nested lambda counting</summary>
        // ushort NestedLambdaCount { get; } // todo: @wip count nested lambdas and expressions

        // /// <summary>Nested lambda compiled counting, should be less or equal to `NestedLambdaCount` so that the same lambda compiled only once.</summary>
        // ushort NestedLambdaCompiledTimesCount { get; }
    }

    /// <summary>Compiles expression to delegate ~20 times faster than Expression.Compile.
    /// Partial to extend with your things when used as source file.</summary>
    // ReSharper disable once PartialTypeWithSinglePart
    [RequiresUnreferencedCode(Trimming.Message)]
    public static partial class ExpressionCompiler
    {
        #region Expression.CompileFast overloads for Delegate, Func, and Action

        /// <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static TDelegate CompileFast<TDelegate>(this LambdaExpression lambdaExpr,
            bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) where TDelegate : class =>
            (TDelegate)(TryCompileBoundToFirstClosureParam(
                typeof(TDelegate) == typeof(Delegate) ? lambdaExpr.Type : typeof(TDelegate), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr, RentOrNewClosureTypeToParamTypes(lambdaExpr),
#else
                lambdaExpr.Parameters, RentOrNewClosureTypeToParamTypes(lambdaExpr.Parameters),
#endif
                lambdaExpr.ReturnType, flags) ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys()));

        /// <summary>Compiles a static method to the passed IL Generator.
        /// Could be used as alternative for `CompileToMethod` like this <code><![CDATA[funcExpr.CompileFastToIL(methodBuilder.GetILGenerator())]]></code>.
        /// Check `IssueTests.Issue179_Add_something_like_LambdaExpression_CompileToMethod.cs` for example.</summary>
        public static bool CompileFastToIL(this LambdaExpression lambdaExpr, ILGenerator il, CompilerFlags flags = CompilerFlags.Default)
        {
            if ((flags & CompilerFlags.EnableDelegateDebugInfo) != 0)
                throw new NotSupportedException("The `CompilerFlags.EnableDelegateDebugInfo` is not supported because the debug info is gathered into the closure object which is not allowed for static lambda to be compiled to method.");

#if LIGHT_EXPRESSION
            var paramExprs = lambdaExpr;
#else
            var paramExprs = lambdaExpr.Parameters;
#endif
            var bodyExpr = lambdaExpr.Body;

            var closureInfo = new ClosureInfo(ClosureStatus.ShouldBeStaticMethod);
            var nestedLambdas = new SmallList<NestedLambdaInfo>();
            if (!TryCollectBoundConstants(ref closureInfo, bodyExpr, paramExprs, null, ref nestedLambdas, flags))
                return false;

            if ((closureInfo.Status & ClosureStatus.HasClosure) != 0)
                return false;

            var parent = lambdaExpr.ReturnType == typeof(void) ? ParentFlags.IgnoreResult : ParentFlags.Empty;
            if (!EmittingVisitor.TryEmit(bodyExpr, paramExprs, il, ref closureInfo, flags, parent))
                return false;

            il.Demit(OpCodes.Ret);
            return true;
        }

        /// <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Delegate CompileFast(this LambdaExpression lambdaExpr, bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Delegate)TryCompileBoundToFirstClosureParam(lambdaExpr.Type, lambdaExpr.Body,
#if LIGHT_EXPRESSION
            lambdaExpr, RentOrNewClosureTypeToParamTypes(lambdaExpr),
#else
            lambdaExpr.Parameters, RentOrNewClosureTypeToParamTypes(lambdaExpr.Parameters),
#endif
            lambdaExpr.ReturnType, flags) ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Unifies Compile for System.Linq.Expressions and FEC.LightExpression</summary>
        public static TDelegate CompileSys<TDelegate>(this Expression<TDelegate> lambdaExpr) where TDelegate : System.Delegate =>
            lambdaExpr
#if LIGHT_EXPRESSION
            .ToLambdaExpression()
#endif
            .Compile();

        /// <summary>Unifies Compile for System.Linq.Expressions and FEC.LightExpression</summary>
        public static Delegate CompileSys(this LambdaExpression lambdaExpr) =>
            lambdaExpr
#if LIGHT_EXPRESSION
            .ToLambdaExpression()
#endif
            .Compile();

        /// <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static TDelegate CompileFast<TDelegate>(this Expression<TDelegate> lambdaExpr, bool ifFastFailedReturnNull = false,
            CompilerFlags flags = CompilerFlags.Default) where TDelegate : System.Delegate =>
            ((LambdaExpression)lambdaExpr).CompileFast<TDelegate>(ifFastFailedReturnNull, flags);

        /// <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Func<R> CompileFast<R>(this Expression<Func<R>> lambdaExpr, bool ifFastFailedReturnNull = false,
            CompilerFlags flags = CompilerFlags.Default) =>
            (Func<R>)TryCompileBoundToFirstClosureParam(typeof(Func<R>), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
                _closureAsASingleParamType, typeof(R), flags) ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Func<T1, R> CompileFast<T1, R>(this Expression<Func<T1, R>> lambdaExpr,
            bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Func<T1, R>)TryCompileBoundToFirstClosureParam(typeof(Func<T1, R>), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
            new[] { typeof(ArrayClosure), typeof(T1) }, typeof(R), flags) ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Func<T1, T2, R> CompileFast<T1, T2, R>(this Expression<Func<T1, T2, R>> lambdaExpr,
            bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Func<T1, T2, R>)TryCompileBoundToFirstClosureParam(typeof(Func<T1, T2, R>), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
                new[] { typeof(ArrayClosure), typeof(T1), typeof(T2) },
                typeof(R), flags) ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Func<T1, T2, T3, R> CompileFast<T1, T2, T3, R>(
            this Expression<Func<T1, T2, T3, R>> lambdaExpr, bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Func<T1, T2, T3, R>)TryCompileBoundToFirstClosureParam(typeof(Func<T1, T2, T3, R>), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
            new[] { typeof(ArrayClosure), typeof(T1), typeof(T2), typeof(T3) }, typeof(R), flags)
            ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Func<T1, T2, T3, T4, R> CompileFast<T1, T2, T3, T4, R>(
            this Expression<Func<T1, T2, T3, T4, R>> lambdaExpr, bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Func<T1, T2, T3, T4, R>)TryCompileBoundToFirstClosureParam(typeof(Func<T1, T2, T3, T4, R>), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
                new[] { typeof(ArrayClosure), typeof(T1), typeof(T2), typeof(T3), typeof(T4) }, typeof(R), flags)
            ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Func<T1, T2, T3, T4, T5, R> CompileFast<T1, T2, T3, T4, T5, R>(
            this Expression<Func<T1, T2, T3, T4, T5, R>> lambdaExpr, bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Func<T1, T2, T3, T4, T5, R>)TryCompileBoundToFirstClosureParam(typeof(Func<T1, T2, T3, T4, T5, R>), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
                new[] { typeof(ArrayClosure), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5) }, typeof(R), flags)
            ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Func<T1, T2, T3, T4, T5, T6, R> CompileFast<T1, T2, T3, T4, T5, T6, R>(
            this Expression<Func<T1, T2, T3, T4, T5, T6, R>> lambdaExpr, bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Func<T1, T2, T3, T4, T5, T6, R>)TryCompileBoundToFirstClosureParam(typeof(Func<T1, T2, T3, T4, T5, T6, R>), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
                new[] { typeof(ArrayClosure), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6) }, typeof(R), flags)
            ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Action CompileFast(this Expression<Action> lambdaExpr, bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Action)TryCompileBoundToFirstClosureParam(typeof(Action), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
            _closureAsASingleParamType, typeof(void), flags) ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Action<T1> CompileFast<T1>(this Expression<Action<T1>> lambdaExpr,
            bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Action<T1>)TryCompileBoundToFirstClosureParam(typeof(Action<T1>), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
            new[] { typeof(ArrayClosure), typeof(T1) }, typeof(void), flags) ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Action<T1, T2> CompileFast<T1, T2>(this Expression<Action<T1, T2>> lambdaExpr,
            bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Action<T1, T2>)TryCompileBoundToFirstClosureParam(typeof(Action<T1, T2>), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
            new[] { typeof(ArrayClosure), typeof(T1), typeof(T2) }, typeof(void), flags) ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Action<T1, T2, T3> CompileFast<T1, T2, T3>(this Expression<Action<T1, T2, T3>> lambdaExpr,
            bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Action<T1, T2, T3>)TryCompileBoundToFirstClosureParam(typeof(Action<T1, T2, T3>), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
                new[] { typeof(ArrayClosure), typeof(T1), typeof(T2), typeof(T3) }, typeof(void), flags)
            ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Action<T1, T2, T3, T4> CompileFast<T1, T2, T3, T4>(
            this Expression<Action<T1, T2, T3, T4>> lambdaExpr, bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Action<T1, T2, T3, T4>)TryCompileBoundToFirstClosureParam(typeof(Action<T1, T2, T3, T4>), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
                new[] { typeof(ArrayClosure), typeof(T1), typeof(T2), typeof(T3), typeof(T4) }, typeof(void), flags)
            ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Action<T1, T2, T3, T4, T5> CompileFast<T1, T2, T3, T4, T5>(
            this Expression<Action<T1, T2, T3, T4, T5>> lambdaExpr, bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Action<T1, T2, T3, T4, T5>)TryCompileBoundToFirstClosureParam(typeof(Action<T1, T2, T3, T4, T5>), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
                new[] { typeof(ArrayClosure), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5) }, typeof(void), flags)
            ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        /// <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        public static Action<T1, T2, T3, T4, T5, T6> CompileFast<T1, T2, T3, T4, T5, T6>(
            this Expression<Action<T1, T2, T3, T4, T5, T6>> lambdaExpr, bool ifFastFailedReturnNull = false, CompilerFlags flags = CompilerFlags.Default) =>
            (Action<T1, T2, T3, T4, T5, T6>)TryCompileBoundToFirstClosureParam(typeof(Action<T1, T2, T3, T4, T5, T6>), lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
                new[] { typeof(ArrayClosure), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6) }, typeof(void), flags)
            ?? (ifFastFailedReturnNull ? null : lambdaExpr.CompileSys());

        #endregion

        /// <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/></summary>
        public static TDelegate TryCompile<TDelegate>(this LambdaExpression lambdaExpr, CompilerFlags flags = CompilerFlags.Default)
            where TDelegate : class =>
            (TDelegate)TryCompileBoundToFirstClosureParam(typeof(TDelegate) == typeof(Delegate) ? lambdaExpr.Type : typeof(TDelegate), lambdaExpr.Body,
#if LIGHT_EXPRESSION
            lambdaExpr, RentOrNewClosureTypeToParamTypes(lambdaExpr),
#else
            lambdaExpr.Parameters, RentOrNewClosureTypeToParamTypes(lambdaExpr.Parameters),
#endif
            lambdaExpr.ReturnType, flags);

        /// <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/> 
        /// with the provided closure object and constant expressions (or lack there of) -
        /// Constant expression should be the in order of Fields in closure object!
        /// Note 1: Use it on your own risk - FEC won't verify the expression is compile-able with passed closure, it is up to you!
        /// Note 2: The expression with NESTED LAMBDA IS NOT SUPPORTED!
        /// Note 3: `Label` and `GoTo` are not supported in this case, because they need first round to collect out-of-order labels</summary>
        public static TDelegate TryCompileWithPreCreatedClosure<TDelegate>(this LambdaExpression lambdaExpr,
            params ConstantExpression[] closureConstantsExprs) where TDelegate : class =>
            lambdaExpr.TryCompileWithPreCreatedClosure<TDelegate>(closureConstantsExprs, CompilerFlags.Default);

        /// <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/> 
        /// with the provided closure object and constant expressions (or lack there of)</summary>
        public static TDelegate TryCompileWithPreCreatedClosure<TDelegate>(this LambdaExpression lambdaExpr,
            ConstantExpression[] closureConstantsExprs, CompilerFlags flags)
            where TDelegate : class
        {
            var closureConstants = new object[closureConstantsExprs.Length];
            for (var i = 0; i < closureConstants.Length; i++)
                closureConstants[i] = closureConstantsExprs[i].Value;

            var closureInfo = new ClosureInfo(ClosureStatus.UserProvided | ClosureStatus.HasClosure, closureConstants);
            return TryCompileWithPreCreatedClosure<TDelegate>(lambdaExpr, ref closureInfo, flags);
        }

        internal static TDelegate TryCompileWithPreCreatedClosure<TDelegate>(
            this LambdaExpression lambdaExpr, ref ClosureInfo closureInfo, CompilerFlags flags) where TDelegate : class
        {
#if LIGHT_EXPRESSION
            var closurePlusParamTypes = RentOrNewClosureTypeToParamTypes(lambdaExpr);
#else
            var closurePlusParamTypes = RentOrNewClosureTypeToParamTypes(lambdaExpr.Parameters);
#endif
            var method = new DynamicMethod(string.Empty, lambdaExpr.ReturnType, closurePlusParamTypes,
                typeof(ExpressionCompiler), skipVisibility: true);

            var il = method.GetILGenerator();
            EmittingVisitor.EmitLoadConstantsAndNestedLambdasIntoVars(il, ref closureInfo);

            var parent = lambdaExpr.ReturnType == typeof(void) ? ParentFlags.IgnoreResult : ParentFlags.Empty;
            if (!EmittingVisitor.TryEmit(lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
                il, ref closureInfo, flags, parent))
                return null;

            il.Demit(OpCodes.Ret);

            var delegateType = typeof(TDelegate) != typeof(Delegate) ? typeof(TDelegate) : lambdaExpr.Type;
            var @delegate = (TDelegate)(object)method.CreateDelegate(delegateType, new ArrayClosure(closureInfo.Constants.Items));
            ReturnClosureTypeToParamTypesToPool(closurePlusParamTypes);
            return @delegate;
        }

        /// <summary>Tries to compile expression to "static" delegate, skipping the step of collecting the closure object.</summary>
        public static TDelegate TryCompileWithoutClosure<TDelegate>(this LambdaExpression lambdaExpr,
            CompilerFlags flags = CompilerFlags.Default) where TDelegate : class
        {
            var closureInfo = new ClosureInfo(ClosureStatus.UserProvided);
#if LIGHT_EXPRESSION
            var closurePlusParamTypes = RentOrNewClosureTypeToParamTypes(lambdaExpr);
#else
            var closurePlusParamTypes = RentOrNewClosureTypeToParamTypes(lambdaExpr.Parameters);
#endif
            var method = new DynamicMethod(string.Empty, lambdaExpr.ReturnType, closurePlusParamTypes, typeof(ArrayClosure),
                skipVisibility: true);

            var il = method.GetILGenerator();
            if (!EmittingVisitor.TryEmit(lambdaExpr.Body,
#if LIGHT_EXPRESSION
                lambdaExpr,
#else
                lambdaExpr.Parameters,
#endif
                il, ref closureInfo, flags, lambdaExpr.ReturnType == typeof(void) ? ParentFlags.IgnoreResult : ParentFlags.Empty))
                return null;

            il.Demit(OpCodes.Ret);

            var delegateType = typeof(TDelegate) != typeof(Delegate) ? typeof(TDelegate) : lambdaExpr.Type;
            var @delegate = (TDelegate)(object)method.CreateDelegate(delegateType, EmptyArrayClosure);
            ReturnClosureTypeToParamTypesToPool(closurePlusParamTypes);
            return @delegate;
        }

        private static Delegate CompileNoArgsNew(ConstructorInfo ctor, Type delegateType, Type[] closurePlusParamTypes, Type returnType)
        {
            var method = new DynamicMethod(string.Empty, returnType, closurePlusParamTypes, typeof(ArrayClosure), true);
            var il = method.GetILGenerator(16); // 16 is enough for maximum of 3 possible ops
            il.Demit(OpCodes.Newobj, ctor);
            if (returnType == typeof(void))
                il.Demit(OpCodes.Pop);
            il.Demit(OpCodes.Ret);
            return method.CreateDelegate(delegateType, EmptyArrayClosure);
        }

#if LIGHT_EXPRESSION
        internal static object TryCompileBoundToFirstClosureParam(Type delegateType, Expression bodyExpr, IParameterProvider paramExprs,
            Type[] closurePlusParamTypes, Type returnType, CompilerFlags flags)
        {
            if (bodyExpr is NoArgsNewClassIntrinsicExpression newNoArgs)
                return CompileNoArgsNew(newNoArgs.Constructor, delegateType, closurePlusParamTypes, returnType);
#else
        internal static object TryCompileBoundToFirstClosureParam(Type delegateType, Expression bodyExpr, IReadOnlyList<PE> paramExprs,
            Type[] closurePlusParamTypes, Type returnType, CompilerFlags flags)
        {
#endif
            // The method collects the info from the all nested lambdas deep down up-front and de-duplicates the lambdas as well.
            var closureInfo = new ClosureInfo(ClosureStatus.ToBeCollected);
            if (!TryCollectBoundConstants(ref closureInfo, bodyExpr, paramExprs, null, ref closureInfo.NestedLambdas, flags))
                return null;

            ArrayClosure closure;
            if ((flags & CompilerFlags.EnableDelegateDebugInfo) == 0)
            {
                closure = (closureInfo.Status & ClosureStatus.HasClosure) == 0
                    ? EmptyArrayClosure
                    : new ArrayClosure(closureInfo.GetArrayOfConstantsAndNestedLambdas());
            }
            else
            {   // todo: @feature add the debug info to the nested lambdas!
                var debugExpr = Lambda(delegateType, bodyExpr, paramExprs?.ToReadOnlyList() ?? Tools.Empty<PE>());
                var constantsAndNestedLambdas = (closureInfo.Status & ClosureStatus.HasClosure) == 0
                    ? null
                    : closureInfo.GetArrayOfConstantsAndNestedLambdas();
                closure = new DebugArrayClosure(constantsAndNestedLambdas, debugExpr);
            }

            var method = new DynamicMethod(string.Empty, returnType, closurePlusParamTypes, typeof(ArrayClosure), true);

            // todo: @perf can we just count the Expressions in the TryCollect phase and use it as N * 4 or something?
            var il = method.GetILGenerator();

            if (closure.ConstantsAndNestedLambdas != null)
                EmittingVisitor.EmitLoadConstantsAndNestedLambdasIntoVars(il, ref closureInfo);

            var parent = returnType == typeof(void) ? ParentFlags.IgnoreResult : ParentFlags.Empty;
            if (!EmittingVisitor.TryEmit(bodyExpr, paramExprs, il, ref closureInfo, flags, parent))
                return null;
            il.Demit(OpCodes.Ret);

            return method.CreateDelegate(delegateType, closure);
        }

        private static readonly Type[] _closureAsASingleParamType = { typeof(ArrayClosure) };
        private static readonly Type[][] _closureTypePlusParamTypesPool = new Type[8][]; // todo: @perf @mem could we use this for other Type arrays?

#if LIGHT_EXPRESSION
        private static Type[] RentOrNewClosureTypeToParamTypes(IParameterProvider paramExprs)
        {
            var count = paramExprs.ParameterCount;
#else
        private static Type[] RentOrNewClosureTypeToParamTypes(IReadOnlyList<PE> paramExprs)
        {
            var count = paramExprs.Count;
#endif
            if (count == 0)
                return _closureAsASingleParamType;

            if (count < 8)
            {
                var pooledClosureAndParamTypes = Interlocked.Exchange(ref _closureTypePlusParamTypesPool[count], null);
                if (pooledClosureAndParamTypes != null)
                {
                    for (var i = 0; i < count; i++)
                    {
                        var parameterExpr = paramExprs.GetParameter(i); // todo: @perf can we avoid calling virtual GetParameter() and maybe use intrinsic with NoByRef?
                        pooledClosureAndParamTypes[i + 1] = parameterExpr.IsByRef ? parameterExpr.Type.MakeByRefType() : parameterExpr.Type;
                    }
                    return pooledClosureAndParamTypes;
                }
            }

            // todo: @perf the code maybe simplified and then will be the candidate for the inlining
            var closureAndParamTypes = new Type[count + 1];
            closureAndParamTypes[0] = typeof(ArrayClosure);
            for (var i = 0; i < count; i++)
            {
                var parameterExpr = paramExprs.GetParameter(i);
                closureAndParamTypes[i + 1] = parameterExpr.IsByRef ? parameterExpr.Type.MakeByRefType() : parameterExpr.Type;
            }
            return closureAndParamTypes;
        }

        [MethodImpl((MethodImplOptions)256)]
        private static void ReturnClosureTypeToParamTypesToPool(Type[] closurePlusParamTypes)
        {
            var paramCount = closurePlusParamTypes.Length - 1;
            if (paramCount != 0 && paramCount < 8)
                Interlocked.Exchange(ref _closureTypePlusParamTypesPool[paramCount], closurePlusParamTypes); // todo: @perf we don't need the Interlocked here
        }

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

        /// <summary>Collects the lambda info for the compilation</summary>
        public sealed class NestedLambdaInfo
        {
            /// <summary>Compiled lambda</summary>
            public object Lambda; // todo: @perf can we use the NestedLambdaInfo itself instead of NestedLambdaWithConstantsAndNestedLambdas and avoid duplication in memory?

            /// <summary>The nested lambdas and their info</summary>
            public SmallList<NestedLambdaInfo> NestedLambdas;

            /// <summary>The lambda expression</summary>
            public LambdaExpression LambdaExpression;

            /// <summary>Parameters not passed through lambda parameter list But used inside lambda body.
            /// The top expression should Not contain not passed parameters.</summary>
            public SmallList<ParameterExpression> NonPassedParameters;

            /// <summary>Index of the compiled lambda in the parent lambda closure array</summary>
            public short LambdaVarIndex;

            /// <summary>Index of the variable which store the non-passed variables array before passing it to the closure constructor.
            /// It used to assign the closed variables from the outside of the nested lambda</summary>
            public short NonPassedParamsVarIndex;

            public NestedLambdaInfo(LambdaExpression lambdaExpression) => LambdaExpression = lambdaExpression;

            /// <summary>Returns the type of lambda</summary>
            public Type GetLambdaType() => (Lambda is NestedLambdaWithConstantsAndNestedLambdas n ? n.NestedLambda : Lambda).GetType();

            /// <summary>Compares 2 lambda expressions for equality</summary>
            public bool HasTheSameLambdaExpression(LambdaExpression lambda) => // todo: @unclear parameters or is comparing the body is enough?
                ReferenceEquals(LambdaExpression, lambda) ||
                ReferenceEquals(LambdaExpression.Body, lambda.Body)
#if LIGHT_EXPRESSION
                && LambdaExpression.ParameterCount == lambda.ParameterCount
#endif
                ;

            public override string ToString() =>
                $"Lambda: {(Lambda is NestedLambdaWithConstantsAndNestedLambdas n ? "compiled+closure" : Lambda != null ? "compiled" : "null")}, Expr: {LambdaExpression.ToString()}";
        }

        [Flags]
        public enum ClosureStatus : byte
        {
            ToBeCollected = 1,
            UserProvided = 1 << 1,
            HasClosure = 1 << 2,
            ShouldBeStaticMethod = 1 << 3
        }

        [DebuggerDisplay("Target:{Target}, InlinedLambdaInvokeIndex:{InlinedLambdaInvokeIndex}, ReturnVariableIndexPlusOneAndIsDefined:{ReturnVariableIndexPlusOneAndIsDefined}")]
        public struct LabelInfo
        {
            public object Target;
            public short InlinedLambdaInvokeIndex;
            public short ReturnVariableIndexPlusOneAndIsDefined;
            public Label Label;
            public Label ReturnLabel;
        }

        /// Track the info required to build a closure object + some context information not directly related to closure.
        public struct ClosureInfo
        {
            /// <summary>Tracks that the last emit was an address</summary>
            public bool LastEmitIsAddress;

            // Tracks the current block nesting count in the stack of blocks in Collect and Emit phase
            private ushort _blockCount;

            /// <summary>Tracks the use of the variables in the blocks stack per variable, 
            /// (uint) contains (ushort) BlockIndex in the upper bits and (ushort) VarIndex in the lower bits.
            /// to determine if variable is the local variable and in what block it's defined</summary>
            private FHashMap<PE, SmallList4<uint>,
                RefEq<PE>, FHashMap.SingleArrayEntries<PE, SmallList4<uint>, RefEq<PE>>
                > _varInBlockMap;

            /// The map of inlined invocations collected in TryCollect and then used in TryEmit
            internal FHashMap<InvocationExpression, Expression, RefEq<InvocationExpression>,
                FHashMap.SingleArrayEntries<InvocationExpression, Expression, RefEq<InvocationExpression>>
                > InlinedLambdaInvocationMap;

            /// Map the Labels to their Targets
            internal SmallList4<LabelInfo> Labels;

            /// This is required because we have the return from the nested lambda expression,
            /// and when inlined in the parent lambda it is no longer the return but just a jump to the label.
            internal short CurrentInlinedLambdaInvokeIndex;

            public ClosureStatus Status;

            /// Constant expressions to find an index (by reference) of constant expression from compiled expression.
            public SmallList<object> Constants;

            /// Constant usage count and variable index.
            /// It is a separate collection from the Constants because we directly convert later into the closure array
            public SmallList2<short> ConstantUsageThenVarIndex;

            /// <summary>Parameters not passed through lambda parameter list But used inside lambda body.
            /// The top expression should Not contain not passed parameters.</summary>
            public SmallList<ParameterExpression> NonPassedParameters;

            /// <summary>The nested lambdas and their info</summary>
            public SmallList<NestedLambdaInfo> NestedLambdas;

            /// <summary>Populates the info</summary>
            public ClosureInfo(ClosureStatus status)
            {
                Status = status;
                Constants = new SmallList<object>();
                LastEmitIsAddress = false;
                CurrentInlinedLambdaInvokeIndex = -1;
            }

            /// <summary>Populates info directly with provided closure object and constants.</summary>
            public ClosureInfo(ClosureStatus status, object[] constValues)
            {
                Status = status;

                Constants = new SmallList<object>(constValues ?? Tools.Empty<object>());
                if (constValues != null)
                    ConstantUsageThenVarIndex.InitCount(constValues.Length);

                LastEmitIsAddress = false;
                CurrentInlinedLambdaInvokeIndex = -1;
            }

            [MethodImpl((MethodImplOptions)256)]
            public bool ContainsConstantsOrNestedLambdas() => Constants.Count != 0 || NestedLambdas.Count != 0;

            public bool AddConstantOrIncrementUsageCount(object value)
            {
                Status |= ClosureStatus.HasClosure;
                var constItems = Constants.Items;
                var constIndex = Constants.Count - 1;
                while (constIndex != -1 && !ReferenceEquals(constItems[constIndex], value))
                    --constIndex;
                if (constIndex == -1)
                {
                    Constants.Append(value);
                    ConstantUsageThenVarIndex.Append(1);
                }
                else
                {
                    ++ConstantUsageThenVarIndex.GetSurePresentItemRef(constIndex);
                }
                return true; // here for fluency, don't delete
            }

            public void AddLabel(LabelTarget labelTarget, short inlinedLambdaInvokeIndex = -1)
            {
                // skip null labelTargets, e.g. it may be the case for LoopExpression.Continue
                if (labelTarget == null)
                    return;
                GetLabelOrInvokeIndexByTarget(ref Labels, labelTarget, out var found);
                if (!found)
                {
                    ref var label = ref Labels.AppendDefaultAndGetRef();
                    label.Target = labelTarget;
                    label.InlinedLambdaInvokeIndex = inlinedLambdaInvokeIndex;
                }
            }

            public short AddInlinedLambdaInvoke(InvocationExpression e)
            {
                var count = Labels.Count;
                for (var i = 0; i < count; ++i)
                    if (Labels.GetSurePresentItemRef(i).Target == e)
                        return (short)i;

                ref var label = ref Labels.AppendDefaultAndGetRef();
                label.Target = e;
                return (short)count;
            }

            public object[] GetArrayOfConstantsAndNestedLambdas()
            {
                var constCount = Constants.Count;
                var nestedLambdasCount = NestedLambdas.Count;
                if (constCount == 0)
                {
                    if (nestedLambdasCount == 0)
                        return null;

                    var lambdaObjects = new object[nestedLambdasCount];
                    for (var i = 0; i < lambdaObjects.Length; i++)
                        lambdaObjects[i] = NestedLambdas.Items[i].Lambda;
                    return lambdaObjects;
                }

                // if constants `count != 0`
                var constItems = Constants.Items;
                if (nestedLambdasCount == 0)
                    return constItems;

                var constPlusLambdaCount = constCount + nestedLambdasCount;

                if (constItems.Length < constPlusLambdaCount)
                    Array.Resize(ref constItems, constPlusLambdaCount);

                for (var i = 0; i < nestedLambdasCount; ++i)
                    constItems[constCount + i] = NestedLambdas.Items[i].Lambda;

                return constItems;
            }

            /// Local variable index is not known in the collecting phase when we only need to decide if ParameterExpression is an actual parameter or variable
            [RequiresUnreferencedCode(Trimming.Message)]
            public void PushBlockWithVars(ParameterExpression blockVarExpr) =>
                PushVarInBlockMap(blockVarExpr, _blockCount++, 0);

            [RequiresUnreferencedCode(Trimming.Message)]
            public void PushBlockWithVars(ParameterExpression blockVarExpr, int varIndex) =>
                PushVarInBlockMap(blockVarExpr, _blockCount++, (ushort)varIndex);

            [RequiresUnreferencedCode(Trimming.Message)]
            public void PushBlockWithVars(IReadOnlyList<PE> blockVarExprs)
            {
                for (var i = 0; i < blockVarExprs.Count; i++)
                    PushVarInBlockMap(blockVarExprs[i], _blockCount, 0);
                ++_blockCount;
            }

            [RequiresUnreferencedCode(Trimming.Message)]
            public void PushBlockAndConstructLocalVars(IReadOnlyList<PE> blockVarExprs, ILGenerator il)
            {
                for (var i = 0; i < blockVarExprs.Count; i++)
                {
                    var varExpr = blockVarExprs[i];
                    var varType = varExpr.Type;
                    if (varExpr.IsByRef && !varType.IsByRef)
                        varType = varType.MakeByRefType();
                    PushVarInBlockMap(varExpr, _blockCount, (ushort)il.GetNextLocalVarIndex(varType));
                }
                ++_blockCount;
            }

            [MethodImpl((MethodImplOptions)256)]
            private void PushVarInBlockMap(ParameterExpression pe, ushort blockIndex, ushort varIndex)
            {
                ref var blocks = ref _varInBlockMap.GetOrAddValueRef(pe, out _);
                if (blocks.Count == 0 || (blocks.GetLastSurePresentItem() >>> 16) != blockIndex)
                    blocks.Append((uint)(blockIndex << 16) | varIndex);
            }

            public void PopBlock()
            {
                Debug.Assert(_blockCount > 0);
                var varCount = _varInBlockMap.Count;
                for (var i = 0; i < varCount; ++i)
                {
                    ref var varBlocks = ref _varInBlockMap.GetSurePresentEntryRef(i);
                    if (varBlocks.Value.Count == _blockCount)
                        varBlocks.Value.RemoveLastSurePresentItem();
                }
                --_blockCount;
            }

            [MethodImpl((MethodImplOptions)256)]
            public bool IsLocalVar(ParameterExpression varParamExpr)
            {
                ref var blocks = ref _varInBlockMap.TryGetValueRef(varParamExpr, out var found);
                return found & blocks.Count != 0;
            }

            [MethodImpl((MethodImplOptions)256)]
            public int GetDefinedLocalVarOrDefault(ParameterExpression varParamExpr)
            {
                ref var blocks = ref _varInBlockMap.TryGetValueRef(varParamExpr, out var found);
                return found & blocks.Count != 0 // rare case with the block count 0 may occur when we collected the block and vars, but not yet defined the variable for it
                    ? (int)(blocks.GetLastSurePresentItem() & ushort.MaxValue)
                    : -1;
            }
        }

        internal static ref LabelInfo GetLabelOrInvokeIndexByTarget(ref this SmallList4<LabelInfo> labels, object labelTarget, out bool found)
        {
            var count = labels.Count;
            for (var i = 0; i < count; ++i) // todo: @perf make this loop into the SmallList method to avoid index check on each item
            {
                ref var label = ref labels.GetSurePresentItemRef(i);
                if (label.Target == labelTarget)
                {
                    found = true;
                    return ref label;
                }
            }
            found = false;
            return ref labels.NotFound();
        }

        [MethodImpl((MethodImplOptions)256)]
        private static Label GetOrDefineLabel(ref this LabelInfo label, ILGenerator il)
        {
            if ((label.ReturnVariableIndexPlusOneAndIsDefined & 1) == 0)
            {
                label.Label = il.DefineLabel();
                label.ReturnVariableIndexPlusOneAndIsDefined |= 1;
            }
            return label.Label;
        }

        public static readonly ArrayClosure EmptyArrayClosure = new ArrayClosure(null);

        public static FieldInfo ArrayClosureArrayField =
            typeof(ArrayClosure).GetField(nameof(ArrayClosure.ConstantsAndNestedLambdas));

        public static FieldInfo ArrayClosureWithNonPassedParamsField =
            typeof(ArrayClosureWithNonPassedParams).GetField(nameof(ArrayClosureWithNonPassedParams.NonPassedParams));

        private static ConstructorInfo[] _nonPassedParamsArrayClosureCtors = typeof(ArrayClosureWithNonPassedParams).GetConstructors();

        public static ConstructorInfo ArrayClosureWithNonPassedParamsConstructor = _nonPassedParamsArrayClosureCtors[0];

        public static ConstructorInfo ArrayClosureWithNonPassedParamsConstructorWithoutConstants = _nonPassedParamsArrayClosureCtors[1];

        public static Result NotSupported_RuntimeVariables { get; private set; }

        public class ArrayClosure
        {
            public readonly object[] ConstantsAndNestedLambdas; // todo: @feature split into two to reduce copying - it mostly need to set up nested lambdas and constants externally without closure collecting phase
            public ArrayClosure(object[] constantsAndNestedLambdas) => ConstantsAndNestedLambdas = constantsAndNestedLambdas;
        }

        [RequiresUnreferencedCode(Trimming.Message)]
        public sealed class DebugArrayClosure : ArrayClosure, IDelegateDebugInfo
        {
            public LambdaExpression Expression { get; internal set; }

            private readonly Lazy<string> _expressionString;
            public string ExpressionString => _expressionString.Value;

            private readonly Lazy<string> _csharpString;
            public string CSharpString => _csharpString.Value;
            public DebugArrayClosure(object[] constantsAndNestedLambdas, LambdaExpression expr)
                : base(constantsAndNestedLambdas)
            {
                Expression = expr;
                _expressionString = new Lazy<string>(() => Expression?.ToExpressionString() ?? "<expression is not available>");
                _csharpString = new Lazy<string>(() => Expression?.ToCSharpString() ?? "<expression is not available>");
            }
        }

        public static bool TryGetDebugClosureNestedLambdaOrConstant(this Delegate parentLambda, out object item, int itemIndex = 0)
        {
            var target = parentLambda.Target;
            if (target is ExpressionCompiler.DebugArrayClosure t)
            {
                var closureItems = t.ConstantsAndNestedLambdas;
                if (itemIndex < closureItems.Length)
                {
                    item = closureItems[itemIndex];
                    return true;
                }
            }
            item = null;
            return false;
        }

        public static bool TryGetDebugClosureNestedLambda(this Delegate parentLambda, int itemIndex, out Delegate d)
        {
            var target = parentLambda.Target;
            if (target is ExpressionCompiler.DebugArrayClosure t)
            {
                var closureItems = t.ConstantsAndNestedLambdas;
                if (itemIndex < closureItems.Length)
                {
                    d = (Delegate)closureItems[itemIndex];
                    return true;
                }
            }
            d = null;
            return false;
        }

        // todo: @perf better to move the case with no constants to another class OR we can reuse ArrayClosure but now ConstantsAndNestedLambdas will hold NonPassedParams
        public sealed class ArrayClosureWithNonPassedParams : ArrayClosure
        {
            public readonly object[] NonPassedParams;

            public ArrayClosureWithNonPassedParams(object[] constantsAndNestedLambdas, object[] nonPassedParams) : base(constantsAndNestedLambdas) =>
                NonPassedParams = nonPassedParams;

            // todo: @perf optimize for this case
            public ArrayClosureWithNonPassedParams(object[] nonPassedParams) : base(null) =>
                NonPassedParams = nonPassedParams;
        }

        // todo: @perf this class is required until we move to a single constants list per lambda hierarchy 
        public sealed class NestedLambdaWithConstantsAndNestedLambdas
        {
            public static FieldInfo NestedLambdaField =
                typeof(NestedLambdaWithConstantsAndNestedLambdas).GetTypeInfo().GetDeclaredField(nameof(NestedLambda));

            public static FieldInfo ConstantsAndNestedLambdasField =
                typeof(NestedLambdaWithConstantsAndNestedLambdas).GetTypeInfo().GetDeclaredField(nameof(ConstantsAndNestedLambdas));

            public readonly object NestedLambda;
            public readonly object ConstantsAndNestedLambdas;
            public NestedLambdaWithConstantsAndNestedLambdas(object nestedLambda, object constantsAndNestedLambdas)
            {
                NestedLambda = nestedLambda;
                ConstantsAndNestedLambdas = constantsAndNestedLambdas;
            }
        }

        internal static class CurryClosureFuncs
        {
            public static readonly MethodInfo[] Methods = typeof(CurryClosureFuncs).GetMethods();

            // todo: @mem @perf can we avoid closure creation over `f` and `c`?
            public static Func<R> Curry<C, R>(Func<C, R> f, C c) =>
                () => f(c);

            public static Func<T1, R> Curry<C, T1, R>(Func<C, T1, R> f, C c) =>
                t1 => f(c, t1);

            public static Func<T1, T2, R> Curry<C, T1, T2, R>(Func<C, T1, T2, R> f, C c) =>
                (t1, t2) => f(c, t1, t2);

            public static Func<T1, T2, T3, R> Curry<C, T1, T2, T3, R>(Func<C, T1, T2, T3, R> f, C c) =>
                (t1, t2, t3) => f(c, t1, t2, t3);

            public static Func<T1, T2, T3, T4, R> Curry<C, T1, T2, T3, T4, R>(Func<C, T1, T2, T3, T4, R> f, C c) =>
                (t1, t2, t3, t4) => f(c, t1, t2, t3, t4);

            public static Func<T1, T2, T3, T4, T5, R> Curry<C, T1, T2, T3, T4, T5, R>(Func<C, T1, T2, T3, T4, T5, R> f,
                C c) => (t1, t2, t3, t4, t5) => f(c, t1, t2, t3, t4, t5);

            public static Func<T1, T2, T3, T4, T5, T6, R>
                Curry<C, T1, T2, T3, T4, T5, T6, R>(Func<C, T1, T2, T3, T4, T5, T6, R> f, C c) =>
                (t1, t2, t3, t4, t5, t6) => f(c, t1, t2, t3, t4, t5, t6);

            public static Func<T1, T2, T3, T4, T5, T6, T7, R>
                Curry<C, T1, T2, T3, T4, T5, T6, T7, R>(Func<C, T1, T2, T3, T4, T5, T6, T7, R> f, C c) =>
                (t1, t2, t3, t4, t5, t6, t7) => f(c, t1, t2, t3, t4, t5, t6, t7);

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, R>
                Curry<C, T1, T2, T3, T4, T5, T6, T7, T8, R>(Func<C, T1, T2, T3, T4, T5, T6, T7, T8, R> f, C c) =>
                (t1, t2, t3, t4, t5, t6, t7, t8) => f(c, t1, t2, t3, t4, t5, t6, t7, t8);

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>
                Curry<C, T1, T2, T3, T4, T5, T6, T7, T8, T9, R>(Func<C, T1, T2, T3, T4, T5, T6, T7, T8, T9, R> f, C c) =>
                (t1, t2, t3, t4, t5, t6, t7, t8, t9) => f(c, t1, t2, t3, t4, t5, t6, t7, t8, t9);

            public static Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>
                Curry<C, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>(Func<C, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> f, C c) =>
                (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) => f(c, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10);
        }

        internal static class CurryClosureActions
        {
            public static readonly MethodInfo[] Methods = typeof(CurryClosureActions).GetMethods();

            public static Action Curry<C>(Action<C> a, C c) =>
                () => a(c);

            public static Action<T1> Curry<C, T1>(Action<C, T1> f, C c) =>
                t1 => f(c, t1);

            public static Action<T1, T2> Curry<C, T1, T2>(Action<C, T1, T2> f, C c) =>
                (t1, t2) => f(c, t1, t2);

            public static Action<T1, T2, T3> Curry<C, T1, T2, T3>(Action<C, T1, T2, T3> f, C c) =>
                (t1, t2, t3) => f(c, t1, t2, t3);

            public static Action<T1, T2, T3, T4> Curry<C, T1, T2, T3, T4>(Action<C, T1, T2, T3, T4> f, C c) =>
                (t1, t2, t3, t4) => f(c, t1, t2, t3, t4);

            public static Action<T1, T2, T3, T4, T5> Curry<C, T1, T2, T3, T4, T5>(Action<C, T1, T2, T3, T4, T5> f,
                C c) => (t1, t2, t3, t4, t5) => f(c, t1, t2, t3, t4, t5);

            public static Action<T1, T2, T3, T4, T5, T6>
                Curry<C, T1, T2, T3, T4, T5, T6>(Action<C, T1, T2, T3, T4, T5, T6> f, C c) =>
                (t1, t2, t3, t4, t5, t6) => f(c, t1, t2, t3, t4, t5, t6);

            public static Action<T1, T2, T3, T4, T5, T6, T7>
                Curry<C, T1, T2, T3, T4, T5, T6, T7>(Action<C, T1, T2, T3, T4, T5, T6, T7> f, C c) =>
                (t1, t2, t3, t4, t5, t6, t7) => f(c, t1, t2, t3, t4, t5, t6, t7);

            public static Action<T1, T2, T3, T4, T5, T6, T7, T8>
                Curry<C, T1, T2, T3, T4, T5, T6, T7, T8>(Action<C, T1, T2, T3, T4, T5, T6, T7, T8> f, C c) =>
                (t1, t2, t3, t4, t5, t6, t7, t8) => f(c, t1, t2, t3, t4, t5, t6, t7, t8);

            public static Action<T1, T2, T3, T4, T5, T6, T7, T8, T9>
                Curry<C, T1, T2, T3, T4, T5, T6, T7, T8, T9>(Action<C, T1, T2, T3, T4, T5, T6, T7, T8, T9> f, C c) =>
                (t1, t2, t3, t4, t5, t6, t7, t8, t9) => f(c, t1, t2, t3, t4, t5, t6, t7, t8, t9);

            public static Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
                Curry<C, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(Action<C, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> f, C c) =>
                (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) => f(c, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10);
        }

        #region Collect Bound Constants

        /// Helps to identify constants as the one to be put into the Closure
        public static bool IsClosureBoundConstant(object value, Type type) =>
            value is Delegate || type.IsArray ||
            !type.IsPrimitive && !type.IsEnum && value is string == false && value is Type == false && value is decimal == false;

        public enum Result
        {
            OK = 0,
            ExpressionIsNull = 1,
            ParameterIsNotVariableNorInPassedParameters = 2,
            NestedLambdaCompileError = 102,
            NotSupported_UnknownExpression = 1000,
            /// <summary>Multi-dimensional array initializer is not supported</summary>
            NotSupported_NewArrayInit_MultidimensionalArray = 1001,
            /// <summary>Quote is not supported</summary>
            NotSupported_Quote = 1002,
            /// <summary>Dynamic is not supported</summary>
            NotSupported_Dynamic = 1003,
            /// <summary>RuntimeVariables is not supported</summary>
            NotSupported_RuntimeVariables = 1004,
            /// <summary>MemberInit MemberBinding is not supported</summary>
            NotSupported_MemberInit_MemberBinding = 1005,
            /// <summary>MemberInit ListBinding is not supported</summary>
            NotSupported_MemberInit_ListBinding = 1006,
            /// <summary>Goto of the Return kind from the TryCatch is not supported</summary>
            NotSupported_Try_GotoReturnToTheFollowupLabel = 1007,
            /// <summary>Not supported assignment target</summary>
            NotSupported_Assign_Target = 1008,
            /// <summary>TypeEqual is not supported </summary>
            NotSupported_TypeEqual = 1009,
            /// <summary>`when` in catch is not supported yet</summary>
            NotSupported_ExceptionCatchFilter = 1010
        }

        /// <summary>Wraps the call to `TryCollectInfo` for the compatibility and provide the root place to check the returned error code.
        /// Imprtant: The method collects the info from the nested lambdas up-front and de-duplicates the lambdas as well.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryCollectBoundConstants(ref ClosureInfo closure, Expression expr,
#if LIGHT_EXPRESSION
            IParameterProvider paramExprs, // `paramExprs` are required for nested lambda compilation
#else
            IReadOnlyList<PE> paramExprs,
#endif
            NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas, CompilerFlags flags)
        {
            var r = TryCollectInfo(ref closure, expr, paramExprs, nestedLambda, ref rootNestedLambdas, flags);
            if (r != Result.OK & (flags & CompilerFlags.ThrowOnNotSupportedExpression) != 0)
                throw new NotSupportedExpressionException(r);
            return true; // exposed here for debugging to set a breakpoint
        }

        /// <summary>Collects the information about closure constants, nested lambdas, non-passed parameters, goto labels and variables in blocks.
        /// Returns `OK` result if everything is fine and other result for error.</summary>
        public static Result TryCollectInfo(ref ClosureInfo closure, Expression expr,
#if LIGHT_EXPRESSION
            IParameterProvider paramExprs,
#else
            IReadOnlyList<PE> paramExprs,
#endif
            NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas, CompilerFlags flags)
        {
            var r = Result.OK;
            while (true)
            {
                if (expr == null)
                    return Result.ExpressionIsNull;
#if LIGHT_EXPRESSION
                if (expr.IsIntrinsic)
                    return expr.TryCollectInfo(flags, ref closure, paramExprs, nestedLambda, ref rootNestedLambdas);
#endif
                switch (expr.NodeType)
                {
                    case ExpressionType.Constant:
#if LIGHT_EXPRESSION
                        // todo: @perf @simplify convert to intrinsic
                        if (expr == NullConstant || expr == FalseConstant || expr == TrueConstant || expr is IntConstantExpression n)
                            return r;
#endif
                        var constantExpr = (ConstantExpression)expr;
                        var value = constantExpr.Value;
                        if (value != null && IsClosureBoundConstant(value, value.GetType()))
                            closure.AddConstantOrIncrementUsageCount(value);
                        return Result.OK;

                    case ExpressionType.Parameter:
                        {
#if LIGHT_EXPRESSION
                            var paramCount = paramExprs.ParameterCount;
#else
                            var paramCount = paramExprs.Count;
#endif
                            // if parameter is used BUT is not in passed parameters and not in local variables,
                            // it means parameter is provided by outer lambda and should be put in closure for current lambda
                            var p = paramCount - 1;
                            var parExpr = (PE)expr;
                            while (p != -1 && !ReferenceEquals(paramExprs.GetParameter(p), parExpr)) --p;
                            if (p == -1 && !closure.IsLocalVar(parExpr))
                            {
                                if (nestedLambda == null) // means that we are in the root lambda
                                    return Result.ParameterIsNotVariableNorInPassedParameters;
                                closure.Status |= ClosureStatus.HasClosure;
                                nestedLambda.NonPassedParameters.GetIndexOrAppend(parExpr, default(RefEq<ParameterExpression>));
                            }
                            return Result.OK;
                        }
                    case ExpressionType.Call:
                        {
                            var callExpr = (MethodCallExpression)expr;
                            var callObjectExpr = callExpr.Object;

#if SUPPORTS_ARGUMENT_PROVIDER
                            var callArgs = (IArgumentProvider)callExpr;
#else
                            var callArgs = callExpr.Arguments;
#endif
                            var argCount = callArgs.GetCount();
                            if (argCount == 0)
                            {
                                if (callObjectExpr != null)
                                {
                                    expr = callObjectExpr;
                                    continue;
                                }
                                return Result.OK;
                            }

                            if (callObjectExpr != null &&
                                (r = TryCollectInfo(ref closure, callExpr.Object, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                                return r;

                            var lastArgIndex = argCount - 1;
                            for (var i = 0; i < lastArgIndex; i++)
                                if ((r = TryCollectInfo(ref closure, callArgs.GetArgument(i), paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                                    return r;
                            expr = callArgs.GetArgument(lastArgIndex);
                            continue;
                        }

                    case ExpressionType.MemberAccess:
                        var memberExpr = ((MemberExpression)expr).Expression;
                        if (memberExpr == null)
                            return r;
                        expr = memberExpr;
                        continue;

                    case ExpressionType.New:
                        {
                            var newExpr = (NewExpression)expr;
#if SUPPORTS_ARGUMENT_PROVIDER
                            var ctorArgs = (IArgumentProvider)newExpr;
#else
                            var ctorArgs = newExpr.Arguments;
#endif
                            var argCount = ctorArgs.GetCount();
                            if (argCount == 0)
                                return r;
                            var lastArgIndex = argCount - 1;
                            for (var i = 0; i < lastArgIndex; i++)
                                if ((r = TryCollectInfo(ref closure, ctorArgs.GetArgument(i), paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                                    return r;
                            expr = ctorArgs.GetArgument(lastArgIndex);
                            continue;
                        }
                    case ExpressionType.NewArrayBounds:
                    case ExpressionType.NewArrayInit:
                        // todo: @feature multi-dimensional array initializers are not supported yet, they also are not supported by the hoisted expression
                        if (expr.NodeType == ExpressionType.NewArrayInit && expr.Type.GetArrayRank() > 1)
                            return Result.NotSupported_NewArrayInit_MultidimensionalArray;
#if LIGHT_EXPRESSION
                        var arrElems = (IArgumentProvider)expr;
                        var elemCount = arrElems.ArgumentCount;
#else
                        var arrElems = ((NewArrayExpression)expr).Expressions;
                        var elemCount = arrElems.Count;
#endif
                        if (elemCount == 0)
                            return r;
                        for (var i = 0; i < elemCount - 1; i++)
                            if ((r = TryCollectInfo(ref closure, arrElems.GetArgument(i), paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                                return r;
                        expr = arrElems.GetArgument(elemCount - 1);
                        continue;

                    case ExpressionType.MemberInit:
                        return TryCollectMemberInitExprConstants(
                            ref closure, (MemberInitExpression)expr, paramExprs, nestedLambda, ref rootNestedLambdas, flags);

                    case ExpressionType.ListInit:
                        return TryCollectListInitExprConstants(
                            ref closure, (ListInitExpression)expr, paramExprs, nestedLambda, ref rootNestedLambdas, flags);

                    case ExpressionType.Lambda:
                        // Here we look if the lambda is already stored in the nested lambdas tree (Collected+Compiled),
                        // or if not found it Collects+Compiles the nested lambda here and adds to the nested lambda tree.
                        var nestedLambdaExpr = (LambdaExpression)expr;

#if LIGHT_EXPRESSION // todo: @simplify can we do better?
                        var nestedParamExprs = (IParameterProvider)nestedLambdaExpr;
#else
                        var nestedParamExprs = nestedLambdaExpr.Parameters;
#endif
                        closure.Status |= ClosureStatus.HasClosure;

                        // Look for the already collected lambdas starting from the root
                        if (rootNestedLambdas.Count != 0 &&
                            FindAlreadyCompiledNestedLambdaInfoInLambdas(ref rootNestedLambdas, nestedLambdaExpr, out var compiledNestedLambda))
                        {
                            if (nestedLambda != null)
                                nestedLambda.NestedLambdas.Append(compiledNestedLambda);
                            else
                                rootNestedLambdas.Append(compiledNestedLambda);
                            if (compiledNestedLambda.NonPassedParameters.Count != 0 &&
                                !PropagateNonPassedParamsToOuterLambda(ref closure, nestedLambda, paramExprs, nestedParamExprs, ref compiledNestedLambda.NonPassedParameters))
                                return Result.ParameterIsNotVariableNorInPassedParameters;
                            return r;
                        }

                        var nestedClosureInfo = new ClosureInfo(ClosureStatus.ToBeCollected);
                        var newNestedLambda = new NestedLambdaInfo(nestedLambdaExpr);

                        if (nestedLambda != null)
                            nestedLambda.NestedLambdas.Append(newNestedLambda);
                        else
                            rootNestedLambdas.Append(newNestedLambda);

                        if ((r = TryCollectInfo(ref nestedClosureInfo, nestedLambdaExpr.Body, nestedParamExprs, newNestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                            return r;

                        if (newNestedLambda.NonPassedParameters.Count != 0 &&
                            !PropagateNonPassedParamsToOuterLambda(ref closure, nestedLambda, paramExprs, nestedParamExprs, ref newNestedLambda.NonPassedParameters))
                            return Result.ParameterIsNotVariableNorInPassedParameters;

                        if (!TryCompileNestedLambda(ref nestedClosureInfo, newNestedLambda, flags))
                            return Result.NestedLambdaCompileError;

                        return r;

                    case ExpressionType.Invoke:
                        {
                            var invokeExpr = (InvocationExpression)expr;
#if SUPPORTS_ARGUMENT_PROVIDER
                            var invokeArgs = (IArgumentProvider)invokeExpr;
#else
                            var invokeArgs = invokeExpr.Arguments;
#endif
                            var invokeArgCount = invokeArgs.GetCount();
                            var invokedExpr = invokeExpr.Expression;
                            if ((flags & CompilerFlags.NoInvocationLambdaInlining) == 0 && invokedExpr is LambdaExpression lambdaExpr)
                            {
                                var oldIndex = closure.CurrentInlinedLambdaInvokeIndex;
                                closure.CurrentInlinedLambdaInvokeIndex = closure.AddInlinedLambdaInvoke(invokeExpr); // todo: @wip check that the invoke expression actually contains Return(LabelTarget), BUT what if it is a conditional expression without return, what happens when inlining? 

                                ref var inlinedExpr = ref closure.InlinedLambdaInvocationMap.GetOrAddValueRef(invokeExpr, out var found);
                                if (!found)
                                    inlinedExpr = CreateInlinedLambdaInvocationExpression(invokeArgs, invokeArgCount, lambdaExpr);

                                if ((r = TryCollectInfo(ref closure, inlinedExpr, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                                    return r;

                                closure.CurrentInlinedLambdaInvokeIndex = oldIndex;
                                return r;
                            }

                            // No inlining, collect the normal way
                            if (invokeArgCount == 0)
                            {
                                expr = invokedExpr;
                                continue;
                            }

                            if ((r = TryCollectInfo(ref closure, invokedExpr, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                                return r;

                            var lastArgIndex = invokeArgCount - 1;
                            for (var i = 0; i < lastArgIndex; i++)
                                if ((r = TryCollectInfo(ref closure, invokeArgs.GetArgument(i), paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                                    return r;
                            expr = invokeArgs.GetArgument(lastArgIndex);
                            continue;
                        }
                    case ExpressionType.Conditional:
                        var condExpr = (ConditionalExpression)expr;
                        if ((r = TryCollectInfo(ref closure, condExpr.Test, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ||
                            (r = TryCollectInfo(ref closure, condExpr.IfFalse, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                            return r;
                        expr = condExpr.IfTrue;
                        continue;

                    case ExpressionType.Block:
                        var blockExpr = (BlockExpression)expr;
                        var blockExprs = blockExpr.Expressions;
                        var blockExprCount = blockExprs.Count;
                        if (blockExprCount == 0)
                            return r; // yeah, this is the real case - the block may not contain any expressions

                        var varExprs = blockExpr.Variables;
                        var varExprCount = varExprs?.Count ?? 0; // todo: @perf optimize for an empty and a single variable

                        if (varExprCount == 1 & blockExprCount == 2 &&
                            blockExprs[0] is BinaryExpression st0 && st0.NodeType == ExpressionType.Assign &&
                            blockExprs[1] is BinaryExpression st1 && st1.NodeType == ExpressionType.Assign &&
                            st0.Left == blockExprs[0] && st1.Right == blockExprs[0])
                        {
                            if ((r = TryCollectInfo(ref closure, st0.Right, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                                return r;
                            expr = st1.Left;
                            continue;
                        }

                        if (varExprCount == 1)
                            closure.PushBlockWithVars(varExprs[0]);
                        else if (varExprCount != 0)
                            closure.PushBlockWithVars(varExprs);

                        for (var i = 0; i < blockExprCount - 1; i++)
                            if ((r = TryCollectInfo(ref closure, blockExprs[i], paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                                return r;

                        expr = blockExprs[blockExprCount - 1];
                        if (varExprCount == 0)
                            continue; // in case of no variables we can collect the last expr without recursion

                        if ((r = TryCollectInfo(ref closure, expr, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                            return r;
                        closure.PopBlock();
                        return r;

                    case ExpressionType.Loop:
                        var loopExpr = (LoopExpression)expr;
                        closure.AddLabel(loopExpr.BreakLabel);
                        closure.AddLabel(loopExpr.ContinueLabel);
                        expr = loopExpr.Body;
                        continue;

                    case ExpressionType.Index:
                        var indexExpr = (IndexExpression)expr;
#if SUPPORTS_ARGUMENT_PROVIDER
                        var indexArgs = (IArgumentProvider)indexExpr;
#else
                        var indexArgs = indexExpr.Arguments;
#endif
                        var indexArgCount = indexArgs.GetCount();
                        for (var i = 0; i < indexArgCount; i++)
                            if ((r = TryCollectInfo(ref closure, indexArgs.GetArgument(i), paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                                return r;
                        if (indexExpr.Object == null)
                            return r;
                        expr = indexExpr.Object;
                        continue;

                    case ExpressionType.Try:
                        return TryCollectTryExprConstants(ref closure, (TryExpression)expr, paramExprs, nestedLambda, ref rootNestedLambdas, flags);

                    case ExpressionType.Label:
                        var labelExpr = (LabelExpression)expr;
                        closure.AddLabel(labelExpr.Target, closure.CurrentInlinedLambdaInvokeIndex);
                        if (labelExpr.DefaultValue == null)
                            return r;
                        expr = labelExpr.DefaultValue;
                        continue;

                    case ExpressionType.Goto:
                        var gotoExpr = (GotoExpression)expr;
                        if (gotoExpr.Value == null)
                            return r;
                        expr = gotoExpr.Value;
                        continue;

                    case ExpressionType.Switch:
                        var switchExpr = ((SwitchExpression)expr);
                        if ((r = TryCollectInfo(ref closure, switchExpr.SwitchValue, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ||
                            switchExpr.DefaultBody != null &&
                            (r = TryCollectInfo(ref closure, switchExpr.DefaultBody, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                            return r;
                        var switchCases = switchExpr.Cases;
                        for (var i = 0; i < switchCases.Count - 1; i++)
                            if ((r = TryCollectInfo(ref closure, switchCases[i].Body, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                                return r;
                        expr = switchCases[switchCases.Count - 1].Body;
                        continue;

                    case ExpressionType.Extension:
                        expr = expr.Reduce();
                        continue;

                    case ExpressionType.Default:
                        return r;

                    case ExpressionType.TypeIs:
                    case ExpressionType.TypeEqual:
                        expr = ((TypeBinaryExpression)expr).Expression;
                        continue;

                    case ExpressionType.Quote:            // todo: @feature - is not supported yet
                        return Result.NotSupported_Quote;
                    case ExpressionType.Dynamic:          // todo: @feature - is not supported yet
                        return Result.NotSupported_Dynamic;
                    case ExpressionType.RuntimeVariables: // todo: @feature - is not supported yet
                        return NotSupported_RuntimeVariables;

                    case ExpressionType.DebugInfo: // todo: @feature - is not supported yet
                        return r;                  // todo: @unclear - just ignoring the info for now

                    default:
                        if (expr is UnaryExpression unaryExpr)
                        {
                            if (unaryExpr.Operand is null)
                                return r;
                            expr = unaryExpr.Operand;
                            continue;
                        }

                        if (expr is BinaryExpression binaryExpr)
                        {
                            if ((r = TryCollectInfo(ref closure, binaryExpr.Left, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                                return r;
                            expr = binaryExpr.Right;
                            continue;
                        }

                        return Result.NotSupported_UnknownExpression;
                }
            }
        }

        private static Expression CreateInlinedLambdaInvocationExpression(
#if SUPPORTS_ARGUMENT_PROVIDER
            IArgumentProvider invokeArgs,
#else
            IReadOnlyList<Expression> invokeArgs,
#endif
            int invokeArgCount, LambdaExpression lambdaExpr)
        {
            // Check the actual lambda return type in case it differs from the Body type,
            // e.g. often case for the Action lambdas where the Body type is ignored in favor of `void`. 
            var lambdaReturnType = lambdaExpr.ReturnType;
            var lambdaBodyExpr = lambdaExpr.Body;
            if (invokeArgCount == 0)
                return lambdaReturnType == lambdaBodyExpr.Type ? lambdaBodyExpr :
                lambdaReturnType == typeof(void) ? Block(typeof(void), lambdaBodyExpr) :
                Convert(lambdaBodyExpr, lambdaReturnType);

            // To inline the lambda we will wrap its body into a block, parameters into the block variables, 
            // and the invocation arguments into the variable assignments, see #278.
#if LIGHT_EXPRESSION
            var lambdaPars = (IParameterProvider)lambdaExpr;
#else
            var lambdaPars = lambdaExpr.Parameters;
#endif
            SmallList2<Expression> inlinedBlockExprs = default;
            SmallList2<ParameterExpression> savedVars = default;
            SmallList2<Expression> savedVarsBlockExprs = default;

            for (var i = 0; i < invokeArgCount; i++)
            {
                var lambdaPar = lambdaPars.GetParameter(i);
                var invokeArg = invokeArgs.GetArgument(i);

                // The case of reusing the parameters or variables in the different lambdas, 
                // see the test `NestedLambdaTests.Hmm_I_can_use_the_same_parameter_for_outer_and_nested_lambda`
                // and the `Issue401_What_happens_if_inlined_invocation_of_lambda_overrides_the_same_parameter`.
                if (lambdaPar == invokeArg)
                {
                    var savedPar = Parameter(lambdaPar.Type, lambdaPar.Name + "_" + lambdaPar.GetHashCode().ToString());
                    savedVars.Add(savedPar);
                    savedVarsBlockExprs.Add(Assign(savedPar, invokeArg));
                    inlinedBlockExprs.Add(Assign(lambdaPar, savedPar));
                    continue;
                }

                inlinedBlockExprs.Add(Assign(lambdaPar, invokeArg));
            }

            inlinedBlockExprs.Append(lambdaBodyExpr);

#if LIGHT_EXPRESSION
            var inlinedBlock = lambdaReturnType == lambdaBodyExpr.Type
                ? Block(lambdaPars.ToReadOnlyList(), in inlinedBlockExprs)
                : Block(lambdaReturnType, lambdaPars.ToReadOnlyList(), in inlinedBlockExprs);
            if (savedVars.Count != 0)
            {
                savedVarsBlockExprs.Add(inlinedBlock);
                inlinedBlock = Block(savedVars.ToArray(), in savedVarsBlockExprs);
            }
#else
            var inlinedBlock = lambdaReturnType == lambdaBodyExpr.Type
                ? Block(lambdaPars, inlinedBlockExprs.ToArray())
                : Block(lambdaReturnType, lambdaPars, inlinedBlockExprs.ToArray());
            if (savedVars.Count != 0)
            {
                savedVarsBlockExprs.Add(inlinedBlock);
                inlinedBlock = Block(savedVars.ToArray(), savedVarsBlockExprs.ToArray());
            }
#endif
            return inlinedBlock;
        }

#if LIGHT_EXPRESSION
        private static bool PropagateNonPassedParamsToOuterLambda(ref ClosureInfo closure, NestedLambdaInfo nestedLambda,
            IParameterProvider paramExprs, IParameterProvider nestedLambdaParamExprs, ref SmallList<ParameterExpression> nestedNonPassedParams)
        {
            var paramExprCount = paramExprs.ParameterCount;
            var nestedLambdaParamExprCount = nestedLambdaParamExprs.ParameterCount;
#else
        private static bool PropagateNonPassedParamsToOuterLambda(ref ClosureInfo closure, NestedLambdaInfo nestedLambda,
            IReadOnlyList<PE> paramExprs, IReadOnlyList<PE> nestedLambdaParamExprs, ref SmallList<ParameterExpression> nestedNonPassedParams)
        {
            var paramExprCount = paramExprs.Count;
            var nestedLambdaParamExprCount = nestedLambdaParamExprs.Count;
#endif
            // If nested non passed parameter is not matched with any outer passed parameter,
            // then ensure it goes to outer non passed parameter.
            // But check that having a non-passed parameter in root expression is invalid.
            for (var i = 0; i < nestedNonPassedParams.Count; i++)
            {
                var nestedNonPassedParam = nestedNonPassedParams.GetSurePresentItemRef(i);

                var isInNestedLambda = false;
                if (nestedLambdaParamExprCount != 0)
                    for (var p = 0; !isInNestedLambda && p < nestedLambdaParamExprCount; ++p)
                        isInNestedLambda = ReferenceEquals(nestedLambdaParamExprs.GetParameter(p), nestedNonPassedParam);

                var isInOuterLambda = false;
                if (paramExprCount != 0)
                    for (var p = 0; !isInOuterLambda && p < paramExprCount; ++p)
                        isInOuterLambda = ReferenceEquals(paramExprs.GetParameter(p), nestedNonPassedParam);

                if (!isInNestedLambda & !isInOuterLambda)
                {
                    if (nestedLambda != null)
                        nestedLambda.NonPassedParameters.GetIndexOrAppend(nestedNonPassedParam, default(RefEq<ParameterExpression>));
                    else if (!closure.IsLocalVar(nestedNonPassedParam))
                        return false;
                }
            }

            return true;
        }

        private static bool FindAlreadyCompiledNestedLambdaInfoInLambdas(
            ref SmallList<NestedLambdaInfo> nestedLambdas, LambdaExpression lambdaExpr, out NestedLambdaInfo found)
        {
            var nestedLambdasCount = nestedLambdas.Count;
            for (var i = 0; i < nestedLambdasCount; ++i)
            {
                var nestedLambda = nestedLambdas.Items[i];
                if (nestedLambda.HasTheSameLambdaExpression(lambdaExpr))
                {
                    found = nestedLambda;
                    return true;
                }

                if (nestedLambda.NestedLambdas.Count != 0)
                    return FindAlreadyCompiledNestedLambdaInfoInLambdas(ref nestedLambda.NestedLambdas, lambdaExpr, out found);
            }

            found = null;
            return false;
        }

        private static bool TryCompileNestedLambda(ref ClosureInfo nestedClosureInfo, NestedLambdaInfo nestedLambdaInfo, CompilerFlags setup)
        {
            // 1. Try to compile nested lambda in place
            // 2. Check that parameters used in compiled lambda are passed or closed by outer lambda
            // 3. Add the compiled lambda to closure of outer lambda for later invocation
            var nestedLambdaExpr = nestedLambdaInfo.LambdaExpression;
            var nestedReturnType = nestedLambdaExpr.ReturnType;
            var nestedLambdaBody = nestedLambdaExpr.Body;
#if LIGHT_EXPRESSION
            var nestedLambdaParamExprs = (IParameterProvider)nestedLambdaExpr;

            if (nestedLambdaBody is NoArgsNewClassIntrinsicExpression newNoArgs)
            {
                var paramTypes = RentOrNewClosureTypeToParamTypes(nestedLambdaParamExprs);
                nestedLambdaInfo.Lambda = CompileNoArgsNew(newNoArgs.Constructor, nestedLambdaExpr.Type, paramTypes, nestedReturnType);
                ReturnClosureTypeToParamTypesToPool(paramTypes);
                return true;
            }
#else
            var nestedLambdaParamExprs = nestedLambdaExpr.Parameters;
#endif
            // copy the nested lambdas and non-passed paramters to closure info to read them in TryEmit
            nestedClosureInfo.NestedLambdas = nestedLambdaInfo.NestedLambdas;
            nestedClosureInfo.NonPassedParameters = nestedLambdaInfo.NonPassedParameters;

            var nestedConstsAndLambdas = nestedClosureInfo.GetArrayOfConstantsAndNestedLambdas();

            ArrayClosure nestedLambdaClosure = null;
            var hasNonPassedParameters = nestedLambdaInfo.NonPassedParameters.Count != 0;
            if (!hasNonPassedParameters)
                nestedLambdaClosure = (nestedClosureInfo.Status & ClosureStatus.HasClosure) == 0
                    ? EmptyArrayClosure
                    : new ArrayClosure(nestedConstsAndLambdas);

            var closurePlusParamTypes = RentOrNewClosureTypeToParamTypes(nestedLambdaParamExprs);

            var method = new DynamicMethod(string.Empty, nestedReturnType, closurePlusParamTypes, typeof(ArrayClosure), true);
            var il = method.GetILGenerator();

            var containsConstantsOrNestedLambdas = nestedClosureInfo.ContainsConstantsOrNestedLambdas();
            if (containsConstantsOrNestedLambdas & ((nestedClosureInfo.Status & ClosureStatus.HasClosure) != 0))
                EmittingVisitor.EmitLoadConstantsAndNestedLambdasIntoVars(il, ref nestedClosureInfo);

            var parent = nestedReturnType == typeof(void) ? ParentFlags.IgnoreResult : ParentFlags.Empty;
            if (!EmittingVisitor.TryEmit(nestedLambdaBody, nestedLambdaParamExprs, il, ref nestedClosureInfo, setup, parent))
                return false;
            il.Demit(OpCodes.Ret);

            // If we don't have closure then create a static or an open delegate to pass closure later with `TryEmitNestedLambda`,
            // constructing the new closure with non-passed arguments and the rest of items
            nestedLambdaInfo.Lambda = nestedLambdaClosure != null
                ? method.CreateDelegate(nestedLambdaExpr.Type, nestedLambdaClosure)
                : method.CreateDelegate(Tools.GetFuncOrActionType(closurePlusParamTypes, nestedReturnType), null);

            if (nestedConstsAndLambdas != null & containsConstantsOrNestedLambdas & hasNonPassedParameters)
                nestedLambdaInfo.Lambda = new NestedLambdaWithConstantsAndNestedLambdas(nestedLambdaInfo.Lambda, nestedConstsAndLambdas);

            ReturnClosureTypeToParamTypesToPool(closurePlusParamTypes);
            return true;
        }

        /// <summary>Return IDelegateDebugInfo if the delegate is fast compiled with `CompilerFlags.EnableDelegateDebugInfo` flag</summary>
        public static IDelegateDebugInfo TryGetDebugInfo<D>(this D delegat) where D : Delegate =>
            delegat.Target as IDelegateDebugInfo;

#if LIGHT_EXPRESSION
        private static Result TryCollectMemberInitExprConstants(ref ClosureInfo closure, MemberInitExpression expr,
            IParameterProvider paramExprs, NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas, CompilerFlags flags)
        {
            var newExpr = expr.Expression;
            var binds = (IArgumentProvider<MemberBinding>)expr;
            var count = binds.ArgumentCount;
#else
        private static Result TryCollectMemberInitExprConstants(ref ClosureInfo closure, MemberInitExpression expr,
            IReadOnlyList<PE> paramExprs, NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas, CompilerFlags flags)
        {
            var newExpr = expr.NewExpression;
            var binds = expr.Bindings;
            var count = binds.Count;
#endif
            var r = Result.OK;
            if ((r = TryCollectInfo(ref closure, newExpr, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                return r;

            for (var i = 0; i < count; ++i)
            {
                var b = binds.GetArgument(i);
                if (b.BindingType != MemberBindingType.Assignment)
                    return b.BindingType == MemberBindingType.MemberBinding ? Result.NotSupported_MemberInit_MemberBinding : Result.NotSupported_MemberInit_ListBinding; // todo: @feature MemberMemberBinding and the MemberListBinding is not supported yet.

                if ((r = TryCollectInfo(ref closure, ((MemberAssignment)b).Expression, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                    return r;
            }
            return r;
        }

        private static Result TryCollectListInitExprConstants(ref ClosureInfo closure, ListInitExpression expr,
#if LIGHT_EXPRESSION
            IParameterProvider paramExprs,
#else
            IReadOnlyList<PE> paramExprs,
#endif
            NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas, CompilerFlags flags)
        {
            var newExpr = expr.NewExpression;
            var inits = expr.Initializers;
            var count = inits.Count;

            var r = Result.OK;
            if ((r = TryCollectInfo(ref closure, newExpr, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                return r;

            for (var i = 0; i < count; ++i)
            {
                var elemInit = inits.GetArgument(i);
                var args = elemInit.Arguments;
                var argCount = args.Count;
                for (var a = 0; a < argCount; ++a)
                    if ((r = TryCollectInfo(ref closure, args.GetArgument(a), paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                        return r;
            }
            return r;
        }

        private static Result TryCollectTryExprConstants(ref ClosureInfo closure, TryExpression tryExpr,
#if LIGHT_EXPRESSION
            IParameterProvider paramExprs,
#else
            IReadOnlyList<PE> paramExprs,
#endif
            NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas, CompilerFlags flags)
        {
            var r = Result.OK;
            if ((r = TryCollectInfo(ref closure, tryExpr.Body, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                return r;

            var catchBlocks = tryExpr.Handlers;
            for (var i = 0; i < catchBlocks.Count; i++)
            {
                var catchBlock = catchBlocks[i];
                var catchExVar = catchBlock.Variable;
                if (catchExVar != null)
                {
                    closure.PushBlockWithVars(catchExVar);
                    if ((r = TryCollectInfo(ref closure, catchExVar, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                        return r;
                }

                if (catchBlock.Filter != null &&
                    (r = TryCollectInfo(ref closure, catchBlock.Filter, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                    return r;

                if ((r = TryCollectInfo(ref closure, catchBlock.Body, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                    return r;

                if (catchExVar != null)
                    closure.PopBlock();
            }

            if (tryExpr.Finally != null &&
                (r = TryCollectInfo(ref closure, tryExpr.Finally, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK)
                return r;

            return r;
        }

        #endregion

        /// The minimal context-aware flags set by parent
        [Flags]
        public enum ParentFlags : ushort
        {
            /// Default is no flags
            Empty = 0,
            /// The result of expression is ignored and maybe popped out
            IgnoreResult = 1 << 1,
            /// Some parent is the call expression
            Call = 1 << 2,
            /// Any Parent Expression is a MemberExpression
            MemberAccess = 1 << 3,
            /// Some arithmetic operation
            Arithmetic = 1 << 4,
            /// Subject
            Coalesce = 1 << 5,
            /// Expression with instance object (method call or member access or array access)
            InstanceAccess = 1 << 6,
            /// Subject
            DupIt = 1 << 7,
            /// Subject
            TryCatch = 1 << 8,
            /// Combination`of InstanceAccess and Call
            InstanceCall = Call | InstanceAccess,
            /// Constructor
            Ctor = 1 << 9,
            /// Constructor call
            CtorCall = Call | Ctor,
            /// Indexer
            IndexAccess = 1 << 10,
            /// Invoking the inlined lambda (the default System.Expression behavior)
            InlinedLambdaInvoke = 1 << 11,
            /// <summary>Indicate if the part AT LEAST participates in the assignment on the left side, 
            /// it may also participate in the right side, e.g. ++x.Bar</summary>
            AssignmentLeftValue = 1 << 12,
            /// <summary>Indicates the ONLY right value of assignment, e.g. `p` in `foo.Bar += p` </summary>
            AssignmentRightValue = 1 << 13,
            /// <summary>Assigning the ref of the right value to the left, e.g. in `var a = ref b[1]` we are passing this flag for the `ref b[1]`</summary>
            AssignmentByRef = 1 << 14
        }

        [MethodImpl((MethodImplOptions)256)]
        public static bool IgnoresResult(this ParentFlags parent) => (parent & ParentFlags.IgnoreResult) != 0;

        internal static bool EmitPopIfIgnoreResult(this ILGenerator il, ParentFlags parent)
        {
            if ((parent & ParentFlags.IgnoreResult) != 0)
                il.Demit(OpCodes.Pop);
            return true;
        }

        [MethodImpl((MethodImplOptions)256)]
        internal static bool TryEmitBoxOf(this ILGenerator il, Type sourceType)
        {
            if (sourceType.IsValueType)
                il.Demit(OpCodes.Box, sourceType);
            return true;
        }

        /// <summary>Supports emitting of selected expressions, e.g. lambdaExpr are not supported yet.
        /// When emitter find not supported expression it will return false from <see cref="TryEmit"/>, so I could fallback
        /// to normal and slow Expression.Compile.</summary>
        [RequiresUnreferencedCode(Trimming.Message)]
        public static class EmittingVisitor
        {
            // todo: @perf use UnsafeAccessAttribute
            private static readonly MethodInfo _getTypeFromHandleMethod =
                ((Func<RuntimeTypeHandle, Type>)Type.GetTypeFromHandle).Method;
            private static readonly MethodInfo _objectEqualsMethod =
                ((Func<object, object, bool>)object.Equals).Method;

            public static bool TryEmit(Expression expr,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent, int byRefIndex = -1)
            {
                while (true)
                {
                    closure.LastEmitIsAddress = false;
#if LIGHT_EXPRESSION
                    if (expr.IsIntrinsic)
                        return expr.TryEmit(setup, ref closure, paramExprs, il, parent, byRefIndex);
#endif
                    var nodeType = expr.NodeType;
                    switch (nodeType)
                    {
                        case ExpressionType.Parameter:
                            return (parent & ParentFlags.IgnoreResult) != 0 ||
                                TryEmitParameter((ParameterExpression)expr, paramExprs, il, ref closure, parent, byRefIndex);

                        case ExpressionType.TypeAs:
                        case ExpressionType.IsTrue:
                        case ExpressionType.IsFalse:
                        case ExpressionType.Increment:
                        case ExpressionType.Decrement:
                        case ExpressionType.Negate:
                        case ExpressionType.NegateChecked:
                        case ExpressionType.OnesComplement:
                        case ExpressionType.UnaryPlus:
                        case ExpressionType.Unbox:
                            return TryEmitSimpleUnaryExpression((UnaryExpression)expr, nodeType, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.TypeIs:
                        case ExpressionType.TypeEqual:
                            return TryEmitTypeIsOrEqual((TypeBinaryExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.Not:
                            return TryEmitNot((UnaryExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.Convert:
                        case ExpressionType.ConvertChecked:
                            return TryEmitConvert((UnaryExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.ArrayIndex:
                            var arrIndexExpr = (BinaryExpression)expr;
                            return TryEmit(arrIndexExpr.Left, paramExprs, il, ref closure, setup, parent | ParentFlags.IndexAccess)
                                && TryEmit(arrIndexExpr.Right, paramExprs, il, ref closure, setup, parent | ParentFlags.IndexAccess) // #265
                                && TryEmitArrayIndexGet(il, expr.Type, ref closure, parent);

                        case ExpressionType.ArrayLength:
                            if (!TryEmit(((UnaryExpression)expr).Operand, paramExprs, il, ref closure, setup, parent))
                                return false;
                            if ((parent & ParentFlags.IgnoreResult) == 0)
                                il.Demit(OpCodes.Ldlen);
                            return true;

                        case ExpressionType.Constant:
                            return (parent & ParentFlags.IgnoreResult) != 0 ||
                                TryEmitConstant(expr, il, ref closure, byRefIndex);

                        case ExpressionType.Call:
                            return TryEmitMethodCall(expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.MemberAccess:
                            return TryEmitMemberGet((MemberExpression)expr, paramExprs, il, ref closure, setup, parent, byRefIndex);

                        case ExpressionType.New:
                            return TryEmitNew(expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.NewArrayBounds:
                            return EmitNewArrayBounds((NewArrayExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.NewArrayInit:
                            return EmitNewArrayInit((NewArrayExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.MemberInit:
                            return EmitMemberInit((MemberInitExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.ListInit:
                            return TryEmitListInit((ListInitExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.Lambda:
                            return TryEmitNestedLambda((LambdaExpression)expr, paramExprs, il, ref closure);

                        case ExpressionType.Invoke:
                            return TryEmitInvoke((InvocationExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.GreaterThan:
                        case ExpressionType.GreaterThanOrEqual:
                        case ExpressionType.LessThan:
                        case ExpressionType.LessThanOrEqual:
                        case ExpressionType.Equal:
                        case ExpressionType.NotEqual:
                            var binaryExpr = (BinaryExpression)expr;
                            return TryEmitComparison(binaryExpr.Left, binaryExpr.Right, expr.Type, nodeType, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.Add:
                        case ExpressionType.AddChecked:
                        case ExpressionType.Subtract:
                        case ExpressionType.SubtractChecked:
                        case ExpressionType.Multiply:
                        case ExpressionType.MultiplyChecked:
                        case ExpressionType.Divide:
                        case ExpressionType.Modulo:
                        case ExpressionType.Power:
                        case ExpressionType.And:
                        case ExpressionType.Or:
                        case ExpressionType.ExclusiveOr:
                        case ExpressionType.LeftShift:
                        case ExpressionType.RightShift:
                            return TryEmitArithmetic(((BinaryExpression)expr).Left, ((BinaryExpression)expr).Right, nodeType, expr.Type, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.AndAlso:
                        case ExpressionType.OrElse:
                            return TryEmitLogicalOperator((BinaryExpression)expr, nodeType, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.Coalesce:
                            return TryEmitCoalesceOperator((BinaryExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.Conditional:
                            var condExpr = (ConditionalExpression)expr;
                            return TryEmitConditional(condExpr.Test, condExpr.IfTrue, condExpr.IfFalse, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.PostIncrementAssign:
                        case ExpressionType.PreIncrementAssign:
                            return TryEmitArithmeticAndOrAssign(((UnaryExpression)expr).Operand, null, expr.Type, ExpressionType.Add,
                                nodeType == ExpressionType.PostIncrementAssign, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.PostDecrementAssign:
                        case ExpressionType.PreDecrementAssign:
                            return TryEmitArithmeticAndOrAssign(((UnaryExpression)expr).Operand, null, expr.Type, ExpressionType.Subtract,
                                nodeType == ExpressionType.PostDecrementAssign, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.AddAssign:
                        case ExpressionType.AddAssignChecked:
                        case ExpressionType.SubtractAssign:
                        case ExpressionType.SubtractAssignChecked:
                        case ExpressionType.MultiplyAssign:
                        case ExpressionType.MultiplyAssignChecked:
                        case ExpressionType.DivideAssign:
                        case ExpressionType.ModuloAssign:
                        case ExpressionType.PowerAssign:
                        case ExpressionType.AndAssign:
                        case ExpressionType.OrAssign:
                        case ExpressionType.ExclusiveOrAssign:
                        case ExpressionType.LeftShiftAssign:
                        case ExpressionType.RightShiftAssign:
                        case ExpressionType.Assign:
                            var ba = (BinaryExpression)expr;
                            return TryEmitArithmeticAndOrAssign(ba.Left, ba.Right, expr.Type,
                                AssignToArithmeticOrSelf(nodeType), false, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.Block:
                            {
                                var blockExpr = (BlockExpression)expr;
                                var blockVarExprs = blockExpr.Variables;
                                var blockVarCount = blockVarExprs?.Count ?? 0;
                                var statementExprs = blockExpr.Expressions; // Trim the expressions after the Throw - #196
                                var statementCount = statementExprs.Count;
                                if (statementCount == 0)
                                    return true; // yeah, it is a valid thing

                                if (blockVarCount == 1 & statementCount == 2 &&
                                    statementExprs[0] is BinaryExpression st0 && st0.NodeType == ExpressionType.Assign &&
                                    statementExprs[1] is BinaryExpression st1 && st1.NodeType == ExpressionType.Assign &&
                                    st0.Left == blockVarExprs[0] && st1.Right == blockVarExprs[0])
                                    return TryEmitArithmeticAndOrAssign(st1.Left, st0.Right, st0.Left.Type,
                                        ExpressionType.Assign, false, paramExprs, il, ref closure, setup, parent);

                                if (blockVarCount != 0)
                                    closure.PushBlockAndConstructLocalVars(blockVarExprs, il);

                                expr = statementExprs[statementCount - 1]; // The last (result) statement in block will provide the result

                                // Try to trim the statements up to the Throw (if any)
                                if (statementCount > 1)
                                {
                                    var throwIndex = statementCount - 1;
                                    while (throwIndex != -1 && statementExprs[throwIndex].NodeType != ExpressionType.Throw)
                                        --throwIndex;

                                    // If we have a Throw and it is not the last one
                                    if (throwIndex != -1 && throwIndex != statementCount - 1)
                                    {
                                        // Change the Throw return type to match the one for the Block, and adjust the statement count
                                        expr = Expression.Throw(((UnaryExpression)statementExprs[throwIndex]).Operand, blockExpr.Type);
                                        statementCount = throwIndex + 1;
                                    }
                                }

                                // handle the all statements in block excluding the last one
                                if (statementCount > 1)
                                {
                                    for (var i = 0; i < statementCount - 1; i++)
                                    {
                                        var stExpr = statementExprs[i];
                                        if (stExpr.NodeType == ExpressionType.Default && stExpr.Type == typeof(void))
                                            continue;

                                        // This is basically the return pattern (see #237), so we don't care for the rest of expressions
                                        if (stExpr is GotoExpression gt && gt.Kind == GotoExpressionKind.Return &&
                                            statementExprs[i + 1] is LabelExpression label && label.Target == gt.Target)
                                        {
                                            if ((parent & ParentFlags.TryCatch) != 0)
                                            {
                                                if ((setup & CompilerFlags.ThrowOnNotSupportedExpression) != 0)
                                                    throw new NotSupportedExpressionException(Result.NotSupported_Try_GotoReturnToTheFollowupLabel);
                                                return false; // todo: @feature return from the TryCatch with the internal label is not supported, though it is the unlikely case
                                            }

                                            // we are generating the return value and ensuring here that it is not popped-out
                                            var gtOrLabelValue = gt.Value ?? label.DefaultValue;
                                            if (gtOrLabelValue != null)
                                            {
                                                if (!TryEmit(gtOrLabelValue, paramExprs, il, ref closure, setup, parent & ~ParentFlags.IgnoreResult))
                                                    return false;

                                                if ((parent & ParentFlags.InlinedLambdaInvoke) != 0)
                                                {
                                                    ref var foundLabel = ref closure.Labels.GetLabelOrInvokeIndexByTarget(gt.Target, out var labelFound);
                                                    if (!labelFound || foundLabel.InlinedLambdaInvokeIndex == -1)
                                                        return false;
                                                    EmitGotoToReturnLabel(ref closure.Labels.GetSurePresentItemRef(foundLabel.InlinedLambdaInvokeIndex), il, gtOrLabelValue, OpCodes.Br);
                                                }
                                                else
                                                {
                                                    // @hack (related to #237) if `IgnoreResult` set, that means the external/calling code won't planning on returning and
                                                    // emitting the double `OpCodes.Ret` (usually for not the last statement in block), so we can safely emit our own `Ret` here.
                                                    // And vice-versa, if `IgnoreResult` not set then the external code planning to emit `Ret` (the last block statement), 
                                                    // so we should avoid it on our side.
                                                    if ((parent & ParentFlags.IgnoreResult) != 0)
                                                        il.Demit(OpCodes.Ret);
                                                }
                                            }
                                            return true;
                                        }

                                        if (!TryEmit(stExpr, paramExprs, il, ref closure, setup, parent | ParentFlags.IgnoreResult))
                                            return false;
                                    }
                                }

                                if (blockVarCount == 0)
                                    continue; // OMG! no recursion, continue with the last expression

                                if (!TryEmit(expr, paramExprs, il, ref closure, setup, parent))
                                    return false;

                                closure.PopBlock();
                                return true;
                            }
                        case ExpressionType.Loop:
                            return TryEmitLoop((LoopExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.Try:
                            return TryEmitTryCatchFinallyBlock((TryExpression)expr, paramExprs, il, ref closure, setup, parent | ParentFlags.TryCatch);

                        case ExpressionType.Throw:
                            {
                                var throwExpr = (UnaryExpression)expr;
                                if (throwExpr.Operand is null)
                                {
                                    il.Demit(OpCodes.Rethrow);
                                }
                                else
                                {
                                    if (!TryEmit(throwExpr.Operand, paramExprs, il, ref closure, setup, parent & ~ParentFlags.IgnoreResult))
                                        return false;
                                    il.Demit(OpCodes.Throw);
                                }
                                return true;
                            }

                        case ExpressionType.Default:
                            if (expr.Type != typeof(void) && (parent & ParentFlags.IgnoreResult) == 0)
                                EmitDefault(expr.Type, il);
                            return true;

                        case ExpressionType.Index:
                            return TryEmitIndexGet((IndexExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.Goto:
                            return TryEmitGoto((GotoExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.Label:
                            return TryEmitLabel((LabelExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.Switch:
                            return TryEmitSwitch((SwitchExpression)expr, paramExprs, il, ref closure, setup, parent);

                        case ExpressionType.Extension:
                            expr = expr.Reduce();
                            continue;

                        case ExpressionType.DebugInfo: // todo: @feature - is not supported yet
                            return true;               // todo: @unclear - just ignoring the info for now

                        case ExpressionType.Quote:     // todo: @feature - is not supported yet
                        default:
                            return false;

                    }
                }
            }

#if LIGHT_EXPRESSION
            private static bool TryEmitNew(Expression expr, IParameterProvider paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#else
            private static bool TryEmitNew(Expression expr, IReadOnlyList<PE> paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#endif
            {
                parent |= ParentFlags.CtorCall;
                var newExpr = (NewExpression)expr;
#if SUPPORTS_ARGUMENT_PROVIDER
                var argExprs = (IArgumentProvider)newExpr;
#else
                var argExprs = newExpr.Arguments;
#endif
                var argCount = argExprs.GetCount();
                var ctor = newExpr.Constructor;
                if (argCount > 0)
                {
                    var args = ctor.GetParameters(); // todo: @perf move into loop
                    for (var i = 0; i < argCount; ++i)
                        if (!TryEmit(argExprs.GetArgument(i),
                            paramExprs, il, ref closure, setup, parent, args[i].ParameterType.IsByRef ? i : -1))
                            return false;
                }
                // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                if (ctor != null)
                    il.Demit(OpCodes.Newobj, ctor);
                else if (newExpr.Type.IsValueType)
                    EmitLoadLocalVariable(il, InitValueTypeVariable(il, newExpr.Type));
                else
                    return false;
                return true;
            }

#if LIGHT_EXPRESSION
            private static bool TryEmitLoop(LoopExpression loopExpr, IParameterProvider paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#else
            private static bool TryEmitLoop(LoopExpression loopExpr, IReadOnlyList<PE> paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#endif
            {
                // Mark the start of the loop body:
                var loopBodyLabel = il.DefineLabel();
                il.DmarkLabel(loopBodyLabel);

                if (loopExpr.ContinueLabel != null)
                {
                    ref var continueLabelInfo = ref closure.Labels.GetLabelOrInvokeIndexByTarget(loopExpr.ContinueLabel, out var foundLabel);
                    if (!foundLabel)
                        return false;
                    var continueLabel = continueLabelInfo.GetOrDefineLabel(il);
                    il.DmarkLabel(continueLabel);
                }

                if (!TryEmit(loopExpr.Body, paramExprs, il, ref closure, setup, parent))
                    return false;

                // If loop hasn't exited, jump back to start of its body:
                il.Demit(OpCodes.Br, loopBodyLabel);

                if (loopExpr.BreakLabel != null)
                {
                    ref var breakLabelInfo = ref closure.Labels.GetLabelOrInvokeIndexByTarget(loopExpr.BreakLabel, out var foundLabel);
                    if (!foundLabel)
                        return false;
                    var breakLabel = breakLabelInfo.GetOrDefineLabel(il);
                    il.DmarkLabel(breakLabel);
                }

                return true;
            }

            // similar code is used by the TryEmitArithmeticAndOrAssign, so don't forget to modify it as well
            private static bool TryEmitIndexGet(IndexExpression indexExpr,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
                var p = parent & ~ParentFlags.IgnoreResult | ParentFlags.IndexAccess;

                var objExpr = indexExpr.Object;
                if (objExpr != null &&
                    !TryEmit(objExpr, paramExprs, il, ref closure, setup, p | ParentFlags.InstanceAccess))
                    return false;

#if SUPPORTS_ARGUMENT_PROVIDER
                var indexArgs = (IArgumentProvider)indexExpr;
#else
                var indexArgs = indexExpr.Arguments;
#endif
                var indexArgCount = indexArgs.GetCount();
                for (var i = 0; i < indexArgCount; i++)
                    if (!TryEmit(indexArgs.GetArgument(i), paramExprs, il, ref closure, setup, p, -1))
                        return false;

                var indexerProp = indexExpr.Indexer;
                return indexerProp != null
                    ? EmitMethodCallOrVirtualCallCheckForNull(il, indexerProp.GetMethod)
                    : indexArgCount == 1
                        ? TryEmitArrayIndexGet(il, indexExpr.Type, ref closure, parent) // one-dimensional array
                        : EmitMethodCallOrVirtualCallCheckForNull(il, objExpr?.Type.FindMethod("Get")); // multi-dimensional array
            }

#if LIGHT_EXPRESSION
            private static bool TryEmitLabel(LabelExpression expr, IParameterProvider paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#else
            private static bool TryEmitLabel(LabelExpression expr, IReadOnlyList<PE> paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#endif
            {
                ref var labelInfo = ref closure.Labels.GetLabelOrInvokeIndexByTarget(expr.Target, out var foundLabel);
                if (!foundLabel)
                    return false;
                il.DmarkLabel(labelInfo.GetOrDefineLabel(il));

                var defaultValue = expr.DefaultValue;
                if (defaultValue != null && !TryEmit(defaultValue, paramExprs, il, ref closure, setup, parent))
                    return false;

                var returnVariableIndexPlusOne = labelInfo.ReturnVariableIndexPlusOneAndIsDefined >>> 1;
                if (returnVariableIndexPlusOne != 0)
                {
                    if (defaultValue != null)
                        EmitStoreLocalVariable(il, returnVariableIndexPlusOne - 1);

                    il.DmarkLabel(labelInfo.ReturnLabel);
                    if (!parent.IgnoresResult())
                        EmitLoadLocalVariable(il, returnVariableIndexPlusOne - 1);
                }
                return foundLabel;
            }

            // For TryCatch get the variable for saving the result from the LabelInfo store the return expression result into the that variable.
            // Emit OpCodes.Leave or OpCodes.Br to the special label with the result which should be marked after the label to jump over its default value
            private static void EmitGotoToReturnLabel(ref LabelInfo labelInfo, ILGenerator il, Expression gotoValue, OpCode returnOpCode)
            {
                var returnVariableIndexPlusOne = labelInfo.ReturnVariableIndexPlusOneAndIsDefined >>> 1;
                if (returnVariableIndexPlusOne == 0)
                {
                    returnVariableIndexPlusOne = il.GetNextLocalVarIndex(gotoValue.Type) + 1;
                    labelInfo.ReturnVariableIndexPlusOneAndIsDefined = (short)(returnVariableIndexPlusOne << 1);
                    labelInfo.ReturnLabel = il.DefineLabel();
                }
                EmitStoreLocalVariable(il, returnVariableIndexPlusOne - 1);
                il.Demit(returnOpCode, labelInfo.ReturnLabel);
            }

#if LIGHT_EXPRESSION
            private static bool TryEmitGoto(GotoExpression expr, IParameterProvider paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#else
            private static bool TryEmitGoto(GotoExpression expr, IReadOnlyList<PE> paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#endif
            {
                ref var labelInfo = ref closure.Labels.GetLabelOrInvokeIndexByTarget(expr.Target, out var labelFound);
                if (!labelFound)
                {
                    if ((closure.Status & ClosureStatus.ToBeCollected) == 0)
                        return false; // if no collection cycle then the labels may be not collected
                    throw new InvalidOperationException($"Cannot jump, no labels found for the target `{expr.Target}`");
                }
                var gotoValue = expr.Value;
                if (gotoValue != null &&
                    !TryEmit(gotoValue, paramExprs, il, ref closure, setup, parent & ~ParentFlags.IgnoreResult))
                    return false;

                switch (expr.Kind)
                {
                    case GotoExpressionKind.Break:
                    case GotoExpressionKind.Continue:
                        il.Demit(OpCodes.Br, labelInfo.GetOrDefineLabel(il));
                        return true;

                    case GotoExpressionKind.Goto:
                        if (gotoValue != null)
                            goto case GotoExpressionKind.Return;
                        il.Demit(OpCodes.Br, labelInfo.GetOrDefineLabel(il));
                        return true;

                    case GotoExpressionKind.Return:
                        if ((parent & ParentFlags.TryCatch) != 0)
                        {
                            if (gotoValue != null)
                                EmitGotoToReturnLabel(ref labelInfo, il, gotoValue, OpCodes.Leave);
                            else
                                il.Demit(OpCodes.Leave, labelInfo.GetOrDefineLabel(il)); // if there is no return value just leave to the original label
                        }
                        else if ((parent & ParentFlags.InlinedLambdaInvoke) != 0)
                        {
                            if (gotoValue != null)
                            {
                                var invokeIndex = labelInfo.InlinedLambdaInvokeIndex;
                                if (invokeIndex == -1)
                                    return false;
                                EmitGotoToReturnLabel(ref closure.Labels.GetSurePresentItemRef(invokeIndex), il, gotoValue, OpCodes.Br);
                            }
                        }
                        else
                            il.Demit(OpCodes.Ret);
                        return true;

                    default:
                        return false;
                }
            }

#if LIGHT_EXPRESSION
            private static bool TryEmitCoalesceOperator(BinaryExpression expr, IParameterProvider paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#else
            private static bool TryEmitCoalesceOperator(BinaryExpression expr, IReadOnlyList<PE> paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#endif
            {
                var labelFalse = il.DefineLabel(); // todo: @perf define only if needed
                var labelDone = il.DefineLabel();

                var left = expr.Left;
                var right = expr.Right;

                // we won't OpCodes.Pop inside the Coalesce as it may leave the Il in invalid state - instead we will pop at the end here (#284)
                var flags = (parent & ~ParentFlags.IgnoreResult) | ParentFlags.Coalesce;

                if (!TryEmit(left, paramExprs, il, ref closure, setup, flags))
                    return false;

                var leftType = left.Type;
                if (leftType.IsValueType)
                {
                    Debug.Assert(leftType.IsNullable(), "Expecting Nullable, it is the only ValueType comparable to null");

                    var varIndex = EmitStoreAndLoadLocalVariableAddress(il, leftType);
                    EmitMethodCall(il, leftType.GetNullableHasValueGetterMethod());

                    il.Demit(OpCodes.Brfalse, labelFalse);

                    if (expr.Type == leftType.GetUnderlyingNullableTypeUnsafe())
                    {
                        // if the target expression type is of underlying nullable, and the left operand is not null,
                        // then extract its underlying value
                        EmitLoadLocalVariableAddress(il, varIndex);
                        il.Demit(OpCodes.Ldfld, leftType.GetNullableValueUnsafeAkaGetValueOrDefaultMethod());
                    }
                    else
                        EmitLoadLocalVariable(il, varIndex); // loading the value (not address) to return it

                    il.Demit(OpCodes.Br, labelDone);
                    il.DmarkLabel(labelFalse);
                    if (!TryEmit(right, paramExprs, il, ref closure, setup, flags))
                        return false;

                    il.DmarkLabel(labelDone);
                }
                else
                {
                    il.Demit(OpCodes.Dup);                // duplicate left, if it's not null, after the branch this value will be on the top of the stack
                    il.Demit(OpCodes.Brtrue, labelFalse); // automates the chain of the Ldnull, Ceq, Brfalse
                    il.Demit(OpCodes.Pop);                // left is null, pop its value from the stack

                    if (!TryEmit(right, paramExprs, il, ref closure, setup, flags))
                        return false;

                    if (right.Type != expr.Type)
                        il.TryEmitBoxOf(right.Type);

                    if (left.Type == expr.Type)
                        il.DmarkLabel(labelFalse);
                    else
                    {
                        il.Demit(OpCodes.Br, labelDone);
                        il.DmarkLabel(labelFalse); // todo: @bug? should we insert the boxing for the Nullable value type before the Castclass
                        il.Demit(OpCodes.Castclass, expr.Type);
                        il.DmarkLabel(labelDone);
                    }
                }
                return il.EmitPopIfIgnoreResult(parent);
            }

            private static void EmitDefault(Type type, ILGenerator il)
            {
                if (!type.GetTypeInfo().IsValueType)
                {
                    il.Demit(OpCodes.Ldnull);
                }
                else if (
                    type == typeof(bool) ||
                    type == typeof(byte) ||
                    type == typeof(char) ||
                    type == typeof(sbyte) ||
                    type == typeof(int) ||
                    type == typeof(uint) ||
                    type == typeof(short) ||
                    type == typeof(ushort))
                {
                    il.Demit(OpCodes.Ldc_I4_0);
                }
                else if (
                    type == typeof(long) ||
                    type == typeof(ulong))
                {
                    il.Demit(OpCodes.Ldc_I4_0);
                    il.Demit(OpCodes.Conv_I8);
                }
                else if (type == typeof(float))
                    il.Demit(OpCodes.Ldc_R4, default(float));
                else if (type == typeof(double))
                    il.Demit(OpCodes.Ldc_R8, default(double));
                else
                    EmitLoadLocalVariable(il, InitValueTypeVariable(il, type));
            }

#if LIGHT_EXPRESSION
            private static bool TryEmitTryCatchFinallyBlock(TryExpression tryExpr, IParameterProvider paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#else
            private static bool TryEmitTryCatchFinallyBlock(TryExpression tryExpr, IReadOnlyList<PE> paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#endif
            {
#if DEMIT
                Debug.WriteLine("try {");
#endif
                il.BeginExceptionBlock();

                if (!TryEmit(tryExpr.Body, paramExprs, il, ref closure, setup, parent))
                    return false;

                var exprType = tryExpr.Type;
                var returnsResult = exprType != typeof(void) && !parent.IgnoresResult();
                var resultVarIndex = -1;

                if (returnsResult)
                    EmitStoreLocalVariable(il, resultVarIndex = il.GetNextLocalVarIndex(exprType));

                var catchBlocks = tryExpr.Handlers;
                for (var i = 0; i < catchBlocks.Count; i++)
                {
                    var catchBlock = catchBlocks[i];
                    if (catchBlock.Filter != null)
                    {
                        if ((setup & CompilerFlags.ThrowOnNotSupportedExpression) != 0)
                            throw new NotSupportedExpressionException(Result.NotSupported_ExceptionCatchFilter);
                        return false;
                    }

                    il.BeginCatchBlock(catchBlock.Test);

                    // at the beginning of catch the Exception value is on the stack,
                    // we will store into local variable.
                    var exVarExpr = catchBlock.Variable;
#if DEMIT
                    Debug.WriteLine($"}} catch {{");
#endif
                    if (exVarExpr != null)
                    {
                        // first, check if the exception variable was used before and supposed to be reused in the new catch 
                        // (this is decided by creator of expression)
                        var exVarIndex = closure.GetDefinedLocalVarOrDefault(exVarExpr);
                        if (exVarIndex == -1)
                            exVarIndex = il.GetNextLocalVarIndex(exVarExpr.Type);
                        closure.PushBlockWithVars(exVarExpr, exVarIndex);
                        EmitStoreLocalVariable(il, exVarIndex);
                    }

                    if (!TryEmit(catchBlock.Body, paramExprs, il, ref closure, setup, parent))
                        return false;

                    if (exVarExpr != null)
                        closure.PopBlock();

                    if (returnsResult)
                        EmitStoreLocalVariable(il, resultVarIndex);
                }

                var finallyExpr = tryExpr.Finally;
                if (finallyExpr != null)
                {
#if DEMIT
                    Debug.WriteLine("} finally {" + finallyExpr);
#endif
                    il.BeginFinallyBlock();
                    // it is important to ignore result for the finally block, because it should not return anything
                    if (!TryEmit(finallyExpr, paramExprs, il, ref closure, setup, parent | ParentFlags.IgnoreResult))
                        return false;
                }

                il.EndExceptionBlock();

#if DEMIT
                Debug.WriteLine("}");
#endif

                if (returnsResult)
                    EmitLoadLocalVariable(il, resultVarIndex);

                return true;
            }

            public static bool TryEmitParameter(ParameterExpression paramExpr,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, ParentFlags parent, int byRefIndex = -1)
            {
                var paramExprCount = paramExprs.GetCount();
                var paramType = paramExpr.Type;
                var isParamOrVarByRef = paramExpr.IsByRef;
                var isArgByRef = byRefIndex != -1;

                // Parameter may represent a variable, so first look if this is the case,
                // and the variable is defined in the current block 
                var varIndex = closure.GetDefinedLocalVarOrDefault(paramExpr);
                if (varIndex != -1)
                {
                    closure.LastEmitIsAddress = !isParamOrVarByRef &&
                        (isArgByRef ||
                            paramType.IsValueType &&
                            (parent & ParentFlags.IndexAccess) == 0 &&  // but the parameter is not used as an index #281, #265
                            (parent & (ParentFlags.MemberAccess | ParentFlags.InstanceAccess)) != 0); // means the parameter is the instance for what method is called or the instance for the member access, see #274, #283

                    if (closure.LastEmitIsAddress)
                        EmitLoadLocalVariableAddress(il, varIndex);
                    else if (!isParamOrVarByRef)
                        EmitLoadLocalVariable(il, varIndex);
                    else
                    {
                        if ((parent & ParentFlags.InstanceCall) == ParentFlags.InstanceCall)
                            EmitLoadLocalVariable(il, varIndex);
                        else
                            EmitStoreAndLoadLocalVariable(il, varIndex);

                        // Assume that the var is the last on the stack and just duplicating it, see #346 `Get_array_element_ref_and_increment_it`
                        // Do only when accessing the variable directly, and not the member and the array element by index
                        if ((parent & ParentFlags.InstanceAccess) == 0)
                            EmitLoadLocalVariable(il, varIndex);

                        if (paramType.IsValueType)
                        {
                            if ((parent & (ParentFlags.Arithmetic | ParentFlags.AssignmentRightValue)) != 0 &
                                (parent & (ParentFlags.MemberAccess | ParentFlags.InstanceAccess)) == 0)
                                EmitLoadIndirectlyByRef(il, paramType);
                        }
                        else
                        {
                            if ((parent & (ParentFlags.Coalesce | ParentFlags.MemberAccess | ParentFlags.IndexAccess | ParentFlags.AssignmentRightValue)) != 0)
                                il.Demit(OpCodes.Ldind_Ref);
                        }
                    }
                    return true;
                }

                // If not variable then look if the parameter is passed to the current lambda
                var paramIndex = paramExprCount - 1;
                while (paramIndex != -1 && !ReferenceEquals(paramExprs.GetParameter(paramIndex), paramExpr)) --paramIndex;
                if (paramIndex != -1)
                {
                    if ((closure.Status & ClosureStatus.ShouldBeStaticMethod) == 0)
                        ++paramIndex; // shift parameter index by one, because the first one will be closure

                    //  means the parameter is the instance for what method is called or the instance for the member access, see #274, #283
                    var valueTypeParamCallOrMemberAccess = paramType.IsValueType &&
                        // means the parameter is the instance for what method is called or the instance for the member access, see #274, #283
                        (parent & (ParentFlags.MemberAccess | ParentFlags.InstanceAccess)) != 0 &
                        // but the parameter is not used as an index #281, #265, nor it is an arithmetic #352
                        (parent & (ParentFlags.IndexAccess | ParentFlags.Arithmetic)) == 0;

                    closure.LastEmitIsAddress = !isParamOrVarByRef & (isArgByRef | valueTypeParamCallOrMemberAccess);

                    if (closure.LastEmitIsAddress)
                        EmitLoadArgAddress(il, paramIndex);
                    else
                        EmitLoadArg(il, paramIndex);

                    // todo: @simplify as it is complex overall and EmitLoadIndirectlyByRef does the Ldind_Ref too
                    if (isParamOrVarByRef)
                    {
                        if (paramType.IsValueType)
                        {
                            // #248 - skip the cases with `ref param.Field` were we are actually want to load the `Field` address not the `param`
                            // this means the parameter is the argument to the method call and not the instance in the method call or member access
                            if (!isArgByRef & (parent & ParentFlags.Call) != 0 &
                                (parent & ParentFlags.InstanceAccess) == 0 ||
                                (parent & (ParentFlags.Arithmetic | ParentFlags.AssignmentRightValue)) != 0 &
                                (parent & (ParentFlags.MemberAccess | ParentFlags.InstanceAccess | ParentFlags.AssignmentLeftValue)) == 0)
                                EmitLoadIndirectlyByRef(il, paramType);
                        }
                        else
                        {
                            if (!isArgByRef & (parent & ParentFlags.Call) != 0 ||
                                (parent & (ParentFlags.Coalesce | ParentFlags.MemberAccess | ParentFlags.IndexAccess | ParentFlags.AssignmentRightValue)) != 0)
                                il.Demit(OpCodes.Ldind_Ref);
                        }
                    }
                    return true;
                }

                if (isParamOrVarByRef)
                {
                    EmitLoadLocalVariableAddress(il, byRefIndex); // todo: @bug? `closure.LastEmitIsAddress = true;` should we do it too as in above code with the variable 
                    return true;
                }

                // the only possibility that we are here is because we are in the nested lambda,
                // and it uses the parameter or variable from the outer lambda
                var nonPassedParamIndex = closure.NonPassedParameters.TryGetIndex(paramExpr, default(RefEq<ParameterExpression>));
                if (nonPassedParamIndex == -1)
                    return false;

                // Load non-passed argument from Closure - closure object is always a first argument
                il.Demit(OpCodes.Ldarg_0);
                il.Demit(OpCodes.Ldfld, ArrayClosureWithNonPassedParamsField);
                EmitLoadConstantInt(il, nonPassedParamIndex);
                il.Demit(OpCodes.Ldelem_Ref);

                // source type is object, NonPassedParams is object array
                if (paramType.IsValueType)
                    il.Demit(OpCodes.Unbox_Any, paramType);

                return true;
            }

#if LIGHT_EXPRESSION
            public static bool TryEmitNonByRefNonValueTypeParameter(ParameterExpression paramExpr, IParameterProvider paramExprs, ILGenerator il, ref ClosureInfo closure)
            {
                var paramExprCount = paramExprs.ParameterCount;
#else
            public static bool TryEmitNonByRefNonValueTypeParameter(ParameterExpression paramExpr, IReadOnlyList<PE> paramExprs, ILGenerator il, ref ClosureInfo closure)
            {
                var paramExprCount = paramExprs.Count;
#endif
                // if parameter is passed through, then just load it on stack
                var paramType = paramExpr.Type;
                var paramIndex = paramExprCount - 1;
                while (paramIndex != -1 && !ReferenceEquals(paramExprs.GetParameter(paramIndex), paramExpr))
                    --paramIndex;
                if (paramIndex != -1)
                {
                    ++paramIndex; // shift parameter index by one, because the first one will be closure
                    if (closure.LastEmitIsAddress)
                        EmitLoadArgAddress(il, paramIndex);
                    else
                        EmitLoadArg(il, paramIndex);
                    return true;
                }

                // the only possibility that we are here is because we are in the nested lambda,
                // and it uses the parameter or variable from the outer lambda
                var nonPassedParamIndex = closure.NonPassedParameters.TryGetIndex(paramExpr, default(RefEq<ParameterExpression>));
                if (nonPassedParamIndex == -1)
                    return false;

                // Load non-passed argument from Closure - closure object is always a first argument
                il.Demit(OpCodes.Ldarg_0);
                il.Demit(OpCodes.Ldfld, ArrayClosureWithNonPassedParamsField);
                EmitLoadConstantInt(il, nonPassedParamIndex);
                il.Demit(OpCodes.Ldelem_Ref);
                return true;
            }

            private static bool TryEmitSimpleUnaryExpression(UnaryExpression expr, ExpressionType nodeType,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
                var exprType = expr.Type;

                if (!TryEmit(expr.Operand, paramExprs, il, ref closure, setup, parent))
                    return false;

                if (nodeType == ExpressionType.TypeAs)
                {
                    il.Demit(OpCodes.Isinst, exprType);
                    if (exprType.IsValueType)
                        il.Demit(OpCodes.Unbox_Any, exprType);
                }
                else if (nodeType == ExpressionType.IsFalse)
                {
                    var falseLabel = il.DefineLabel();
                    var continueLabel = il.DefineLabel();
                    il.Demit(OpCodes.Brfalse, falseLabel);
                    il.Demit(OpCodes.Ldc_I4_0);
                    il.Demit(OpCodes.Br, continueLabel);
                    il.DmarkLabel(falseLabel);
                    il.Demit(OpCodes.Ldc_I4_1);
                    il.DmarkLabel(continueLabel);
                }
                else if (nodeType == ExpressionType.Increment)
                {
                    if (exprType.IsPrimitive)
                    {
                        if (!TryEmitNumberOne(il, exprType))
                            return false;
                        il.Demit(OpCodes.Add);
                    }
                    else if (!EmitMethodCallCheckForNull(il, exprType.GetMethod("op_Increment")))
                        return false;
                }
                else if (nodeType == ExpressionType.Decrement)
                {
                    if (exprType.IsPrimitive)
                    {
                        if (!TryEmitNumberOne(il, exprType))
                            return false;
                        il.Demit(OpCodes.Sub);
                    }
                    else if (!EmitMethodCallCheckForNull(il, exprType.GetMethod("op_Decrement")))
                        return false;
                }
                else if (nodeType == ExpressionType.Negate | nodeType == ExpressionType.NegateChecked)
                {
                    if (exprType.IsPrimitive)
                        il.Demit(OpCodes.Neg);
                    else if (!EmitMethodCallCheckForNull(il, exprType.GetMethod("op_UnaryNegation")))
                        return false;
                }
                else if (nodeType == ExpressionType.OnesComplement)
                    il.Demit(OpCodes.Not);
                else if (nodeType == ExpressionType.Unbox)
                    il.Demit(OpCodes.Unbox_Any, exprType);
                // else if (nodeType == ExpressionType.IsTrue) { }
                // else if (nodeType == ExpressionType.UnaryPlus) { }

                return il.EmitPopIfIgnoreResult(parent);
            }

            private static bool TryEmitTypeIsOrEqual(TypeBinaryExpression expr,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
                if (!TryEmit(expr.Expression, paramExprs, il, ref closure, setup, parent))
                    return false;
                if ((parent & ParentFlags.IgnoreResult) != 0)
                    return true;
                if (expr.NodeType == ExpressionType.TypeIs)
                {
                    il.Demit(OpCodes.Isinst, expr.TypeOperand);
                    il.Demit(OpCodes.Ldnull);
                    il.Demit(OpCodes.Cgt_Un);
                    return true;
                }
                if ((setup & CompilerFlags.ThrowOnNotSupportedExpression) != 0)
                    throw new NotSupportedExpressionException(Result.NotSupported_TypeEqual);
                return false;
            }

            private static bool TryEmitNot(UnaryExpression expr,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
                var op = expr.Operand;
                if (op.NodeType == ExpressionType.Equal)
                    return TryEmitComparison(((BinaryExpression)op).Left, ((BinaryExpression)op).Right,
                        expr.Type, ExpressionType.NotEqual, paramExprs, il, ref closure, setup, parent);

                if (!TryEmit(op, paramExprs, il, ref closure, setup, parent))
                    return false;

                if ((parent & ParentFlags.IgnoreResult) != 0)
                    il.Demit(OpCodes.Pop);
                else if (expr.Type == typeof(bool))
                    EmitEqualToZeroOrNull(il);
                else
                    il.Demit(OpCodes.Not);
                return true;
            }

            private static bool TryEmitConvert(UnaryExpression expr,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
                // todo: @perf! refactor this whole thing in order to handle the hot path without heavy reflection calls
                var opExpr = expr.Operand;
                var method = expr.Method;
                if (method != null && method.Name != "op_Implicit" && method.Name != "op_Explicit")
                    return TryEmit(opExpr, paramExprs, il, ref closure, setup, parent & ~ParentFlags.IgnoreResult | ParentFlags.InstanceCall, -1)
                        && EmitMethodCallOrVirtualCall(il, method);

                var sourceType = opExpr.Type;
                var targetType = expr.Type;

                // quick path for the ignored result and conversion which can't cause the exception.
                // let's opExpr emitter to ignore the result.
                if ((parent & ParentFlags.IgnoreResult) != 0 &&
                    (sourceType == targetType || targetType.IsAssignableFrom(sourceType)))
                    return TryEmit(opExpr, paramExprs, il, ref closure, setup, parent & ~ParentFlags.InstanceAccess);

                if (!TryEmit(opExpr, paramExprs, il, ref closure, setup, parent & ~ParentFlags.IgnoreResult & ~ParentFlags.InstanceAccess))
                    return false;

                if (sourceType == targetType)
                    return il.EmitPopIfIgnoreResult(parent);

                if (targetType == typeof(object))
                    return il.TryEmitBoxOf(sourceType) && il.EmitPopIfIgnoreResult(parent);

                var underlyingNullableSourceType = sourceType.GetUnderlyingNullableTypeOrNull();
                if (underlyingNullableSourceType == targetType)
                {
                    if (!closure.LastEmitIsAddress) // from the opExpr emitter
                        EmitStoreAndLoadLocalVariableAddress(il, sourceType);
                    return EmitMethodCall(il, sourceType.FindNullableValueGetterMethod()) && il.EmitPopIfIgnoreResult(parent);
                }

                var underlyingNullableTargetType = targetType.GetUnderlyingNullableTypeOrNull();
                if (underlyingNullableTargetType == sourceType)
                {
                    il.Demit(OpCodes.Newobj, targetType.GetTypeInfo().DeclaredConstructors.GetFirst());
                    return true;
                }

                // check implicit / explicit conversion operators on source and target types
                // for non-primitives and for non-primitive nullable - #73
                if (underlyingNullableSourceType == null & !sourceType.IsPrimitive)
                {
                    method ??= sourceType.FindConvertOperator(sourceType, underlyingNullableTargetType ?? targetType);
                    if (method != null)
                    {
                        EmitMethodCall(il, method);
                        if (underlyingNullableTargetType != null)
                            il.Demit(OpCodes.Newobj, targetType.GetTypeInfo().DeclaredConstructors.GetFirst());
                        return il.EmitPopIfIgnoreResult(parent);
                    }
                }
                else if (underlyingNullableTargetType == null) // means sourceType.IsPrimitive
                {
                    if (method != null && method.DeclaringType == targetType && method.GetParameters()[0].ParameterType == sourceType)
                        return EmitMethodCall(il, method) && il.EmitPopIfIgnoreResult(parent);

                    var actualSourceType = underlyingNullableSourceType ?? sourceType;
                    method ??= actualSourceType.FindConvertOperator(actualSourceType, targetType);
                    if (method != null)
                    {
                        if (underlyingNullableSourceType != null)
                        {
                            EmitStoreAndLoadLocalVariableAddress(il, sourceType);
                            EmitMethodCall(il, sourceType.FindNullableValueGetterMethod());
                        }
                        return EmitMethodCall(il, method) && il.EmitPopIfIgnoreResult(parent);
                    }
                }

                if (targetType != typeof(string))
                {
                    if (underlyingNullableTargetType == null & !targetType.IsPrimitive)
                    {
                        if (method != null && method.DeclaringType == targetType && method.GetParameters()[0].ParameterType == sourceType)
                            return EmitMethodCall(il, method) && il.EmitPopIfIgnoreResult(parent);

                        method ??= targetType.FindConvertOperator(underlyingNullableSourceType ?? sourceType, targetType);
                        if (method != null)
                        {
                            if (underlyingNullableSourceType != null)
                            {
                                EmitStoreAndLoadLocalVariableAddress(il, sourceType);
                                EmitMethodCall(il, sourceType.FindNullableValueGetterMethod());
                            }
                            return EmitMethodCall(il, method) && il.EmitPopIfIgnoreResult(parent);
                        }
                    }
                    else if (underlyingNullableSourceType == null) // means targetType.IsPrimitive
                    {
                        var actualTargetType = underlyingNullableTargetType ?? targetType;
                        method ??= actualTargetType.FindConvertOperator(sourceType, actualTargetType);
                        if (method != null)
                        {
                            EmitMethodCall(il, method);
                            if (underlyingNullableTargetType != null)
                                il.Demit(OpCodes.Newobj, targetType.GetTypeInfo().DeclaredConstructors.GetFirst());
                            return il.EmitPopIfIgnoreResult(parent);
                        }
                    }
                }

                if (sourceType == typeof(object) && targetType.IsValueType)
                {
                    il.Demit(OpCodes.Unbox_Any, targetType);
                }
                else if (underlyingNullableTargetType != null)
                {
                    // Conversion to Nullable: `new Nullable<T>(T val);`
                    if (underlyingNullableSourceType == null)
                    {
                        if (!underlyingNullableTargetType.IsEnum && // todo: @clarify hope the source type is convertible to enum, huh 
                            !TryEmitValueConvert(underlyingNullableTargetType, il, isChecked: false))
                            return false;
                        il.Demit(OpCodes.Newobj, targetType.GetTypeInfo().DeclaredConstructors.GetFirst());
                    }
                    else
                    {
                        Debug.Assert(underlyingNullableSourceType != null);
                        var sourceVarIndex = EmitStoreAndLoadLocalVariableAddress(il, sourceType);
                        EmitMethodCall(il, sourceType.GetNullableHasValueGetterMethod());

                        var labelSourceHasValue = il.DefineLabel();
                        il.Demit(OpCodes.Brtrue_S, labelSourceHasValue); // jump where source has a value

                        // otherwise, emit and load a `new Nullable<TTarget>()` struct (that's why a Init instead of New)
                        EmitLoadLocalVariable(il, InitValueTypeVariable(il, targetType));

                        // jump to completion
                        var labelDone = il.DefineLabel();
                        il.Demit(OpCodes.Br_S, labelDone);

                        // if source nullable has a value:
                        il.DmarkLabel(labelSourceHasValue);
                        EmitLoadLocalVariableAddress(il, sourceVarIndex);
                        il.Demit(OpCodes.Ldfld, sourceType.GetNullableValueUnsafeAkaGetValueOrDefaultMethod());
                        if (method != null && method.ReturnType == targetType)
                        {
                            EmitMethodCall(il, method);
                        }
                        else
                        {
                            if (!TryEmitValueConvert(underlyingNullableTargetType, il, expr.NodeType == ExpressionType.ConvertChecked))
                            {
                                method ??= underlyingNullableTargetType.FindConvertOperator(underlyingNullableSourceType, underlyingNullableTargetType);
                                if (method == null)
                                    return false; // nor conversion nor conversion operator is found
                                EmitMethodCall(il, method);
                            }
                            il.Demit(OpCodes.Newobj, targetType.GetTypeInfo().DeclaredConstructors.GetFirst());
                        }
                        il.DmarkLabel(labelDone);
                    }
                }
                else if (targetType.IsEnum && sourceType == typeof(Enum))
                {
                    il.Demit(OpCodes.Unbox_Any, targetType); // a special case, see AutoMapper StringToEnumConverter.Should_work
                }
                else
                {
                    if (targetType.IsEnum)
                        targetType = Enum.GetUnderlyingType(targetType);

                    // fixes #159
                    if (underlyingNullableSourceType != null)
                    {
                        EmitStoreAndLoadLocalVariableAddress(il, sourceType);
                        EmitMethodCall(il, sourceType.FindNullableValueGetterMethod());
                    }

                    // cast as the last resort and let's it fail if unlucky
                    if (!TryEmitValueConvert(targetType, il, expr.NodeType == ExpressionType.ConvertChecked))
                    {
                        il.TryEmitBoxOf(sourceType);
                        il.Demit(OpCodes.Castclass, targetType);
                    }
                }

                return il.EmitPopIfIgnoreResult(parent);
            }

            private static bool TryEmitValueConvert(Type targetType, ILGenerator il, bool isChecked)
            {
                if (targetType == typeof(int))
                    il.Demit(isChecked ? OpCodes.Conv_Ovf_I4 : OpCodes.Conv_I4);
                else if (targetType == typeof(float))
                    il.Demit(OpCodes.Conv_R4);
                else if (targetType == typeof(uint))
                    il.Demit(isChecked ? OpCodes.Conv_Ovf_U4 : OpCodes.Conv_U4);
                else if (targetType == typeof(sbyte))
                    il.Demit(isChecked ? OpCodes.Conv_Ovf_I1 : OpCodes.Conv_I1);
                else if (targetType == typeof(byte))
                    il.Demit(isChecked ? OpCodes.Conv_Ovf_U1 : OpCodes.Conv_U1);
                else if (targetType == typeof(short))
                    il.Demit(isChecked ? OpCodes.Conv_Ovf_I2 : OpCodes.Conv_I2);
                else if (targetType == typeof(ushort) || targetType == typeof(char))
                    il.Demit(isChecked ? OpCodes.Conv_Ovf_U2 : OpCodes.Conv_U2);
                else if (targetType == typeof(long))
                    il.Demit(isChecked ? OpCodes.Conv_Ovf_I8 : OpCodes.Conv_I8);
                else if (targetType == typeof(ulong))
                    il.Demit(isChecked ? OpCodes.Conv_Ovf_U8 : OpCodes.Conv_U8); // should we consider if sourceType.IsUnsigned == false and using the OpCodes.Conv_I8 (seems like the System.Compile does it)
                else if (targetType == typeof(double))
                    il.Demit(OpCodes.Conv_R8);
                else
                    return false;
                return true;
            }

            public static bool TryEmitConstant(Expression expr, ILGenerator il, ref ClosureInfo closure, int byRefIndex = -1)
            {
#if LIGHT_EXPRESSION
                // todo: @perf @simplify convert to intrinsic?
                if (expr == NullConstant)
                {
                    il.Demit(OpCodes.Ldnull);
                    return true;
                }
                if (expr == FalseConstant)
                {
                    il.Demit(OpCodes.Ldc_I4_0);
                    return true;
                }
                if (expr == TrueConstant)
                {
                    il.Demit(OpCodes.Ldc_I4_1);
                    return true;
                }
                if (expr is IntConstantExpression n)
                {
                    EmitLoadConstantInt(il, n.IntValue);
                    return true;
                }
#endif
                var constExpr = (ConstantExpression)expr;
                var constValue = constExpr.Value;
                if (constValue != null)
                    return TryEmitConstant(closure.ContainsConstantsOrNestedLambdas(), expr.Type, constValue.GetType(), constValue, il, ref closure, byRefIndex);
                if (expr.Type.IsValueType)
                    return EmitLoadLocalVariable(il, InitValueTypeVariable(il, expr.Type)); // yep, this is a proper way to emit the Nullable null
                il.Demit(OpCodes.Ldnull);
                return true;
            }

            [MethodImpl((MethodImplOptions)256)]
            public static bool TryEmitNotNullConstant(bool considerClosure, object consValue, ILGenerator il, ref ClosureInfo closure, int byRefIndex = -1) =>
                TryEmitConstant(considerClosure, null, consValue.GetType(), consValue, il, ref closure, byRefIndex);

            public static bool TryEmitConstant(bool considerClosure, Type exprType, Type constType, object constValue, ILGenerator il, ref ClosureInfo closure, int byRefIndex = -1)
            {
                if (exprType == null)
                    exprType = constType;
                if (considerClosure && IsClosureBoundConstant(constValue, constType))
                {
                    var constIndex = closure.Constants.TryGetIndex(constValue, default(RefEq<object>));
                    if (constIndex == -1)
                        return false;

                    var varIndex = closure.ConstantUsageThenVarIndex[constIndex] - 1;
                    if (varIndex > 0)
                        EmitLoadLocalVariable(il, varIndex);
                    else
                    {
                        EmitLoadClosureArrayItem(il, constIndex);
                        if (exprType.IsValueType)
                        {
                            il.Demit(OpCodes.Unbox_Any, exprType);
                            if (byRefIndex != -1)
                                EmitStoreAndLoadLocalVariableAddress(il, exprType);
                        }
#if NETFRAMEWORK
                        else
                        {
                            // The cast probably required only for Full CLR starting from NET45, 
                            // e.g. `Test_283_Case6_MappingSchemaTests_CultureInfo_VerificationException`.
                            // .NET Core does not seem to care about verifiability and it's faster without the explicit cast.
                            il.Demit(OpCodes.Castclass, exprType);
                        }
#endif
                    }
                }
                else
                {
                    if (constValue is string s)
                    {
                        il.Demit(s, OpCodes.Ldstr);
                        return true;
                    }
                    if (constValue is Type t)
                    {
                        il.Demit(OpCodes.Ldtoken, t);
                        return EmitMethodCall(il, _getTypeFromHandleMethod);
                    }
                    if (!TryEmitPrimitiveOrEnumOrDecimalConstant(il, constValue, constType))
                        return false;
                }

                if (exprType.IsValueType && exprType.IsNullable())
                    il.Demit(OpCodes.Newobj, exprType.GetConstructors().GetFirst());
                else if (exprType == typeof(object))
                    return il.TryEmitBoxOf(constType); // using normal type for Enum instead of underlying type
                return true;
            }

            private static bool TryEmitPrimitiveOrEnumOrDecimalConstant(ILGenerator il, object constValue, Type constType)
            {
                if (constType.IsEnum)
                    constType = Enum.GetUnderlyingType(constType);

                switch (Type.GetTypeCode(constType))
                {
                    case TypeCode.Boolean:
                        il.Demit((bool)constValue ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0); // todo: @perf check for LightExpression
                        break;
                    case TypeCode.Char:
                        EmitLoadConstantInt(il, (char)constValue);
                        break;
                    case TypeCode.SByte:
                        EmitLoadConstantInt(il, (sbyte)constValue);
                        break;
                    case TypeCode.Byte:
                        EmitLoadConstantInt(il, (byte)constValue);
                        break;
                    case TypeCode.Int16:
                        EmitLoadConstantInt(il, (short)constValue);
                        break;
                    case TypeCode.Int32:
                        EmitLoadConstantInt(il, (int)constValue);
                        break;
                    case TypeCode.Int64:
                        il.Demit(OpCodes.Ldc_I8, (long)constValue);
                        break;
                    case TypeCode.Double:
                        il.Demit(OpCodes.Ldc_R8, (double)constValue);
                        break;
                    case TypeCode.Single:
                        il.Demit(OpCodes.Ldc_R4, (float)constValue);
                        break;
                    case TypeCode.UInt16:
                        EmitLoadConstantInt(il, (ushort)constValue);
                        break;
                    case TypeCode.UInt32:
                        unchecked
                        {
                            EmitLoadConstantInt(il, (int)(uint)constValue);
                        }
                        break;
                    case TypeCode.UInt64:
                        unchecked
                        {
                            il.Demit(OpCodes.Ldc_I8, (long)(ulong)constValue);
                        }
                        break;
                    case TypeCode.Decimal:
                        EmitDecimalConstant((decimal)constValue, il);
                        break;
                    // todo: @feature for net7 add Half, Int128, UInt128
                    default:
                        if (constType == typeof(IntPtr))
                        {
                            il.Demit(OpCodes.Ldc_I8, ((IntPtr)constValue).ToInt64());
                            break;
                        }
                        else if (constType == typeof(UIntPtr))
                        {
                            unchecked
                            {
                                il.Demit(OpCodes.Ldc_I8, (long)((UIntPtr)constValue).ToUInt64());
                            }
                            break;
                        }
                        return false;
                }
                return true;
            }

            // todo: @perf optimize using Type.TypeCode 
            internal static bool TryEmitNumberOne(ILGenerator il, Type type)
            {
                if (type == typeof(int) || type == typeof(char) || type == typeof(short) ||
                    type == typeof(byte) || type == typeof(ushort) || type == typeof(sbyte) ||
                    type == typeof(uint))
                    il.Demit(OpCodes.Ldc_I4_1);
                else if (type == typeof(long) || type == typeof(ulong) ||
                         type == typeof(IntPtr) || type == typeof(UIntPtr))
                    il.Demit(OpCodes.Ldc_I8, (long)1);
                else if (type == typeof(float))
                    il.Demit(OpCodes.Ldc_R4, 1f);
                else if (type == typeof(double))
                    il.Demit(OpCodes.Ldc_R8, 1d);
                else
                    return false;
                return true;
            }

            [MethodImpl((MethodImplOptions)256)]
            private static void EmitLoadClosureArrayItem(ILGenerator il, int i)
            {
                il.Demit(OpCodes.Ldloc_0);// SHOULD BE always at 0 location; load array field variable on the stack
                EmitLoadConstantInt(il, i);
                il.Demit(OpCodes.Ldelem_Ref);
            }

            internal static void EmitLoadConstantsAndNestedLambdasIntoVars(ILGenerator il, ref ClosureInfo closure)
            {
                // todo: @perf load the field to `var` only if the constants are more than 1
                // Load constants array field from Closure and store it into the variable
                il.Demit(OpCodes.Ldarg_0);
                il.Demit(OpCodes.Ldfld, ArrayClosureArrayField);
                EmitStoreLocalVariable(il, il.GetNextLocalVarIndex(typeof(object[]))); // always does Stloc_0
                // important that the constant will contain the nested lambdas as well in the same array after the actual constants, so the Count indicates where the constants end
                var constItems = closure.Constants.Items; // todo: @perf why do we getting when non constants is stored but just a nested lambda is present?
                var constCount = closure.Constants.Count;

                short varIndex;
                for (var i = 0; i < constCount; i++)
                {
                    ref var constUsage = ref closure.ConstantUsageThenVarIndex.GetSurePresentItemRef(i);
                    if (constUsage > 1) // todo: @perf should we proceed to do this or simplify and remove the usages for the closure info?
                    {
                        EmitLoadClosureArrayItem(il, i);
                        var varType = constItems[i].GetType();
                        if (varType.IsValueType)
                            il.Demit(OpCodes.Unbox_Any, varType);

                        varIndex = (short)il.GetNextLocalVarIndex(varType);
                        constUsage = (short)(varIndex + 1); // to distinguish from the default 1
                        EmitStoreLocalVariable(il, varIndex);
                    }
                }

                var nestedLambdasCount = closure.NestedLambdas.Count;
                if (nestedLambdasCount != 0)
                {
                    var nestedLambdas = closure.NestedLambdas.Items;
                    for (var i = 0; i < nestedLambdasCount; i++)
                    {
                        var lambdaInfo = nestedLambdas[i];
                        EmitLoadClosureArrayItem(il, constCount + i);
                        lambdaInfo.LambdaVarIndex = varIndex = (short)il.GetNextLocalVarIndex(lambdaInfo.GetLambdaType());
                        EmitStoreLocalVariable(il, varIndex);
                    }
                }
            }

            private static ConstructorInfo _decimalIntCtor, _decimalLongCtor;
            private static FieldInfo _decimalZero, _decimalOne;

            private static void EmitDecimalConstant(decimal value, ILGenerator il)
            {
                if (value == 0 | value == 1)
                {
                    // emit Decimal.Zero or Decimal.One instead of new Decimal(0) or new Decimal(1)
                    var field = value == 0 ?
                        _decimalZero ?? (_decimalZero = typeof(Decimal).GetField(nameof(Decimal.Zero))) :
                        _decimalOne ?? (_decimalOne = typeof(Decimal).GetField(nameof(Decimal.One)));
                    il.Demit(OpCodes.Ldsfld, field);
                    return;
                }

                //check if decimal has decimal places, if not use shorter IL code (constructor from int or long)
                if (value % 1 == 0)
                {
                    if (value >= int.MinValue && value <= int.MaxValue)
                    {
                        EmitLoadConstantInt(il, decimal.ToInt32(value));
                        il.Demit(OpCodes.Newobj, _decimalIntCtor ?? (_decimalIntCtor = typeof(decimal).FindSingleParamConstructor(typeof(int))));
                        return;
                    }

                    if (value >= long.MinValue && value <= long.MaxValue)
                    {
                        il.Demit(OpCodes.Ldc_I8, decimal.ToInt64(value));
                        il.Demit(OpCodes.Newobj, _decimalLongCtor ?? (_decimalLongCtor = typeof(decimal).FindSingleParamConstructor(typeof(long))));
                        return;
                    }
                }

                if (value == decimal.MinValue)
                {
                    il.Demit(OpCodes.Ldsfld, typeof(decimal).GetField(nameof(decimal.MinValue)));
                    return;
                }

                if (value == decimal.MaxValue)
                {
                    il.Demit(OpCodes.Ldsfld, typeof(decimal).GetField(nameof(decimal.MaxValue)));
                    return;
                }

                var parts = decimal.GetBits(value);
                var sign = (parts[3] & 0x80000000) != 0;
                var scale = (byte)((parts[3] >> 16) & 0x7F);

                EmitLoadConstantInt(il, parts[0]);
                EmitLoadConstantInt(il, parts[1]);
                EmitLoadConstantInt(il, parts[2]);

                il.Demit(sign ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
                EmitLoadConstantInt(il, scale);
                il.Demit(OpCodes.Conv_U1);
                il.Demit(OpCodes.Newobj, _decimalCtor.Value);
            }

            private static readonly Lazy<ConstructorInfo> _decimalCtor = new Lazy<ConstructorInfo>(() =>
            {
                foreach (var ctor in typeof(decimal).GetTypeInfo().DeclaredConstructors)
                    if (ctor.GetParameters().Length == 5)
                        return ctor;
                return null;
            });

            // todo: @perf merge with EmitLoadLocalVariable 
            private static int InitValueTypeVariable(ILGenerator il, Type exprType)
            {
                var locVarIndex = il.GetNextLocalVarIndex(exprType);
                EmitLoadLocalVariableAddress(il, locVarIndex);
                il.Demit(OpCodes.Initobj, exprType);
                return locVarIndex;
            }

            private static int InitValueTypeVariable(ILGenerator il, Type exprType, int locVarIndex)
            {
                if (locVarIndex == -1)
                    locVarIndex = il.GetNextLocalVarIndex(exprType);
                EmitLoadLocalVariableAddress(il, locVarIndex);
                il.Demit(OpCodes.Initobj, exprType);
                return locVarIndex;
            }

#if LIGHT_EXPRESSION
            private static bool EmitNewArrayBounds(NewArrayExpression expr, IParameterProvider paramExprs,
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
                var bounds = (IArgumentProvider)expr;
                var boundCount = bounds.ArgumentCount;
#else
            private static bool EmitNewArrayBounds(NewArrayExpression expr, IReadOnlyList<PE> paramExprs,
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
                var bounds = expr.Expressions;
                var boundCount = bounds.Count;
#endif
                if (boundCount == 1)
                {
                    if (!TryEmit(bounds.GetArgument(0), paramExprs, il, ref closure, setup, parent))
                        return false;
                    var elemType = expr.Type.GetElementType();
                    if (elemType == null)
                        return false;
                    il.Demit(OpCodes.Newarr, elemType);
                }
                else
                {
                    for (var i = 0; i < boundCount; i++)
                        if (!TryEmit(bounds.GetArgument(i), paramExprs, il, ref closure, setup, parent))
                            return false;
                    il.Demit(OpCodes.Newobj, expr.Type.GetTypeInfo().DeclaredConstructors.GetFirst());
                }
                return true;
            }

#if LIGHT_EXPRESSION
            private static bool EmitNewArrayInit(NewArrayExpression expr, IParameterProvider paramExprs,
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
#else
            private static bool EmitNewArrayInit(NewArrayExpression expr, IReadOnlyList<PE> paramExprs,
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
#endif
                var arrayType = expr.Type;
                if (arrayType.GetArrayRank() > 1)
                    return false; // todo: @feature multi-dimensional array initializers are not supported yet, they also are not supported by the hoisted expression

                var elemType = arrayType.GetElementType();
                if (elemType == null)
                    return false;

#if LIGHT_EXPRESSION
                var elems = (IArgumentProvider)expr;
                var elemCount = elems.ArgumentCount;
#else
                var elems = expr.Expressions;
                var elemCount = elems.Count;
#endif
                EmitLoadConstantInt(il, elemCount); // emit the length of the array calculated from the number of initializer elements
                il.Demit(OpCodes.Newarr, elemType);

                var isElemOfValueType = elemType.IsValueType;
                for (var i = 0; i < elemCount; i++)
                {
                    il.Demit(OpCodes.Dup);
                    EmitLoadConstantInt(il, i);
                    if (isElemOfValueType) // loading element address for later copying of value into it.
                    {
                        il.Demit(OpCodes.Ldelema, elemType);
                        if (!TryEmit(elems.GetArgument(i), paramExprs, il, ref closure, setup, parent))
                            return false;
                        il.Demit(OpCodes.Stobj, elemType); // store element of value type by array element address
                    }
                    else
                    {
                        if (!TryEmit(elems.GetArgument(i), paramExprs, il, ref closure, setup, parent))
                            return false;
                        il.Demit(OpCodes.Stelem_Ref);
                    }
                }
                return true;
            }

#if LIGHT_EXPRESSION
            private static bool EmitMemberInit(MemberInitExpression expr, IParameterProvider paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#else
            private static bool EmitMemberInit(MemberInitExpression expr, IReadOnlyList<PE> paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#endif
            {
                var valueVarIndex = -1;
                if (expr.Type.IsValueType)
                    valueVarIndex = il.GetNextLocalVarIndex(expr.Type);

                var newExpr = expr.NewExpression;
#if LIGHT_EXPRESSION
                if (newExpr == null)
                {
                    if (!TryEmit(expr.Expression, paramExprs, il, ref closure, setup, parent))
                        return false;
                }
                else
#endif
                {
#if SUPPORTS_ARGUMENT_PROVIDER
                    var argExprs = (IArgumentProvider)newExpr;
#else
                    var argExprs = newExpr.Arguments;
#endif
                    var argCount = argExprs.GetCount();
                    if (argCount > 0)
                    {
                        var args = newExpr.Constructor.GetParameters();
                        for (var i = 0; i < argCount; i++)
                            if (!TryEmit(argExprs.GetArgument(i), paramExprs, il, ref closure, setup, parent,
                                args[i].ParameterType.IsByRef ? i : -1))
                                return false;
                    }

                    // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                    if (newExpr.Constructor != null)
                        il.Demit(OpCodes.Newobj, newExpr.Constructor);
                    else if (newExpr.Type.IsValueType)
                        valueVarIndex = InitValueTypeVariable(il, newExpr.Type, valueVarIndex);
                    else
                        return false; // null constructor and not a value type, better to fallback
                }

#if LIGHT_EXPRESSION
                var bindings = (IArgumentProvider<MemberBinding>)expr;
                var bindCount = bindings.ArgumentCount;
#else
                var bindings = expr.Bindings;
                var bindCount = bindings.Count;
#endif
                for (var i = 0; i < bindCount; i++)
                {
                    var binding = bindings.GetArgument(i);
                    if (binding.BindingType != MemberBindingType.Assignment) // todo: @feature is not supported yet
                        return false;

                    if (valueVarIndex != -1) // load local value address, to set its members
                        EmitLoadLocalVariableAddress(il, valueVarIndex);
                    else
                        il.Demit(OpCodes.Dup); // duplicate member owner on stack

                    if (!TryEmit(((MemberAssignment)binding).Expression, paramExprs, il, ref closure, setup, parent) ||
                        !EmitMemberSet(il, binding.Member))
                        return false;
                }

                if (valueVarIndex != -1)
                    EmitLoadLocalVariable(il, valueVarIndex);
                return true;
            }

            [MethodImpl((MethodImplOptions)256)]
            private static bool TryEmitPropertySet(ILGenerator il, PropertyInfo prop)
            {
                var method = prop.SetMethod;
                return method != null && EmitMethodCallOrVirtualCall(il, method);
            }

            [MethodImpl((MethodImplOptions)256)]
            private static bool EmitFieldSet(ILGenerator il, FieldInfo field)
            {
                il.Demit(field.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, field);
                return true;
            }

            [MethodImpl((MethodImplOptions)256)]
            private static bool EmitMemberSet(ILGenerator il, MemberInfo member) =>
                member is PropertyInfo pr ? TryEmitPropertySet(il, pr) :
                member is FieldInfo field ? EmitFieldSet(il, field) :
                false;

#if LIGHT_EXPRESSION
            private static bool TryEmitListInit(ListInitExpression expr, IParameterProvider paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#else
            private static bool TryEmitListInit(ListInitExpression expr, IReadOnlyList<PE> paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#endif
            {
                var valueVarIndex = -1;
                if (expr.Type.IsValueType)
                    valueVarIndex = il.GetNextLocalVarIndex(expr.Type);

                var newExpr = expr.NewExpression;
                var exprType = newExpr.Type;
#if SUPPORTS_ARGUMENT_PROVIDER
                var argExprs = (IArgumentProvider)newExpr;
#else
                var argExprs = newExpr.Arguments;
#endif
                var argCount = argExprs.GetCount();
                if (argCount > 0)
                {
                    var args = newExpr.Constructor.GetParameters();
                    for (var i = 0; i < argCount; i++)
                        if (!TryEmit(argExprs.GetArgument(i), paramExprs, il, ref closure, setup, parent,
                            args[i].ParameterType.IsByRef ? i : -1))
                            return false;
                }

                // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                if (newExpr.Constructor != null)
                    il.Demit(OpCodes.Newobj, newExpr.Constructor);
                else if (exprType.IsValueType)
                    valueVarIndex = InitValueTypeVariable(il, exprType, valueVarIndex);
                else
                    return false; // null constructor and not a value type, better to fallback

                var inits = expr.Initializers;
                var initCount = inits.Count;
                var ok = true;

                // see the TryEmitMethodCall for the reason of the callFlags
                var callFlags = parent & ~ParentFlags.IgnoreResult & ~ParentFlags.MemberAccess & ~ParentFlags.InstanceAccess | ParentFlags.Call;
                for (var i = 0; i < initCount; ++i)
                {
                    if (valueVarIndex != -1) // load local value address, to set its members
                        EmitLoadLocalVariableAddress(il, valueVarIndex);
                    else
                        il.Demit(OpCodes.Dup); // duplicate member owner on stack

                    var elemInit = inits.GetArgument(i);
                    var method = elemInit.AddMethod;
                    var methodParams = method.GetParameters();
#if LIGHT_EXPRESSION
                    var addArgs = (IArgumentProvider)elemInit;
                    var addArgCount = elemInit.ArgumentCount;
#else
                    var addArgs = elemInit.Arguments;
                    var addArgCount = addArgs.Count;
#endif
                    for (var a = 0; ok && a < addArgCount; ++a)
                        ok = TryEmit(addArgs.GetArgument(a), paramExprs, il, ref closure, setup, callFlags, methodParams[a].ParameterType.IsByRef ? a : -1);

                    if (!exprType.IsValueType)
                        ok = EmitMethodCallOrVirtualCall(il, method);
                    else if (!method.IsVirtual // #251 - no need for constrained or virtual call because it is already by-ref
                        || method.DeclaringType == exprType)
                        ok = EmitMethodCall(il, method);
                    else
                    {
                        il.Demit(OpCodes.Constrained, exprType); // todo: @clarify it is a value type so... can we de-virtualize the call?
                        ok = EmitVirtualMethodCall(il, method);
                    }
                }

                if (valueVarIndex != -1)
                    EmitLoadLocalVariable(il, valueVarIndex);
                return ok;
            }

            // the `right = null` argument indicates the increment/decrement operation
            private static bool TryEmitArithmeticAndOrAssign(
                Expression left, Expression right, Type exprType, ExpressionType nodeType, bool isPost,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
                // we need the result variable and the time of Post/Pre when to store it only if the result is not ignored, otherwise don't bother
                var resultVar = -1;
                if (!parent.IgnoresResult())
                    resultVar = il.GetNextLocalVarIndex(exprType);

                switch (left.NodeType)
                {
                    case ExpressionType.Parameter:
                        if (!isPost)
                            return TryEmitAssignToParameterOrVariable((ParameterExpression)left, right,
                                nodeType, isPost, exprType, paramExprs, il, ref closure, setup, parent, resultVar);

                        // todo: @wip split for now between the Increment/Decrement and the rest
                        var p = (ParameterExpression)left;
#if LIGHT_EXPRESSION
                        var paramExprCount = paramExprs.ParameterCount;
#else
                        var paramExprCount = paramExprs.Count;
#endif
                        var paramIndex = -1;
                        var localVarIndex = closure.GetDefinedLocalVarOrDefault(p);
                        if (localVarIndex != -1)
                            EmitLoadLocalVariable(il, localVarIndex); // todo: @wip #346
                        else
                        {
                            paramIndex = paramExprCount - 1;
                            while (paramIndex != -1 && !ReferenceEquals(paramExprs.GetParameter(paramIndex), p)) --paramIndex;
                            if (paramIndex == -1)
                                return false;
                            if ((closure.Status & ClosureStatus.ShouldBeStaticMethod) == 0)
                                ++paramIndex;
                            EmitLoadArg(il, paramIndex);
                            if (p.IsByRef)
                                EmitLoadIndirectlyByRef(il, p.Type);
                        }

                        if (resultVar != -1 & isPost)
                            EmitStoreAndLoadLocalVariable(il, resultVar); // for the post increment/decrement save the non-incremented value for the later further use

                        EmitIncOrDec(il, nodeType == ExpressionType.Add);

                        if (resultVar != -1 & !isPost)
                            EmitStoreAndLoadLocalVariable(il, resultVar);

                        if (localVarIndex != -1)
                            EmitStoreLocalVariable(il, localVarIndex); // store incremented value into the local value;
                        else if (p.IsByRef)
                        {
                            var incrementedVar = il.GetNextLocalVarIndex(exprType);
                            EmitStoreLocalVariable(il, incrementedVar);
                            EmitLoadArg(il, paramIndex);
                            EmitLoadLocalVariable(il, incrementedVar);
                            EmitStoreIndirectlyByRef(il, exprType);
                        }
                        else
                            il.Demit(OpCodes.Starg_S, paramIndex);
                        break;

                    case ExpressionType.ArrayIndex:
                        throw new InvalidOperationException("ArrayIndex is not supported for the left part of the assignment operation. Use Index instead.");

                    case ExpressionType.MemberAccess:
                    case ExpressionType.Index:
                        var leftMemberExpr = left as MemberExpression;
                        var orLeftIndexExpr = left as IndexExpression;

                        // return early for not supported types of left value to avoid multiple checks below
                        if (leftMemberExpr == null & orLeftIndexExpr == null)
                            return false;

                        var indexArgCount = -1;
#if SUPPORTS_ARGUMENT_PROVIDER
                        IArgumentProvider indexArgs = null;
#else
                        IReadOnlyList<Expression> indexArgs = null;
#endif
                        if (orLeftIndexExpr != null)
                        {
#if SUPPORTS_ARGUMENT_PROVIDER
                            indexArgs = (IArgumentProvider)orLeftIndexExpr;
#else
                            indexArgs = orLeftIndexExpr.Arguments;
#endif
                            indexArgCount = indexArgs.GetCount();
                            if (indexArgCount > 4)
                                return false; // todo: @feature more than 4 index arguments are not supported, and probably not need to be supported
                        }

                        var objExpr = leftMemberExpr != null ? leftMemberExpr.Expression : orLeftIndexExpr.Object;

                        // Remove the InstanceCall because we need to operate on the (nullable) field value and not on `ref` to return the value.
                        // We may avoid it in case of not returning the value or PreIncrement/PreDecrement, but let's do less checks and branching.
                        var baseFlags = parent & ~ParentFlags.IgnoreResult & ~ParentFlags.InstanceCall;
                        var rightOnlyFlags = baseFlags | ParentFlags.AssignmentRightValue;

                        var memberOrIndexFlags = leftMemberExpr != null ? ParentFlags.MemberAccess : ParentFlags.IndexAccess;
                        var leftArLeastFlags = baseFlags | ParentFlags.AssignmentLeftValue | memberOrIndexFlags;

                        var leftIsByAddress = false;
                        if (nodeType == ExpressionType.Assign)
                        {
                            Debug.Assert(right != null);
                            var rightType = right.Type;

                            // if the right part is the block or alike, it is better from the complexity perspective
                            // to emit it first and then restore the assignement target from var and assign the value
                            var rightVar = -1;
                            if (right.NodeType.IsBlockLikeOrConditional() ||
                                right.NodeType == ExpressionType.Invoke)
                            {
                                if (!TryEmit(right, paramExprs, il, ref closure, setup, rightOnlyFlags))
                                    return false;
                                if (closure.LastEmitIsAddress)
                                    EmitLoadIndirectlyByRef(il, rightType);
                                rightVar = resultVar != -1 ? resultVar : il.GetNextLocalVarIndex(rightType);
                                EmitStoreLocalVariable(il, rightVar);
                            }

                            // Emit the left-value instance and index(es) (for the index access)
                            if (leftMemberExpr != null)
                            {
                                if (objExpr != null &&
                                    !TryEmit(objExpr, paramExprs, il, ref closure, setup, leftArLeastFlags | ParentFlags.InstanceAccess))
                                    return false;
                            }
                            else
                            {
                                Debug.Assert(orLeftIndexExpr != null);
                                if (objExpr != null)
                                {
                                    var isIndexerAMethodCall = indexArgCount > 1 | orLeftIndexExpr.Indexer != null;
                                    var objFlags = isIndexerAMethodCall ? ParentFlags.InstanceCall : ParentFlags.InstanceAccess | ParentFlags.IndexAccess;
                                    if (!TryEmit(objExpr, paramExprs, il, ref closure, setup, objFlags | ParentFlags.AssignmentLeftValue))
                                        return false;
                                }
                                for (var i = 0; i < indexArgCount; i++)
                                    if (!TryEmit(indexArgs.GetArgument(i), paramExprs, il, ref closure, setup, baseFlags, -1))
                                        return false;
                            }

                            // Load already emitted or emit the right-value normally after the left to be assigned
                            if (rightVar != -1)
                            {
                                EmitLoadLocalVariable(il, rightVar);
                            }
                            else
                            {
                                if (!TryEmit(right, paramExprs, il, ref closure, setup, rightOnlyFlags))
                                    return false;
                                if (resultVar != -1)
                                    EmitStoreAndLoadLocalVariable(il, resultVar);
                            }

                            if (leftMemberExpr != null)
                            {
                                if (!EmitMemberSet(il, leftMemberExpr.Member))
                                    return false;
                            }
                            else // if (leftIndexExpr != null)
                            {
                                var ok = orLeftIndexExpr.Indexer != null
                                    ? EmitMethodCallOrVirtualCallCheckForNull(il, orLeftIndexExpr.Indexer.SetMethod)
                                    : indexArgCount == 1
                                        ? TryEmitArrayIndexSet(il, orLeftIndexExpr.Type) // one-dimensional array
                                        : EmitMethodCallOrVirtualCallCheckForNull(il, objExpr?.Type.FindMethod("Set")); // multi-dimensional array
                                if (!ok)
                                    return false;
                            }

                            if (resultVar != -1)
                                EmitLoadLocalVariable(il, resultVar);
                            return true;
                        }

                        // Here we are at Arithmetic + Assign:
                        // 1. First loading the left part as a part of right assignment,
                        // 2. Loading the right value
                        // 3. Do arithmetic operation
                        // 4. Storing the result in the local variable
                        // 5. Loading the left value for assignment
                        // 6. Loading the stored arithmetic result
                        // 7. Assign the result
                        var leftOrRightNullableAreNullLabel = default(Label);
                        var leftType = left.Type;
                        if (leftMemberExpr != null)
                        {
                            if (!TryEmitMemberGet(leftMemberExpr, paramExprs, il, ref closure, setup,
                                    leftArLeastFlags | ParentFlags.Arithmetic | ParentFlags.DupIt))
                                return false;
                        }
                        else // if (leftIndexExpr != null)
                        {
                            // determine is the index essentially the method call to get/set value
                            var isIndexerAMethodCall = indexArgCount > 1 | orLeftIndexExpr.Indexer != null;
                            var objVar = -1;
                            var objVarByAddress = false;
                            if (objExpr != null)
                            {
                                var objFlags = isIndexerAMethodCall ? ParentFlags.InstanceCall : ParentFlags.InstanceAccess | ParentFlags.IndexAccess;
                                if (!TryEmit(objExpr, paramExprs, il, ref closure, setup, objFlags | ParentFlags.Arithmetic))
                                    return false;

                                // required for calling the method on the value type parameter
                                var objType = objExpr.Type;
                                objVarByAddress = objType.IsValueType && !closure.LastEmitIsAddress && // todo: @wip avoid ad-hocking with parameter here
                                    (objExpr.NodeType != ExpressionType.Parameter || !((ParameterExpression)objExpr).IsByRef);
                                if (objVarByAddress)
                                    objVar = EmitStoreAndLoadLocalVariableAddress(il, objType);
                                else
                                {
                                    if (objExpr is ParameterExpression pe && pe.IsByRef)
                                        objType = objType.MakeByRefType();
                                    objVar = EmitStoreAndLoadLocalVariable(il, objType);
                                }
                            }

                            int indexArgVar0 = -1, indexArgVar1 = -1, indexArgVar2 = -1, indexArgVar3 = -1; // using stackalloc array?
                            for (var i = 0; i < indexArgCount; i++)
                            {
                                var indexArg = indexArgs.GetArgument(i);
                                if (!TryEmit(indexArg, paramExprs, il, ref closure, setup, baseFlags))
                                    return false;
                                var indexArgVar = EmitStoreAndLoadLocalVariable(il, indexArg.Type);
                                if (i == 0) indexArgVar0 = indexArgVar;
                                else if (i == 1) indexArgVar1 = indexArgVar;
                                else if (i == 2) indexArgVar2 = indexArgVar;
                                else if (i == 3) indexArgVar3 = indexArgVar;
                            }

                            // repeat the load of the obj and index variables for the assignment here to avoid store and load of the right value
                            if (objExpr != null)
                            {
                                if (!objVarByAddress)
                                    EmitLoadLocalVariable(il, objVar);
                                else
                                    EmitLoadLocalVariableAddress(il, objVar);
                            }

                            EmitLoadLocalVariable(il, indexArgVar0); // there is always at least one index argument
                            if (indexArgVar1 != -1)
                            {
                                EmitLoadLocalVariable(il, indexArgVar1);
                                if (indexArgVar2 != -1)
                                    EmitLoadLocalVariable(il, indexArgVar2);
                                if (indexArgVar3 != -1)
                                    EmitLoadLocalVariable(il, indexArgVar3);
                            }

                            var ok = !isIndexerAMethodCall
                                ? TryEmitArrayIndexGet(il, orLeftIndexExpr.Type, ref closure, baseFlags) // one-dimensional array
                                : orLeftIndexExpr.Indexer != null
                                    ? EmitMethodCallOrVirtualCallCheckForNull(il, orLeftIndexExpr.Indexer.GetMethod)
                                    : EmitMethodCallOrVirtualCallCheckForNull(il, objExpr?.Type.FindMethod("Get")); // multi-dimensional array
                            if (!ok)
                                return false;
                        }

                        if (leftIsByAddress = closure.LastEmitIsAddress)
                            EmitLoadIndirectlyByRef(il, leftType); // if the field is loaded by ref, it need to be loaded from the ref in order to do arithmetic operation on it

                        var leftIsNullable = leftType.IsNullable();
                        if (!leftIsNullable)
                        {
                            if (right == null) // optimization for the common increment/decrement case, indicated by using the null for the right argument 
                            {
                                if (resultVar != -1 & isPost)
                                    EmitStoreAndLoadLocalVariable(il, resultVar); // for the post increment/decrement save the non-incremented value before doing any operation on it
                                EmitIncOrDec(il, nodeType == ExpressionType.Add);
                                if (resultVar != -1 & !isPost)
                                    EmitStoreAndLoadLocalVariable(il, resultVar);
                            }
                            else
                            {
                                var rightType = right.Type;
                                if (!TryEmit(right, paramExprs, il, ref closure, setup, rightOnlyFlags))
                                    return false;

                                var rightIsNullable = rightType.IsNullable();
                                if (rightIsNullable) // todo: @perf @clarify is it even possible to have left non-nullable and right nullable
                                {
                                    var rightVar = EmitStoreAndLoadLocalVariableAddress(il, rightType);
                                    il.Demit(OpCodes.Call, leftType.GetNullableHasValueGetterMethod());

                                    il.Demit(OpCodes.Brfalse, leftOrRightNullableAreNullLabel = il.DefineLabel());

                                    EmitLoadLocalVariableAddress(il, rightVar);
                                    il.Demit(OpCodes.Ldfld, rightType.GetNullableValueUnsafeAkaGetValueOrDefaultMethod()); // unwrap right operand
                                }

                                if (!TryEmitArithmeticOperation(leftType, rightType, nodeType, exprType, il))
                                    return false;
                                if (resultVar != -1)
                                    EmitStoreAndLoadLocalVariable(il, resultVar);
                            }
                        }
                        else // if `leftIsNullable == true`
                        {
                            // Reuse the result variable for the field,
                            // so it may be returned as the original value of field if nullable is `null` and we jump to the return
                            var leftNullableVar = resultVar != -1 ? resultVar : il.GetNextLocalVarIndex(leftType);
                            EmitStoreLocalVariable(il, leftNullableVar);

                            if (right == null)
                            {
                                EmitLoadLocalVariableAddress(il, leftNullableVar);
                                il.Demit(OpCodes.Call, leftType.GetNullableHasValueGetterMethod());

                                il.Demit(OpCodes.Brfalse, leftOrRightNullableAreNullLabel = il.DefineLabel());

                                EmitLoadLocalVariableAddress(il, leftNullableVar);
                                il.Demit(OpCodes.Ldfld, leftType.GetNullableValueUnsafeAkaGetValueOrDefaultMethod());

                                EmitIncOrDec(il, nodeType == ExpressionType.Add);
                            }
                            else
                            {
                                // emit the right expression immediatly after the left and then just process their results
                                var rightType = right.Type;
                                if (!TryEmit(right, paramExprs, il, ref closure, setup, rightOnlyFlags))
                                    return false;
                                if (closure.LastEmitIsAddress)
                                    EmitLoadIndirectlyByRef(il, rightType);

                                var rightVar = EmitStoreLocalVariable(il, rightType);

                                var rightIsNullable = rightType.IsNullable();
                                if (!rightIsNullable) // todo: @perf @clarify if it is possible to have left nullable and right non-nullable
                                {
                                    EmitLoadLocalVariableAddress(il, leftNullableVar);
                                    il.Demit(OpCodes.Call, leftType.GetNullableHasValueGetterMethod());

                                    il.Demit(OpCodes.Brfalse, leftOrRightNullableAreNullLabel = il.DefineLabel());

                                    EmitLoadLocalVariableAddress(il, leftNullableVar);
                                    il.Demit(OpCodes.Ldfld, leftType.GetNullableValueUnsafeAkaGetValueOrDefaultMethod());

                                    EmitLoadLocalVariable(il, rightVar);
                                }
                                else
                                {
                                    EmitLoadLocalVariableAddress(il, leftNullableVar);
                                    il.Demit(OpCodes.Call, leftType.GetNullableHasValueGetterMethod());

                                    EmitLoadLocalVariableAddress(il, rightVar);
                                    il.Demit(OpCodes.Call, rightType.GetNullableHasValueGetterMethod());
                                    il.Demit(OpCodes.And);
                                    il.Demit(OpCodes.Brfalse, leftOrRightNullableAreNullLabel = il.DefineLabel());

                                    EmitLoadLocalVariableAddress(il, leftNullableVar);
                                    il.Demit(OpCodes.Ldfld, leftType.GetNullableValueUnsafeAkaGetValueOrDefaultMethod());  // unwrap left operand

                                    EmitLoadLocalVariableAddress(il, rightVar);
                                    il.Demit(OpCodes.Ldfld, rightType.GetNullableValueUnsafeAkaGetValueOrDefaultMethod()); // unwrap right operand
                                }

                                if (!TryEmitArithmeticOperation(leftType, rightType, nodeType, exprType, il))
                                    return false;
                            }

                            il.Demit(OpCodes.Newobj, leftType.GetNullableConstructor()); // wrap the result back into the nullable
                            if (resultVar != -1 & !isPost)
                                EmitStoreAndLoadLocalVariable(il, resultVar);
                        }

                        if (leftIsByAddress)
                            EmitStoreIndirectlyByRef(il, leftType);
                        else if (leftMemberExpr != null)
                        {
                            if (!EmitMemberSet(il, leftMemberExpr.Member))
                                return false;
                        }
                        else // if (leftIndexExpr != null)
                        {
                            var ok = orLeftIndexExpr.Indexer != null
                                ? EmitMethodCallOrVirtualCallCheckForNull(il, orLeftIndexExpr.Indexer.SetMethod)
                                : indexArgCount == 1
                                    ? TryEmitArrayIndexSet(il, orLeftIndexExpr.Type) // one-dimensional array
                                    : EmitMethodCallOrVirtualCallCheckForNull(il, objExpr?.Type.FindMethod("Set")); // multi-dimensional array
                            if (!ok)
                                return false;
                        }

                        if (leftIsNullable)
                        {
                            // todo: @perf @simplify avoid the Dup and the Pop for this case
                            if (leftIsByAddress | objExpr != null)
                            {
                                var skipPopLeftDuppedInstance = il.DefineLabel();
                                il.Demit(OpCodes.Br_S, skipPopLeftDuppedInstance);
                                il.DmarkLabel(leftOrRightNullableAreNullLabel); // jump here if nullables are null after checking them with `!HasValue`

                                il.Demit(OpCodes.Pop); // pop the dupped instance address or the field address, or the array instance address

                                if (orLeftIndexExpr != null)
                                {
                                    il.Demit(OpCodes.Pop); // pop the first index argument which is always present
                                    if (indexArgCount > 1)
                                    {
                                        il.Demit(OpCodes.Pop);
                                        if (indexArgCount > 2)
                                        {
                                            il.Demit(OpCodes.Pop);
                                            if (indexArgCount > 3)
                                                il.Demit(OpCodes.Pop); // pop the 4th last supprted index argument
                                        }
                                    }
                                }

                                il.DmarkLabel(skipPopLeftDuppedInstance);
                            }
                            else
                            {
                                il.DmarkLabel(leftOrRightNullableAreNullLabel); // jump here if nullables are null after checking them with `!HasValue`
                            }
                        }
                        break;
                    default:
                        return false;
                }

                if (resultVar != -1)
                    EmitLoadLocalVariable(il, resultVar);
                return true;
            }

            private static ExpressionType AssignToArithmeticOrSelf(ExpressionType nodeType) => nodeType switch
            {
                ExpressionType.AddAssign => ExpressionType.Add,
                ExpressionType.AddAssignChecked => ExpressionType.AddChecked,
                ExpressionType.SubtractAssign => ExpressionType.Subtract,
                ExpressionType.SubtractAssignChecked => ExpressionType.SubtractChecked,
                ExpressionType.MultiplyAssign => ExpressionType.Multiply,
                ExpressionType.MultiplyAssignChecked => ExpressionType.MultiplyChecked,
                ExpressionType.DivideAssign => ExpressionType.Divide,
                ExpressionType.ModuloAssign => ExpressionType.Modulo,
                ExpressionType.PowerAssign => ExpressionType.Power,
                ExpressionType.AndAssign => ExpressionType.And,
                ExpressionType.OrAssign => ExpressionType.Or,
                ExpressionType.ExclusiveOrAssign => ExpressionType.ExclusiveOr,
                ExpressionType.LeftShiftAssign => ExpressionType.LeftShift,
                ExpressionType.RightShiftAssign => ExpressionType.RightShift,
                _ => nodeType
            };

            // the null `right` means the increment/decrement operation
            private static bool TryEmitAssignToParameterOrVariable(
                ParameterExpression left, Expression right, ExpressionType nodeType, bool isPost, Type exprType,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent, int resultVar = -1)
            {
#if LIGHT_EXPRESSION
                var paramExprCount = paramExprs.ParameterCount;
#else
                var paramExprCount = paramExprs.Count;
#endif
                var ok = false;
                var flags = parent & ~ParentFlags.IgnoreResult;

                // First look if the left value is the local variable (in the current block) then store the right value in it.
                var leftLocalVar = closure.GetDefinedLocalVarOrDefault(left);
                if (leftLocalVar != -1)
                {
                    if (resultVar != -1 & isPost)
                    {
                        EmitLoadLocalVariable(il, leftLocalVar);
                        EmitStoreLocalVariable(il, resultVar); // for the post increment/decrement save the non-incremented value for the later further use
                    }

                    var isLeftByRef = left.IsByRef;
                    if (nodeType == ExpressionType.Assign)
                    {
                        var varFlags = flags | ParentFlags.AssignmentRightValue;
                        if (isLeftByRef)
                            varFlags |= ParentFlags.AssignmentByRef;
                        ok = TryEmit(right, paramExprs, il, ref closure, setup, varFlags);
                        if (resultVar != -1 & !isPost)
                            EmitStoreAndLoadLocalVariable(il, resultVar);
                        if (!isLeftByRef)
                            EmitStoreLocalVariable(il, leftLocalVar);
                    }
                    else
                    {
                        ok = TryEmitArithmetic(left, right, nodeType, exprType, paramExprs, il, ref closure, setup, flags | ParentFlags.AssignmentLeftValue);
                        if (resultVar != -1 & !isPost)
                            EmitStoreAndLoadLocalVariable(il, resultVar);
                        if (isLeftByRef)
                            EmitStoreIndirectlyByRef(il, exprType);
                        else
                            EmitStoreLocalVariable(il, leftLocalVar);
                    }

                    // assigning the new value into the already closed variable - it enables the recursive nested lambda calls, see #353
                    var nestedLambdasCount = closure.NestedLambdas.Count;
                    for (var i = 0; i < nestedLambdasCount; ++i)
                        EmitStoreAssignedLeftVarIntoClosureArray(il, closure.NestedLambdas.Items[i], left, leftLocalVar);

                    if (resultVar != -1)
                        EmitLoadLocalVariable(il, resultVar);
                    return ok;
                }

                // If not the variable, then look if it is the passed parameter - yes it is bad but you can assign to the parameter
                var paramIndex = paramExprCount - 1;
                while (paramIndex != -1 && !ReferenceEquals(paramExprs.GetParameter(paramIndex), left)) --paramIndex;
                if (paramIndex != -1)
                {
                    // shift parameter index by one, because the first one will be closure
                    if ((closure.Status & ClosureStatus.ShouldBeStaticMethod) == 0)
                        ++paramIndex;

                    var isLeftByRef = left.IsByRef;
                    if (isLeftByRef)
                        EmitLoadArg(il, paramIndex);

                    if (resultVar != -1 & isPost)
                        EmitStoreAndLoadLocalVariable(il, resultVar); // for the post increment/decrement save the non-incremented value for the later further use

                    ok = nodeType == ExpressionType.Assign
                        ? TryEmit(right, paramExprs, il, ref closure, setup, flags)
                        : TryEmitArithmetic(left, right, nodeType, exprType, paramExprs, il, ref closure, setup, flags);

                    if (resultVar != -1 & !isPost)
                        EmitStoreAndLoadLocalVariable(il, resultVar);

                    if (isLeftByRef)
                        EmitStoreIndirectlyByRef(il, left.Type);
                    else
                        il.Demit(OpCodes.Starg_S, paramIndex);

                    if (resultVar != -1)
                        EmitLoadLocalVariable(il, resultVar);
                    return ok;
                }

                // check that it is a captured parameter by closure
                var nonPassedParamIndex = closure.NonPassedParameters.TryGetIndex(left, default(RefEq<ParameterExpression>));
                if (nonPassedParamIndex == -1)
                    return false;

                if (nodeType == ExpressionType.Assign)
                {
                    if (!TryEmit(right, paramExprs, il, ref closure, setup, flags))
                        return false;
                    if (right is ParameterExpression rp && rp.IsByRef)
                        EmitLoadIndirectlyByRef(il, rp.Type);

                    var rightVar = resultVar != -1 ? resultVar : il.GetNextLocalVarIndex(exprType);
                    EmitStoreLocalVariable(il, rightVar);

                    // load array field and param item index
                    il.Demit(OpCodes.Ldarg_0); // load closure as it is always an argument zero
                    il.Demit(OpCodes.Ldfld, ArrayClosureWithNonPassedParamsField);
                    EmitLoadConstantInt(il, nonPassedParamIndex);

                    EmitLoadLocalVariable(il, rightVar);

                    il.TryEmitBoxOf(exprType);
                    il.Demit(OpCodes.Stelem_Ref); // put the variable into array

                    // assigning the new value into the already closed variable - it enables the recursive nested lambda calls, see #353
                    var nestedLambdasCount = closure.NestedLambdas.Count;
                    for (var i = 0; i < nestedLambdasCount; ++i)
                        EmitStoreAssignedLeftVarIntoClosureArray(il, closure.NestedLambdas.Items[i], left, rightVar);

                    if (resultVar != -1)
                        EmitLoadLocalVariable(il, rightVar);
                    return true;
                }

                if (resultVar != -1 & isPost)
                {
                    il.Demit(OpCodes.Ldarg_0); // load closure as it is always an argument zero
                    il.Demit(OpCodes.Ldfld, ArrayClosureWithNonPassedParamsField);
                    EmitLoadConstantInt(il, nonPassedParamIndex);
                    il.Demit(OpCodes.Ldelem_Ref); // load the variable from array
                    if (exprType.IsValueType)
                        il.Demit(OpCodes.Unbox_Any, exprType);
#if NETFRAMEWORK
                    else
                        il.Demit(OpCodes.Castclass, exprType);
#endif
                    EmitStoreLocalVariable(il, resultVar);
                }

                // todo: @perf optimize for the increment/decrement case
                if (!TryEmitArithmetic(left, right, nodeType, exprType, paramExprs, il, ref closure, setup, flags))
                    return false;

                var arithmethicResultVar = resultVar != -1 ? resultVar : il.GetNextLocalVarIndex(exprType);
                EmitStoreLocalVariable(il, arithmethicResultVar);

                il.Demit(OpCodes.Ldarg_0); // load closure as it is always an argument zero
                il.Demit(OpCodes.Ldfld, ArrayClosureWithNonPassedParamsField);
                EmitLoadConstantInt(il, nonPassedParamIndex);

                EmitLoadLocalVariable(il, arithmethicResultVar);

                il.TryEmitBoxOf(exprType);
                il.Demit(OpCodes.Stelem_Ref); // put the variable into array

                if (resultVar != -1 & !isPost)
                    EmitLoadLocalVariable(il, arithmethicResultVar);
                return true;
            }

            private static void EmitStoreAssignedLeftVarIntoClosureArray(ILGenerator il, NestedLambdaInfo nestedLambdaInfo, ParameterExpression assignedLeftVar, int assignedLeftVarIndex)
            {
                if (nestedLambdaInfo.NonPassedParamsVarIndex == 0)
                    return;
                var nonPassedParIndex = nestedLambdaInfo.NonPassedParameters.TryGetIndex(assignedLeftVar, default(RefEq<ParameterExpression>));
                if (nonPassedParIndex == -1)
                    return;
                EmitLoadLocalVariable(il, nestedLambdaInfo.NonPassedParamsVarIndex);
                EmitLoadConstantInt(il, nonPassedParIndex);
                EmitLoadLocalVariable(il, assignedLeftVarIndex);
                il.TryEmitBoxOf(assignedLeftVar.Type);
                il.Demit(OpCodes.Stelem_Ref); // put the variable into non-passed parameters (variables) array
            }

            private static void EmitLoadIndirectlyByRef(ILGenerator il, Type type)
            {
                if (type.IsEnum)
                    type = Enum.GetUnderlyingType(type);
                switch (Type.GetTypeCode(type))
                {
                    case TypeCode.Boolean: il.Demit(OpCodes.Ldind_U1); break;
                    case TypeCode.Char: il.Demit(OpCodes.Ldind_U1); break;
                    case TypeCode.Byte: il.Demit(OpCodes.Ldind_U1); break;
                    case TypeCode.SByte: il.Demit(OpCodes.Ldind_I1); break;
                    case TypeCode.Int16: il.Demit(OpCodes.Ldind_I2); break;
                    case TypeCode.Int32: il.Demit(OpCodes.Ldind_I4); break;
                    case TypeCode.Int64: il.Demit(OpCodes.Ldind_I8); break;
                    case TypeCode.Double: il.Demit(OpCodes.Ldind_R8); break;
                    case TypeCode.Single: il.Demit(OpCodes.Ldind_R4); break;
                    case TypeCode.UInt16: il.Demit(OpCodes.Ldind_U2); break;
                    case TypeCode.UInt32: il.Demit(OpCodes.Ldind_U4); break;
                    case TypeCode.UInt64: il.Demit(OpCodes.Ldobj, type); break;
                    case TypeCode.String: il.Demit(OpCodes.Ldind_Ref); break;
                    default:
                        if (type == typeof(IntPtr) | type == typeof(UIntPtr))
                            il.Demit(OpCodes.Ldind_I);
                        else if (type.IsValueType)
                            il.Demit(OpCodes.Ldobj, type);
                        else
                            il.Demit(OpCodes.Ldind_Ref);
                        break;
                }
            }

            private static void EmitStoreIndirectlyByRef(ILGenerator il, Type type)
            {
                if (type.IsEnum)
                    type = Enum.GetUnderlyingType(type);
                switch (Type.GetTypeCode(type))
                {
                    case TypeCode.Boolean: il.Demit(OpCodes.Stind_I1); break;
                    case TypeCode.Char: il.Demit(OpCodes.Stind_I1); break;
                    case TypeCode.Byte: il.Demit(OpCodes.Stind_I1); break;
                    case TypeCode.SByte: il.Demit(OpCodes.Stind_I1); break;
                    case TypeCode.Int16: il.Demit(OpCodes.Stind_I2); break;
                    case TypeCode.Int32: il.Demit(OpCodes.Stind_I4); break;
                    case TypeCode.Int64: il.Demit(OpCodes.Stind_I8); break;
                    case TypeCode.Double: il.Demit(OpCodes.Stind_R8); break;
                    case TypeCode.Single: il.Demit(OpCodes.Stind_R4); break;
                    case TypeCode.String: il.Demit(OpCodes.Stind_Ref); break;
                    case TypeCode.UInt16: il.Demit(OpCodes.Stind_I2); break;
                    case TypeCode.UInt32: il.Demit(OpCodes.Stind_I4); break;
                    case TypeCode.UInt64: il.Demit(OpCodes.Stind_I8); break;
                    default:
                        if (type == typeof(IntPtr) || type == typeof(UIntPtr))
                            il.Demit(OpCodes.Stind_I);
                        else if (type.IsValueType)
                            il.Demit(OpCodes.Stobj, type);
                        else
                            il.Demit(OpCodes.Stind_Ref);
                        break;
                }
            }

            private static bool TryEmitArrayIndexGet(ILGenerator il, Type type, ref ClosureInfo closure, ParentFlags parent)
            {
                if (!type.IsValueType)
                {
                    il.Demit(OpCodes.Ldelem_Ref);
                    return true;
                }

                // access the value type by address when it is used later for the member access, as instance in the method call, assigned to the left;
                if ((parent & (ParentFlags.MemberAccess | ParentFlags.InstanceAccess | ParentFlags.AssignmentByRef)) != 0)
                {
                    il.Demit(OpCodes.Ldelema, type);
                    closure.LastEmitIsAddress = true;
                    return true;
                }
                // todo: @perf @simplify convert to switch on TypeCode
                if (type == typeof(Int32))
                    il.Demit(OpCodes.Ldelem_I4);
                else if (type == typeof(Int64))
                    il.Demit(OpCodes.Ldelem_I8);
                else if (type == typeof(Int16))
                    il.Demit(OpCodes.Ldelem_I2);
                else if (type == typeof(SByte))
                    il.Demit(OpCodes.Ldelem_I1);
                else if (type == typeof(Single))
                    il.Demit(OpCodes.Ldelem_R4);
                else if (type == typeof(Double))
                    il.Demit(OpCodes.Ldelem_R8);
                else if (type == typeof(IntPtr))
                    il.Demit(OpCodes.Ldelem_I);
                else if (type == typeof(UIntPtr))
                    il.Demit(OpCodes.Ldelem_I);
                else if (type == typeof(Byte))
                    il.Demit(OpCodes.Ldelem_U1);
                else if (type == typeof(UInt16))
                    il.Demit(OpCodes.Ldelem_U2);
                else if (type == typeof(UInt32))
                    il.Demit(OpCodes.Ldelem_U4);
                else
                    il.Demit(OpCodes.Ldelem, type);
                return true;
            }

            private static bool TryEmitArrayIndexSet(ILGenerator il, Type elementType)
            {
                if (!elementType.IsValueType)
                {
                    il.Demit(OpCodes.Stelem_Ref);
                    return true;
                }

                if (elementType == typeof(Int32))
                    il.Demit(OpCodes.Stelem_I4);
                else if (elementType == typeof(Int64))
                    il.Demit(OpCodes.Stelem_I8);
                else if (elementType == typeof(Int16))
                    il.Demit(OpCodes.Stelem_I2);
                else if (elementType == typeof(SByte))
                    il.Demit(OpCodes.Stelem_I1);
                else if (elementType == typeof(Single))
                    il.Demit(OpCodes.Stelem_R4);
                else if (elementType == typeof(Double))
                    il.Demit(OpCodes.Stelem_R8);
                else if (elementType == typeof(IntPtr))
                    il.Demit(OpCodes.Stelem_I);
                else if (elementType == typeof(UIntPtr))
                    il.Demit(OpCodes.Stelem_I);
                else
                    il.Demit(OpCodes.Stelem, elementType);
                return true;
            }

            private static bool TryEmitMethodCall(Expression expr,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
                var flags = ParentFlags.Call;
                var callExpr = (MethodCallExpression)expr;
                var objExpr = callExpr.Object;
                var method = callExpr.Method;
                var methodParams = method.GetParameters(); // todo: @perf @mem find how to avoid the call, look at `NewNoByRefArgs` expressions as example

                var objIsValueType = false;
                if (objExpr != null)
                {
                    if (!TryEmit(objExpr, paramExprs, il, ref closure, setup, flags | ParentFlags.InstanceAccess))
                        return false;

                    objIsValueType = objExpr.Type.IsValueType;
                    if (objIsValueType && objExpr.NodeType != ExpressionType.Parameter && !closure.LastEmitIsAddress)
                        EmitStoreAndLoadLocalVariableAddress(il, objExpr.Type);
                }

                if (methodParams.Length > 0)
                {
#if SUPPORTS_ARGUMENT_PROVIDER
                    var callArgs = (IArgumentProvider)callExpr;
#else
                    var callArgs = callExpr.Arguments;
#endif
                    for (var i = 0; i < methodParams.Length; i++)
                        if (!TryEmit(callArgs.GetArgument(i), paramExprs, il, ref closure, setup, flags, methodParams[i].ParameterType.IsByRef ? i : -1))
                            return false;
                }

                var ok = true;
                if (!objIsValueType)
                    ok = EmitMethodCallOrVirtualCall(il, method);
                else if (method.DeclaringType != typeof(Enum) &&
                    (!method.IsVirtual ||
                    method.DeclaringType == objExpr.Type ||
                    objExpr is ParameterExpression pe && pe.IsByRef))
                    ok = EmitMethodCall(il, method);
                else
                {
                    il.Demit(OpCodes.Constrained, objExpr.Type);
                    ok = EmitVirtualMethodCall(il, method);
                }

                if (parent.IgnoresResult() && method.ReturnType != typeof(void))
                    il.Demit(OpCodes.Pop);

                closure.LastEmitIsAddress = false;
                return ok;
            }

            public static bool TryEmitMemberGet(MemberExpression expr,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent, int byRefIndex = -1)
            {
                var objExpr = expr.Expression;
                if (expr.Member is PropertyInfo prop)
                {
                    if (objExpr != null)
                    {
                        var p = (parent | ParentFlags.InstanceCall)
                            & ~ParentFlags.MemberAccess // removing ParentFlags.MemberAccess here because we are calling the method instead of accessing the field
                            & ~ParentFlags.IgnoreResult & ~ParentFlags.DupIt;

                        if (!TryEmit(objExpr, paramExprs, il, ref closure, setup, p))
                            return false;

                        if ((parent & ParentFlags.DupIt) != 0) // just duplicate the whatever is emitted for object
                            il.Demit(OpCodes.Dup);
                        else
                            // Value type special treatment to load address of value instance in order to call a method.
                            // For the parameters, we will skip the address loading because the `LastEmitIsAddress == true` for `Ldarga`, 
                            // so the condition here will be skipped
                            if (!closure.LastEmitIsAddress && objExpr.Type.IsValueType)
                            EmitStoreAndLoadLocalVariableAddress(il, objExpr.Type);
                    }

                    closure.LastEmitIsAddress = false;
                    return EmitMethodCallOrVirtualCall(il, prop.GetMethod);
                }

                if (expr.Member is FieldInfo field)
                {
                    if (objExpr != null)
                    {
                        var p = (parent | ParentFlags.InstanceAccess | ParentFlags.MemberAccess)
                            & ~ParentFlags.IgnoreResult & ~ParentFlags.DupIt;

                        if (!TryEmit(objExpr, paramExprs, il, ref closure, setup, p))
                            return false;

                        // #248 indicates that expression is argument passed by ref to Call
                        var isByAddress = byRefIndex != -1;

                        // we are assigning to the field of ValueType so we need its address `val.Bar += 1`, #352
                        if ((parent & ParentFlags.AssignmentLeftValue) != 0 && objExpr.Type.IsValueType)
                            isByAddress = true;
                        else
                            // if the field is not used as an index, #302
                            // or if the field is not accessed from the just constructed object `new Widget().DodgyValue`, #333
                            if (((parent & ParentFlags.InstanceAccess) != 0 &
                                (parent & (ParentFlags.IndexAccess | ParentFlags.Ctor)) == 0) && field.FieldType.IsValueType)
                            isByAddress = true;

                        // we don't need to duplicate the instance if we are working with the field address to save to it directly,
                        // so the field address should be Dupped instead for loading and then storing by-ref for assignment (see below).
                        // (don't forget to Pop if the assignment should be skipped for nullable with `null` value)
                        if ((parent & ParentFlags.DupIt) != 0 &
                            (!isByAddress | (parent & ParentFlags.AssignmentLeftValue) == 0))
                            il.Demit(OpCodes.Dup);

                        closure.LastEmitIsAddress = isByAddress;
                        if (!isByAddress)
                        {
                            if (objExpr.Type.IsEnum)
                                EmitStoreAndLoadLocalVariableAddress(il, objExpr.Type);
                            il.Demit(OpCodes.Ldfld, field);
                        }
                        else
                        {
                            il.Demit(OpCodes.Ldflda, field);
                            if ((parent & ParentFlags.AssignmentLeftValue) != 0)
                                il.Demit(OpCodes.Dup);
                        }
                    }
                    else if (field.IsLiteral)
                    {
                        var fieldValue = field.GetValue(null);
                        if (fieldValue != null)
                            return TryEmitConstant(false, null, field.FieldType, fieldValue, il, ref closure);
                        il.Demit(OpCodes.Ldnull);
                    }
                    else
                    {
                        il.Demit(OpCodes.Ldsfld, field);
                    }
                    return true;
                }
                return false;
            }

            // ReSharper disable once FunctionComplexityOverflow
#if LIGHT_EXPRESSION
            private static bool TryEmitNestedLambda(LambdaExpression lambdaExpr, IParameterProvider outerParamExprs, ILGenerator il, ref ClosureInfo closure)
            {
                var outerParamExprCount = outerParamExprs.ParameterCount;
#else
            private static bool TryEmitNestedLambda(LambdaExpression lambdaExpr, IReadOnlyList<PE> outerParamExprs, ILGenerator il, ref ClosureInfo closure)
            {
                var outerParamExprCount = outerParamExprs.Count;
#endif
                // First, find in closed compiled lambdas the one corresponding to the current lambda expression.
                // Situation with not found lambda is not possible/exceptional,
                // it means that we somehow skipped the lambda expression while collecting closure info.
                var outerNestedLambdasCount = closure.NestedLambdas.Count;
                var outerNestedLambdas = closure.NestedLambdas.Items;
                var i = outerNestedLambdasCount - 1;
                while (i != -1 && !outerNestedLambdas[i].HasTheSameLambdaExpression(lambdaExpr)) --i;
                if (i == -1)
                    return false;

                ref var nestedLambdaInfo = ref outerNestedLambdas[i];
                EmitLoadLocalVariable(il, nestedLambdaInfo.LambdaVarIndex);

                // If lambda does not use any outer parameters to be set in closure, then we're done
                if (nestedLambdaInfo.NonPassedParameters.Count == 0)
                    return true;

                //-------------------------------------------------------------------
                // For the lambda with non-passed parameters (or variables) in closure
                // we are loading `NestedLambdaWithConstantsAndNestedLambdas` pair.

                var containsConstants = nestedLambdaInfo.Lambda is NestedLambdaWithConstantsAndNestedLambdas;
                if (containsConstants)
                {
                    il.Demit(OpCodes.Ldfld, NestedLambdaWithConstantsAndNestedLambdas.NestedLambdaField);
                    EmitLoadLocalVariable(il, nestedLambdaInfo.LambdaVarIndex); // load the variable for the second time
                    il.Demit(OpCodes.Ldfld, NestedLambdaWithConstantsAndNestedLambdas.ConstantsAndNestedLambdasField);
                }

                // - create `NonPassedParameters` array for the non-passed parameters and variables
                EmitLoadConstantInt(il, nestedLambdaInfo.NonPassedParameters.Count); // load the length of array
                il.Demit(OpCodes.Newarr, typeof(object));

                // we need to store the array in local variable, because we may assign to closed variable after the closure is passed to the lambda
                var nonPassedParamsVarIndex = il.GetNextLocalVarIndex(typeof(object[]));
                EmitStoreAndLoadLocalVariable(il, nonPassedParamsVarIndex);
                nestedLambdaInfo.NonPassedParamsVarIndex = (short)nonPassedParamsVarIndex;

                // - populate the `NonPassedParameters` array
                for (var nestedParamIndex = 0; nestedParamIndex < nestedLambdaInfo.NonPassedParameters.Count; ++nestedParamIndex)
                {
                    // Duplicate nested array on stack to store the item, and load index to where to store
                    il.Demit(OpCodes.Dup);
                    EmitLoadConstantInt(il, nestedParamIndex);

                    var nestedParam = nestedLambdaInfo.NonPassedParameters.GetSurePresentItemRef(nestedParamIndex);
                    var outerParamIndex = outerParamExprCount - 1;
                    while (outerParamIndex != -1 && !ReferenceEquals(outerParamExprs.GetParameter(outerParamIndex), nestedParam))
                        --outerParamIndex;
                    if (outerParamIndex != -1) // load parameter from input outer params
                    {
                        // Add `+1` to index because the `0` index is for the closure argument
                        EmitLoadArg(il, outerParamIndex + 1);
                        il.TryEmitBoxOf(nestedParam.Type);
                    }
                    else // load parameter from outer closure or from the local variables
                    {
                        var outerLocalVarIndex = closure.GetDefinedLocalVarOrDefault(nestedParam);
                        if (outerLocalVarIndex != -1) // it's a local variable
                        {
                            EmitLoadLocalVariable(il, outerLocalVarIndex);
                            il.TryEmitBoxOf(nestedParam.Type);
                        }
                        else // it's a parameter from the outer closure
                        {
                            var outerNonPassedParamIndex = closure.NonPassedParameters.TryGetIndex(nestedParam, default(RefEq<ParameterExpression>));
                            if (outerNonPassedParamIndex == -1)
                                return false; // impossible, return error code 2 the same as in TryCollectInfo

                            // Load the parameter from outer closure `Items` array
                            il.Demit(OpCodes.Ldarg_0); // closure is always a first argument
                            il.Demit(OpCodes.Ldfld, ArrayClosureWithNonPassedParamsField);
                            EmitLoadConstantInt(il, outerNonPassedParamIndex);
                            il.Demit(OpCodes.Ldelem_Ref);
                        }
                    }

                    // Store the item into nested lambda array
                    il.Demit(OpCodes.Stelem_Ref);
                }

                // - emit the closure constructor call
                var closureCtor = containsConstants
                    ? ArrayClosureWithNonPassedParamsConstructor
                    : ArrayClosureWithNonPassedParamsConstructorWithoutConstants;
                il.Demit(OpCodes.Newobj, closureCtor);

                // - call `Curry` method with nested lambda and array closure to produce a closed lambda with the expected signature
                var lambdaTypeArgs = nestedLambdaInfo.GetLambdaType().GetGenericArguments();
                var nestedLambdaExpr = nestedLambdaInfo.LambdaExpression;
                var closureMethod = nestedLambdaExpr.ReturnType == typeof(void)
                    ? CurryClosureActions.Methods[lambdaTypeArgs.Length - 1].MakeGenericMethod(lambdaTypeArgs)
                    : CurryClosureFuncs.Methods[lambdaTypeArgs.Length - 2].MakeGenericMethod(lambdaTypeArgs);

                var ok = EmitMethodCall(il, closureMethod);

                // converting to the original possibly custom delegate type, see #308
                if (closureMethod.ReturnType != nestedLambdaExpr.Type)
                {
                    il.Demit(OpCodes.Ldftn, closureMethod.ReturnType.FindDelegateInvokeMethod());
                    il.Demit(OpCodes.Newobj, nestedLambdaExpr.Type.GetConstructors()[0]);
                }

                return ok;
            }

#if LIGHT_EXPRESSION
            private static bool TryEmitInvoke(InvocationExpression expr, IParameterProvider paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
            {
                var paramCount = paramExprs.ParameterCount;
#else
            private static bool TryEmitInvoke(InvocationExpression expr, IReadOnlyList<PE> paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
            {
                var paramCount = paramExprs.Count;
#endif
#if SUPPORTS_ARGUMENT_PROVIDER
                var argExprs = (IArgumentProvider)expr;
#else
                var argExprs = expr.Arguments;
#endif
                var argCount = argExprs.GetCount();
                var invokedExpr = expr.Expression;
                if ((setup & CompilerFlags.NoInvocationLambdaInlining) == 0 && invokedExpr is LambdaExpression lambdaExpr)
                {
                    parent |= ParentFlags.InlinedLambdaInvoke;

                    ref var inlinedExpr = ref closure.InlinedLambdaInvocationMap.GetOrAddValueRef(expr, out var found);
                    if (!found)
                        inlinedExpr = CreateInlinedLambdaInvocationExpression(argExprs, argCount, lambdaExpr);

                    if (!TryEmit(inlinedExpr, paramExprs, il, ref closure, setup, parent))
                        return false;

                    if ((parent & ParentFlags.IgnoreResult) == 0 && lambdaExpr.Body.Type != typeof(void))
                    {
                        // find if the variable with the result is exist in the label infos
                        ref var label = ref closure.Labels.GetLabelOrInvokeIndexByTarget(expr, out var labelFound);
                        if (labelFound)
                        {
                            var returnVariableIndexPlusOne = label.ReturnVariableIndexPlusOneAndIsDefined >>> 1;
                            if (returnVariableIndexPlusOne != 0)
                            {
                                il.DmarkLabel(label.ReturnLabel);
                                EmitLoadLocalVariable(il, returnVariableIndexPlusOne - 1);
                            }
                        }
                    }
                    return true;
                }

                if (!TryEmit(invokedExpr, paramExprs, il, ref closure, setup, parent & ~ParentFlags.IgnoreResult)) // removing the IgnoreResult temporary because we need "full" lambda emit and we will re-apply the IgnoreResult later at the end of the method
                    return false;

                //if (lambda is ConstantExpression lambdaConst) // todo: @perf opportunity to optimize
                //    delegateInvokeMethod = ((Delegate)lambdaConst.Value).GetMethodInfo();
                //else 
                var delegateInvokeMethod = invokedExpr.Type.FindDelegateInvokeMethod(); // todo: @perf bad thingy
                if (argCount != 0)
                {
                    var useResult = parent & ~ParentFlags.IgnoreResult & ~ParentFlags.InstanceAccess;
                    var args = delegateInvokeMethod.GetParameters(); // todo: @perf avoid this if possible
                    for (var i = 0; i < args.Length; ++i)
                    {
                        var argExpr = argExprs.GetArgument(i);
                        if (!TryEmit(argExpr, paramExprs, il, ref closure, setup, useResult, args[i].ParameterType.IsByRef ? i : -1))
                            return false;
                    }
                }

                EmitMethodCall(il, delegateInvokeMethod);
                if ((parent & ParentFlags.IgnoreResult) != 0 && delegateInvokeMethod.ReturnType != typeof(void))
                    il.Demit(OpCodes.Pop);

                return true;
            }

#if LIGHT_EXPRESSION
            private static bool TryEmitSwitch(SwitchExpression expr, IParameterProvider paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#else
            private static bool TryEmitSwitch(SwitchExpression expr, IReadOnlyList<PE> paramExprs, ILGenerator il, ref ClosureInfo closure,
                CompilerFlags setup, ParentFlags parent)
#endif
            {
                // todo: @perf #398 use switch statement for int comparison, e.g. if int difference is less or equal 3 -> use IL switch
                var switchValueExpr = expr.SwitchValue;
                var customEqualMethod = expr.Comparison;
                var cases = expr.Cases;
                if (cases.Count == 1)
                {
                    var cs0 = cases[0];
                    if (cs0.TestValues.Count == 1)
                    {
                        Expression testExpr = customEqualMethod == null
                            ? Equal(switchValueExpr, cs0.TestValues[0])
                            : Call(customEqualMethod, switchValueExpr, cs0.TestValues[0]);
                        return TryEmitConditional(testExpr, cs0.Body, expr.DefaultBody, paramExprs, il, ref closure, setup, parent);
                    }
                }

                var switchValueType = switchValueExpr.Type;
                var switchValueIsNullable = switchValueType.IsNullable();
                Type switchNullableUnderlyingValueType = null;
                MethodInfo switchNullableHasValueMethod = null;
                FieldInfo switchNullableUnsafeValueField = null;
                if (switchValueIsNullable)
                {
                    switchNullableUnderlyingValueType = Nullable.GetUnderlyingType(switchValueType);
                    switchNullableHasValueMethod = switchValueType.GetNullableHasValueGetterMethod();
                    switchNullableUnsafeValueField = switchValueType.GetNullableValueUnsafeAkaGetValueOrDefaultMethod();
                }

                var checkType = switchNullableUnderlyingValueType ?? switchValueType;
                var equalityMethod = customEqualMethod != null
                    ? customEqualMethod
                    : !checkType.IsPrimitive && !checkType.IsEnum
                        ? FindComparisonMethod(il, "op_Equality", switchValueType, switchValueType) ?? _objectEqualsMethod
                        : null;

                var operandParent = parent & ~ParentFlags.IgnoreResult & ~ParentFlags.InstanceAccess;
                var isEqualityMethodForUnderlyingNullable = false;
                int param0ByRefIndex = -1, param1ByRefIndex = -1;
                if (equalityMethod != null)
                {
                    operandParent |= ParentFlags.Call;
                    var paramInfos = equalityMethod.GetParameters();
                    Debug.Assert(paramInfos.Length == 2);
                    var paramType = paramInfos[0].ParameterType;
                    isEqualityMethodForUnderlyingNullable = paramType == switchNullableUnderlyingValueType;
                    if (paramType.IsByRef)
                        param0ByRefIndex = 0;
                    if (paramInfos[1].ParameterType.IsByRef)
                        param1ByRefIndex = 1;
                }

                // Emit the switch value once and store it in the local variable for comparison in cases below
                if (!TryEmit(switchValueExpr, paramExprs, il, ref closure, setup, operandParent, param0ByRefIndex))
                    return false;

                var switchValueVar = EmitStoreLocalVariable(il, switchValueType);

                var switchEndLabel = il.DefineLabel();
                var labels = new Label[cases.Count];

                for (var caseIndex = 0; caseIndex < cases.Count; ++caseIndex)
                {
                    var cs = cases[caseIndex];
                    var caseBodyLabel = il.DefineLabel();
                    labels[caseIndex] = caseBodyLabel;

                    foreach (var caseTestValue in cs.TestValues)
                    {
                        if (!switchValueIsNullable)
                        {
                            EmitLoadLocalVariable(il, switchValueVar);
                            if (!TryEmit(caseTestValue, paramExprs, il, ref closure, setup, operandParent, param1ByRefIndex))
                                return false;
                            if (equalityMethod == null)
                            {
                                il.Demit(OpCodes.Beq, caseBodyLabel);
                                continue;
                            }

                            if (!EmitMethodCall(il, equalityMethod))
                                return false;
                            il.Demit(OpCodes.Brtrue, caseBodyLabel);
                            continue;
                        }

                        if (equalityMethod != null & !isEqualityMethodForUnderlyingNullable)
                        {
                            EmitLoadLocalVariable(il, switchValueVar);
                            if (!TryEmit(caseTestValue, paramExprs, il, ref closure, setup, operandParent, param1ByRefIndex) ||
                                !EmitMethodCall(il, equalityMethod))
                                return false;
                            il.Demit(OpCodes.Brtrue, caseBodyLabel);
                            continue;
                        }

                        if (equalityMethod == null)
                        {
                            // short-circuit the comparison with the null, if the switch value has value == false the let's do a Brfalse
                            if (caseTestValue is ConstantExpression r && r.Value == null)
                            {
                                EmitLoadLocalVariableAddress(il, switchValueVar);
                                EmitMethodCall(il, switchNullableHasValueMethod);
                                il.Demit(OpCodes.Brfalse, caseBodyLabel);
                                continue;
                            }
                        }

                        // Compare the switch value with the case value via Ceq or comparison method and then compare the HasValue of both
                        EmitLoadLocalVariableAddress(il, switchValueVar);
                        il.Demit(OpCodes.Ldfld, switchNullableUnsafeValueField);
                        if (!TryEmit(caseTestValue, paramExprs, il, ref closure, setup, operandParent, param1ByRefIndex))
                            return false;
                        var caseValueVar = EmitStoreAndLoadLocalVariableAddress(il, switchValueType);
                        il.Demit(OpCodes.Ldfld, switchNullableUnsafeValueField);
                        if (equalityMethod == null)
                            il.Demit(OpCodes.Ceq);
                        else if (!EmitMethodCall(il, equalityMethod))
                            return false;

                        EmitLoadLocalVariableAddress(il, switchValueVar);
                        EmitMethodCall(il, switchNullableHasValueMethod);
                        EmitLoadLocalVariableAddress(il, caseValueVar);
                        EmitMethodCall(il, switchNullableHasValueMethod);
                        il.Demit(OpCodes.Ceq);

                        il.Demit(OpCodes.And); // both the Nullable values and HashValue results need to be true
                        il.Demit(OpCodes.Brtrue, caseBodyLabel);
                    }
                }

                if (expr.DefaultBody != null)
                {
                    if (!TryEmit(expr.DefaultBody, paramExprs, il, ref closure, setup, parent))
                        return false;
                    il.Demit(OpCodes.Br, switchEndLabel);
                }

                for (var caseIndex = 0; caseIndex < cases.Count; ++caseIndex)
                {
                    il.DmarkLabel(labels[caseIndex]);
                    var cs = cases[caseIndex];
                    if (!TryEmit(cs.Body, paramExprs, il, ref closure, setup, parent))
                        return false;

                    if (caseIndex != cases.Count - 1)
                        il.Demit(OpCodes.Br, switchEndLabel);
                }

                il.DmarkLabel(switchEndLabel);
                return true;
            }

            private static MethodInfo FindComparisonMethod(ILGenerator il, string methodName, Type leftOpType, Type rightOpType)
            {
                var methods = leftOpType.GetMethods();
                for (var i = 0; i < methods.Length; i++)
                {
                    var m = methods[i];
                    if (m.IsSpecialName && m.IsStatic && m.Name == methodName)
                    {
                        var ps = m.GetParameters();
                        if (ps.Length == 2 && ps[0].ParameterType == leftOpType && ps[1].ParameterType == rightOpType)
                            return m;
                    }
                }
                return null;
            }

            private static bool TryEmitComparison(
                Expression left, Expression right, Type exprType, ExpressionType nodeType,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
                var leftOpType = left.Type;
                var leftIsNullable = leftOpType.IsNullable();
                var rightOpType = right.Type;

                // if on member is `null` object then list its type to match other member
                var rightIsNull = IsExpressionContainsNullValue(right);
                if (rightIsNull & rightOpType == typeof(object))
                    rightOpType = leftOpType;

                var leftIsNull = IsExpressionContainsNullValue(left);
                if (leftIsNull & leftOpType == typeof(object))
                    leftOpType = rightOpType;

                var operandParent = parent & ~ParentFlags.IgnoreResult & ~ParentFlags.InstanceAccess;

                // short-circuit the comparison with null on the right
                var isEqualityOp = nodeType == ExpressionType.Equal | nodeType == ExpressionType.NotEqual;
                if (isEqualityOp)
                {
                    if (leftIsNullable & rightIsNull)
                    {
                        if (!TryEmit(left, paramExprs, il, ref closure, setup, operandParent))
                            return false;
                        EmitStoreAndLoadLocalVariableAddress(il, leftOpType);
                        EmitMethodCall(il, leftOpType.GetNullableHasValueGetterMethod());
                        if (nodeType == ExpressionType.Equal)
                            EmitEqualToZeroOrNull(il);
                        return il.EmitPopIfIgnoreResult(parent);
                    }

                    if (leftIsNull && rightOpType.IsNullable())
                    {
                        if (!TryEmit(right, paramExprs, il, ref closure, setup, operandParent))
                            return false;
                        EmitStoreAndLoadLocalVariableAddress(il, rightOpType);
                        EmitMethodCall(il, rightOpType.GetNullableHasValueGetterMethod());
                        if (nodeType == ExpressionType.Equal)
                            EmitEqualToZeroOrNull(il);
                        return il.EmitPopIfIgnoreResult(parent);
                    }
                }

                if (!TryEmit(left, paramExprs, il, ref closure, setup, operandParent))
                    return false;

                int lVarIndex = -1, rVarIndex = -1;
                if (leftIsNullable)
                {
                    lVarIndex = EmitStoreAndLoadLocalVariableAddress(il, leftOpType);
                    il.Demit(OpCodes.Ldfld, leftOpType.GetNullableValueUnsafeAkaGetValueOrDefaultMethod());
                    leftOpType = Nullable.GetUnderlyingType(leftOpType);
                }

                if (!TryEmit(right, paramExprs, il, ref closure, setup, operandParent))
                    return false;

                if (leftOpType != rightOpType && leftOpType.IsClass && rightOpType.IsClass &&
                    (leftOpType == typeof(object) | rightOpType == typeof(object)))
                {
                    if (!isEqualityOp)
                        return false;
                    il.Demit(OpCodes.Ceq); // todo: @question test it, why it is not _objectEqualsMethod 
                    if (nodeType == ExpressionType.NotEqual)
                        EmitEqualToZeroOrNull(il);
                    return il.EmitPopIfIgnoreResult(parent);
                }

                if (rightOpType.IsNullable())
                {
                    rVarIndex = EmitStoreAndLoadLocalVariableAddress(il, rightOpType);
                    il.Demit(OpCodes.Ldfld, rightOpType.GetNullableValueUnsafeAkaGetValueOrDefaultMethod());
                    rightOpType = Nullable.GetUnderlyingType(rightOpType);
                }

                if (!leftOpType.IsPrimitive && !leftOpType.IsEnum)
                {
                    var methodName
                        = nodeType == ExpressionType.Equal ? "op_Equality"
                        : nodeType == ExpressionType.NotEqual ? "op_Inequality"
                        : nodeType == ExpressionType.GreaterThan ? "op_GreaterThan"
                        : nodeType == ExpressionType.GreaterThanOrEqual ? "op_GreaterThanOrEqual"
                        : nodeType == ExpressionType.LessThan ? "op_LessThan"
                        : nodeType == ExpressionType.LessThanOrEqual ? "op_LessThanOrEqual"
                        : null;
                    if (methodName == null)
                        return false;
                    // todo: @bug? for now handling only the parameters of the same type
                    var method = FindComparisonMethod(il, methodName, leftOpType, rightOpType);
                    if (method != null)
                    {
                        var ok = EmitMethodCall(il, method);
                        if (leftIsNullable)
                            goto nullableCheck;
                        return ok;
                    }

                    if (!isEqualityOp)
                        return false; // todo: @unclear what is the alternative?

                    EmitMethodCall(il, _objectEqualsMethod);
                    if (nodeType == ExpressionType.NotEqual) // invert result for not equal
                        EmitEqualToZeroOrNull(il);

                    if (leftIsNullable)
                        goto nullableCheck;

                    return il.EmitPopIfIgnoreResult(parent);
                }

                // handle primitives comparison
                switch (nodeType)
                {
                    case ExpressionType.Equal:
                        il.Demit(OpCodes.Ceq);
                        break;
                    case ExpressionType.NotEqual:
                        il.Demit(OpCodes.Ceq);
                        EmitEqualToZeroOrNull(il);
                        break;
                    case ExpressionType.LessThan:
                        il.Demit(OpCodes.Clt);
                        break;
                    case ExpressionType.GreaterThan:
                        il.Demit(OpCodes.Cgt);
                        break;
                    case ExpressionType.GreaterThanOrEqual:
                        // simplifying by using the LessThen (Clt) and comparing with negative outcome (Ceq 0)
                        if (leftOpType.IsUnsigned() && rightOpType.IsUnsigned())
                            il.Demit(OpCodes.Clt_Un);
                        else
                            il.Demit(OpCodes.Clt);
                        EmitEqualToZeroOrNull(il);
                        break;
                    case ExpressionType.LessThanOrEqual:
                        // simplifying by using the GreaterThen (Cgt) and comparing with negative outcome (Ceq 0)
                        if (leftOpType.IsUnsigned() && rightOpType.IsUnsigned())
                            il.Demit(OpCodes.Cgt_Un);
                        else
                            il.Demit(OpCodes.Cgt);
                        EmitEqualToZeroOrNull(il);
                        break;

                    default:
                        return false;
                }

            nullableCheck:
                if (leftIsNullable)
                {
                    var leftNullableHasValueGetterMethod = left.Type.GetNullableHasValueGetterMethod();

                    EmitLoadLocalVariableAddress(il, lVarIndex);
                    EmitMethodCall(il, leftNullableHasValueGetterMethod);

                    var isLiftedToNull = exprType == typeof(bool?);
                    var leftHasValueVar = -1;
                    if (isLiftedToNull)
                        EmitStoreAndLoadLocalVariable(il, leftHasValueVar = il.GetNextLocalVarIndex(typeof(bool)));

                    // ReSharper disable once AssignNullToNotNullAttribute
                    EmitLoadLocalVariableAddress(il, rVarIndex);
                    EmitMethodCall(il, leftNullableHasValueGetterMethod);

                    var rightHasValueVar = -1;
                    if (isLiftedToNull)
                        EmitStoreAndLoadLocalVariable(il, rightHasValueVar = il.GetNextLocalVarIndex(typeof(bool)));

                    switch (nodeType)
                    {
                        case ExpressionType.Equal:
                            il.Demit(OpCodes.Ceq); // compare both HasValue calls
                            il.Demit(OpCodes.And); // both results need to be true
                            break;

                        case ExpressionType.NotEqual:
                            il.Demit(OpCodes.Ceq);
                            EmitEqualToZeroOrNull(il);
                            il.Demit(OpCodes.Or);
                            break;

                        case ExpressionType.LessThan:
                        case ExpressionType.GreaterThan:
                        case ExpressionType.LessThanOrEqual:
                        case ExpressionType.GreaterThanOrEqual:
                            il.Demit(OpCodes.Ceq);
                            il.Demit(OpCodes.Ldc_I4_1);
                            il.Demit(OpCodes.Ceq);
                            il.Demit(OpCodes.And);
                            break;

                        default:
                            return false;
                    }

                    if (isLiftedToNull)
                    {
                        var resultLabel = il.DefineLabel();
                        var isNullLabel = il.DefineLabel();
                        EmitLoadLocalVariable(il, leftHasValueVar);
                        il.Demit(OpCodes.Brfalse, isNullLabel);
                        EmitLoadLocalVariable(il, rightHasValueVar);
                        il.Demit(OpCodes.Brtrue, resultLabel);
                        il.DmarkLabel(isNullLabel);
                        il.Demit(OpCodes.Pop);
                        il.Demit(OpCodes.Ldnull);
                        il.DmarkLabel(resultLabel);
                    }
                }

                return il.EmitPopIfIgnoreResult(parent);
            }

            private static bool TryEmitArithmetic(Expression left, Expression right, ExpressionType nodeType, Type exprType,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
                var flags = (parent & ~ParentFlags.IgnoreResult & ~ParentFlags.InstanceCall) | ParentFlags.Arithmetic;
                var leftNoValueLabel = default(Label);
                var leftType = left.Type;
                var leftIsNullable = leftType.IsNullable();
                if (leftIsNullable)
                {
                    leftNoValueLabel = il.DefineLabel();
                    if (!TryEmit(left, paramExprs, il, ref closure, setup, flags | ParentFlags.InstanceCall))
                        return false;

                    if (!closure.LastEmitIsAddress)
                        EmitStoreAndLoadLocalVariableAddress(il, leftType);

                    il.Demit(OpCodes.Dup);
                    EmitMethodCall(il, leftType.GetNullableHasValueGetterMethod());
                    il.Demit(OpCodes.Brfalse, leftNoValueLabel);
                    il.Demit(OpCodes.Ldfld, leftType.GetNullableValueUnsafeAkaGetValueOrDefaultMethod());
                }
                else if (!TryEmit(left, paramExprs, il, ref closure, setup, flags))
                    return false;

                var rightNoValueLabel = default(Label);
                var rightIsNullable = false;
                if (right == null) // indicates the increment/decrement operation
                {
                    EmitIncOrDec(il, nodeType == ExpressionType.Add);
                }
                else
                {
                    var rightType = right.Type;

                    // stores the left value for later to restore it after the complex right emit,
                    // it prevents the problems in cases of right being a block, try-catch, etc.
                    // see `Using_try_finally_as_arithmetic_operand_use_void_block_in_finally`
                    var leftVar = -1;
                    if (right.NodeType.IsBlockLikeOrConditional() || right.NodeType == ExpressionType.Invoke)
                        leftVar = EmitStoreLocalVariable(il, leftType);

                    rightIsNullable = rightType.IsNullable();
                    if (rightIsNullable)
                    {
                        rightNoValueLabel = il.DefineLabel();
                        if (!TryEmit(right, paramExprs, il, ref closure, setup, flags | ParentFlags.InstanceCall))
                            return false;

                        if (!closure.LastEmitIsAddress)
                            EmitStoreAndLoadLocalVariableAddress(il, rightType);

                        il.Demit(OpCodes.Dup);
                        EmitMethodCall(il, rightType.GetNullableHasValueGetterMethod());
                        il.Demit(OpCodes.Brfalse, rightNoValueLabel);
                        il.Demit(OpCodes.Ldfld, rightType.GetNullableValueUnsafeAkaGetValueOrDefaultMethod());
                    }
                    else if (!TryEmit(right, paramExprs, il, ref closure, setup, flags))
                        return false;

                    if (leftVar != -1)
                    {
                        // restore the left and right in proper order for operation
                        var rightVar = EmitStoreLocalVariable(il, rightType);
                        EmitLoadLocalVariable(il, leftVar);
                        EmitLoadLocalVariable(il, rightVar);
                    }

                    if (!TryEmitArithmeticOperation(leftType, rightType, nodeType, exprType, il))
                        return false;
                }

                if (leftIsNullable | rightIsNullable) // todo: @clarify that the emitted code is correct
                {
                    var valueLabel = il.DefineLabel();
                    il.Demit(OpCodes.Br, valueLabel);

                    if (rightIsNullable)
                        il.DmarkLabel(rightNoValueLabel);
                    il.Demit(OpCodes.Pop);

                    if (leftIsNullable)
                        il.DmarkLabel(leftNoValueLabel);
                    il.Demit(OpCodes.Pop);

                    if (exprType.IsNullable())
                    {
                        EmitLoadLocalVariable(il, InitValueTypeVariable(il, exprType));
                        var endL = il.DefineLabel();
                        il.Demit(OpCodes.Br_S, endL);
                        il.DmarkLabel(valueLabel);
                        il.Demit(OpCodes.Newobj, exprType.GetNullableConstructor());
                        il.DmarkLabel(endL);
                    }
                    else
                    {
                        il.Demit(OpCodes.Ldc_I4_0);
                        il.DmarkLabel(valueLabel);
                    }
                }
                return true;
            }

            private static MethodInfo _stringStringConcatMethod, _stringObjectConcatMethod;
            private static MethodInfo GetStringConcatMethod(Type paraType)
            {
                var methods = typeof(string).GetMethods();
                for (var i = 0; i < methods.Length; i++)
                {
                    var m = methods[i];
                    if (m.IsStatic && m.Name == "Concat" &&
                        m.GetParameters().Length == 2 && m.GetParameters()[0].ParameterType == paraType)
                        return m;
                }
                return null;
            }

            private static MethodInfo FindStaticOperatorMethod(Type type, string methodName)
            {
                if (methodName == null)
                    return null;
                var methods = type.GetMethods();
                for (var i = 0; i < methods.Length; i++)
                {
                    var m = methods[i];
                    if (m.IsSpecialName && m.IsStatic && m.Name == methodName)
                        return m;
                }
                return null;
            }

            private static bool TryEmitArithmeticOperation(Type leftType, Type rightType, ExpressionType arithmeticNodeType, Type exprType, ILGenerator il)
            {
                if (!exprType.IsPrimitive)
                {
                    if (exprType.IsNullable())
                        exprType = Nullable.GetUnderlyingType(exprType);

                    if (!exprType.IsPrimitive)
                    {
                        var method = exprType != typeof(string)
                            ? FindStaticOperatorMethod(exprType, arithmeticNodeType.GetArithmeticBinaryOperatorMethodName())
                            : leftType != rightType || leftType != typeof(string)
                                ? _stringObjectConcatMethod ?? (_stringObjectConcatMethod = GetStringConcatMethod(typeof(object)))
                                : _stringStringConcatMethod ?? (_stringStringConcatMethod = GetStringConcatMethod(typeof(string)));

                        return method != null && EmitMethodCallOrVirtualCall(il, method);
                    }
                }

                var opCode = arithmeticNodeType switch
                {
                    ExpressionType.Add => OpCodes.Add,
                    ExpressionType.AddChecked => exprType.IsUnsigned() ? OpCodes.Add_Ovf_Un : OpCodes.Add_Ovf,
                    ExpressionType.Subtract => OpCodes.Sub,
                    ExpressionType.SubtractChecked => exprType.IsUnsigned() ? OpCodes.Sub_Ovf_Un : OpCodes.Sub_Ovf,
                    ExpressionType.Multiply => OpCodes.Mul,
                    ExpressionType.MultiplyChecked => exprType.IsUnsigned() ? OpCodes.Mul_Ovf_Un : OpCodes.Mul_Ovf,
                    ExpressionType.Divide => OpCodes.Div,
                    ExpressionType.Modulo => OpCodes.Rem,
                    ExpressionType.And => OpCodes.And,
                    ExpressionType.Or => OpCodes.Or,
                    ExpressionType.ExclusiveOr => OpCodes.Xor,
                    ExpressionType.LeftShift => OpCodes.Shl,
                    ExpressionType.RightShift => exprType.IsUnsigned() ? OpCodes.Shr_Un : OpCodes.Shr,
                    ExpressionType.Power => OpCodes.Call,
                    _ => throw new NotSupportedException("Unsupported arithmetic operation: " + arithmeticNodeType)
                };

                if (opCode.Equals(OpCodes.Call))
                    il.Demit(OpCodes.Call, typeof(Math).FindMethod("Pow"));
                else
                    il.Demit(opCode);
                return true;
            }

            private static bool TryEmitLogicalOperator(BinaryExpression expr, ExpressionType nodeType,
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
                if (!TryEmit(expr.Left, paramExprs, il, ref closure, setup, parent))
                    return false;

                var labelSkipRight = il.DefineLabel();
                il.Demit(nodeType == ExpressionType.AndAlso ? OpCodes.Brfalse : OpCodes.Brtrue, labelSkipRight);

                if (!TryEmit(expr.Right, paramExprs, il, ref closure, setup, parent))
                    return false;

                var labelDone = il.DefineLabel();
                il.Demit(OpCodes.Br, labelDone);

                il.DmarkLabel(labelSkipRight); // label the second branch
                il.Demit(nodeType == ExpressionType.AndAlso ? OpCodes.Ldc_I4_0 : OpCodes.Ldc_I4_1);
                il.DmarkLabel(labelDone);

                return true;
            }

            private static bool IsExpressionContainsNullValue(Expression expr) =>
                expr is DefaultExpression ld && (ld.Type.IsClass || ld.Type.IsNullable()) ||
                expr is ConstantExpression lc && lc.Value == null;

            private static bool TryEmitConditional(
                Expression testExpr, Expression ifTrueExpr, Expression ifFalseExpr,
                // Type type, // todo: @wip what about the type, what if it is a void?
#if LIGHT_EXPRESSION
                IParameterProvider paramExprs,
#else
                IReadOnlyList<PE> paramExprs,
#endif
                ILGenerator il, ref ClosureInfo closure, CompilerFlags setup, ParentFlags parent)
            {
                testExpr = TryReduceCondition(testExpr);
                var testNodeType = testExpr.NodeType;

                // Detect a simplistic case when we can use `Brtrue` or `Brfalse`.
                // We are checking the negative result to go into the `IfFalse` branch,
                // because for `IfTrue` we don't need to jump and just need to proceed emitting the `IfTrue` expression
                //
                // The cases:
                // `x == true`  => `Brfalse`
                // `x != true`  => `Brtrue`
                // `x == false` => `Brtrue`
                // `x != false` => `Brfalse`
                // `x == null`  => `Brtrue`
                // `x != null`  => `Brfalse`
                // `x == 0`     => `Brtrue`
                // `x != 0`     => `Brfalse`

                var useBrFalseOrTrue = -1; // 0 - is comparison with Zero (0, null, false), 1 - is comparison with (true)
                Type nullOfValueType = null;
                if (testExpr is BinaryExpression tb &&
                    (testNodeType == ExpressionType.Equal | testNodeType == ExpressionType.NotEqual))
                {
                    var testLeftExpr = tb.Left;
                    var testRightExpr = tb.Right;

                    Expression oppositeTestExpr = null;
                    var sideConstExpr = testRightExpr as ConstantExpression ?? testLeftExpr as ConstantExpression;
                    if (sideConstExpr != null)
                    {
                        oppositeTestExpr = sideConstExpr == testLeftExpr ? testRightExpr : testLeftExpr;
                        var sideConstVal = sideConstExpr.Value;
                        if (sideConstVal == null) // todo: @perf we need to optimize for the Default as well
                        {
                            useBrFalseOrTrue = 0;
                            if (oppositeTestExpr.Type.IsNullable())
                                nullOfValueType = oppositeTestExpr.Type;
                        }
                        else if (sideConstVal is bool boolConst)
                            useBrFalseOrTrue = boolConst ? 1 : 0;
                        else if (sideConstVal is int intConst && intConst == 0)
                            useBrFalseOrTrue = 0; // Brtrue does not work for `1`, you need to use Beq, or similar
                        else if (sideConstVal is byte bytConst && bytConst == 0)
                            useBrFalseOrTrue = 0;
                    }
                    else
                    {
                        var sideDefaultExpr = testRightExpr as DefaultExpression ?? testLeftExpr as DefaultExpression;
                        if (sideDefaultExpr != null)
                        {
                            oppositeTestExpr = sideDefaultExpr == testLeftExpr ? testRightExpr : testLeftExpr;
                            var testSideType = sideDefaultExpr.Type;
                            if (testSideType.IsPrimitiveWithZeroDefault())
                                useBrFalseOrTrue = 0;
                            else if (testSideType.IsClass || testSideType.IsNullable())
                            {
                                useBrFalseOrTrue = 0;
                                if (oppositeTestExpr.Type.IsNullable())
                                    nullOfValueType = oppositeTestExpr.Type;
                            }
                        }
                    }

                    if (useBrFalseOrTrue != -1 &&
                        !TryEmit(oppositeTestExpr, paramExprs, il, ref closure, setup, parent & ~ParentFlags.IgnoreResult))
                        return false;
                }

                if (useBrFalseOrTrue == -1 &&
                    !TryEmit(testExpr, paramExprs, il, ref closure, setup, parent & ~ParentFlags.IgnoreResult))
                    return false;

                if (nullOfValueType != null)
                {
                    if (!closure.LastEmitIsAddress)
                        EmitStoreAndLoadLocalVariableAddress(il, nullOfValueType);
                    EmitMethodCall(il, nullOfValueType.GetNullableHasValueGetterMethod());
                }

                var labelIfFalse = il.DefineLabel();
                if ((testNodeType == ExpressionType.Equal & useBrFalseOrTrue == 0) ||
                    (testNodeType == ExpressionType.NotEqual & useBrFalseOrTrue == 1))
                {
                    // todo: @perf incomplete:
                    // try to recognize the pattern like in #301(300) `if (b == null) { goto return_label; }` 
                    // and instead of generating two branches e.g. Brtrue to else branch and Br or Ret to the end of the body,
                    // let's generate a single one e.g. Brfalse to return.
                    il.Demit(OpCodes.Brtrue, labelIfFalse);
                }
                else
                    il.Demit(OpCodes.Brfalse, labelIfFalse);

                if (!TryEmit(ifTrueExpr, paramExprs, il, ref closure, setup, parent))
                    return false;

                if (ifFalseExpr.NodeType == ExpressionType.Default && ifFalseExpr.Type == typeof(void))
                    il.DmarkLabel(labelIfFalse);
                else
                {
                    var labelDone = il.DefineLabel();
                    il.Demit(OpCodes.Br, labelDone);
                    il.DmarkLabel(labelIfFalse);
                    if (!TryEmit(ifFalseExpr, paramExprs, il, ref closure, setup, parent))
                        return false;
                    il.DmarkLabel(labelDone);
                }
                return true;
            }

            private static Expression TryReduceCondition(Expression testExpr)
            {
                // removing Not by turning Equal -> NotEqual, NotEqual -> Equal
                if (testExpr.NodeType == ExpressionType.Not)
                {
                    // simplify the not `==` -> `!=`, `!=` -> `==`
                    var op = TryReduceCondition(((UnaryExpression)testExpr).Operand);
                    if (op.NodeType == ExpressionType.Equal) // ensures that it is a BinaryExpression
                    {
                        var binOp = (BinaryExpression)op;
                        return NotEqual(binOp.Left, binOp.Right);
                    }
                    else if (op.NodeType == ExpressionType.NotEqual) // ensures that it is a BinaryExpression
                    {
                        var binOp = (BinaryExpression)op;
                        return Equal(binOp.Left, binOp.Right);
                    }
                }
                else if (testExpr is BinaryExpression b)
                {
                    if (b.NodeType == ExpressionType.OrElse || b.NodeType == ExpressionType.Or)
                    {
                        if (b.Left is ConstantExpression lc && lc.Value is bool lcb)
                            return lcb ? lc : TryReduceCondition(b.Right);

                        if (b.Right is ConstantExpression rc && rc.Value is bool rcb && !rcb)
                            return TryReduceCondition(b.Left);
                    }
                    else if (b.NodeType == ExpressionType.AndAlso || b.NodeType == ExpressionType.And)
                    {
                        if (b.Left is ConstantExpression lc && lc.Value is bool lcb)
                            return !lcb ? lc : TryReduceCondition(b.Right);

                        if (b.Right is ConstantExpression rc && rc.Value is bool rcb && rcb)
                            return TryReduceCondition(b.Left);
                    }
                }

                return testExpr;
            }

            [MethodImpl((MethodImplOptions)256)]
            public static void EmitEqualToZeroOrNull(ILGenerator il)
            {
                il.Demit(OpCodes.Ldc_I4_0); // OpCodes.Not does not work here because it is a bitwise operation
                il.Demit(OpCodes.Ceq);
            }

            /// Get the advantage of the optimized specialized EmitCall method
            [MethodImpl((MethodImplOptions)256)]
            public static bool EmitMethodCallOrVirtualCall(ILGenerator il, MethodInfo method)
            {
                il.Demit(method.IsVirtual ? OpCodes.Callvirt : OpCodes.Call, method);
                // todo: @feature EmitCall is specifically for the varags method and not for normal C# conventions methods,
                // for those you need to call Emit(OpCodes.Call|Callvirt, methodInfo).
                // So for now the varargs methods are not supported yet.
                return (method.CallingConvention & CallingConventions.VarArgs) == 0;
            }

            [MethodImpl((MethodImplOptions)256)]
            public static bool EmitVirtualMethodCall(ILGenerator il, MethodInfo method)
            {
                il.Demit(OpCodes.Callvirt, method);
                // todo: @feature EmitCall is specifically for the varags method and not for normal C# conventions methods,
                // for those you need to call Emit(OpCodes.Call|Callvirt, methodInfo).
                // So for now the varargs methods are not supported yet.
                return (method.CallingConvention & CallingConventions.VarArgs) == 0;
            }

            [MethodImpl((MethodImplOptions)256)]
            public static bool EmitMethodCall(ILGenerator il, MethodInfo method)
            {
                il.Demit(OpCodes.Call, method);
                // todo: @feature EmitCall is specifically for the varags method and not for normal C# conventions methods,
                // for those you need to call Emit(OpCodes.Call|Callvirt, methodInfo).
                // So for now the varargs methods are not supported yet.
                return (method.CallingConvention & CallingConventions.VarArgs) == 0;
            }

            /// Same as EmitMethodCall which checks the method for null first, and returns false if it is null. 
            [MethodImpl((MethodImplOptions)256)]
            public static bool EmitMethodCallCheckForNull(ILGenerator il, MethodInfo method) =>
                method != null && EmitMethodCall(il, method);

            /// Same as EmitMethodCallOrVirtualCall which checks the method for null first, and returns false if it is null. 
            [MethodImpl((MethodImplOptions)256)]
            public static bool EmitMethodCallOrVirtualCallCheckForNull(ILGenerator il, MethodInfo method) =>
                method != null && EmitMethodCallOrVirtualCall(il, method);

            /// Efficiently emit the int constant
            [MethodImpl((MethodImplOptions)256)]
            public static void EmitLoadConstantInt(ILGenerator il, int i)
            {
                switch (i)
                {
                    case -1: il.Demit(OpCodes.Ldc_I4_M1); break;
                    case 0: il.Demit(OpCodes.Ldc_I4_0); break;
                    case 1: il.Demit(OpCodes.Ldc_I4_1); break;
                    case 2: il.Demit(OpCodes.Ldc_I4_2); break;
                    case 3: il.Demit(OpCodes.Ldc_I4_3); break;
                    case 4: il.Demit(OpCodes.Ldc_I4_4); break;
                    case 5: il.Demit(OpCodes.Ldc_I4_5); break;
                    case 6: il.Demit(OpCodes.Ldc_I4_6); break;
                    case 7: il.Demit(OpCodes.Ldc_I4_7); break;
                    case 8: il.Demit(OpCodes.Ldc_I4_8); break;
                    default:
                        if (i > -129 && i < 128)
                            il.Demit(OpCodes.Ldc_I4_S, (sbyte)i);
                        else
                            il.Demit(OpCodes.Ldc_I4, i);
                        break;
                }
            }

            [MethodImpl((MethodImplOptions)256)]
            private static void EmitLoadLocalVariableAddress(ILGenerator il, int location)
            {
                if ((uint)location <= byte.MaxValue)
                    il.Demit(OpCodes.Ldloca_S, (byte)location);
                else
                    il.Demit(OpCodes.Ldloca, (short)location);
            }

            [MethodImpl((MethodImplOptions)256)]
            private static bool EmitLoadLocalVariable(ILGenerator il, int location)
            {
                if (location == 0)
                    il.Demit(OpCodes.Ldloc_0);
                else if (location == 1)
                    il.Demit(OpCodes.Ldloc_1);
                else if (location == 2)
                    il.Demit(OpCodes.Ldloc_2);
                else if (location == 3)
                    il.Demit(OpCodes.Ldloc_3);
                else if ((uint)location <= byte.MaxValue)
                    il.Demit(OpCodes.Ldloc_S, (byte)location);
                else
                    il.Demit(OpCodes.Ldloc, (short)location);
                return true;
            }

            [MethodImpl((MethodImplOptions)256)]
            private static bool EmitIncOrDec(ILGenerator il, bool isInc = false)
            {
                il.Demit(OpCodes.Ldc_I4_1);
                il.Demit(isInc ? OpCodes.Add : OpCodes.Sub);
                return true;
            }

            [MethodImpl((MethodImplOptions)256)]
            private static void EmitStoreLocalVariable(ILGenerator il, int location)
            {
                if (location == 0)
                    il.Demit(OpCodes.Stloc_0);
                else if (location == 1)
                    il.Demit(OpCodes.Stloc_1);
                else if (location == 2)
                    il.Demit(OpCodes.Stloc_2);
                else if (location == 3)
                    il.Demit(OpCodes.Stloc_3);
                else if ((uint)location <= byte.MaxValue)
                    il.Demit(OpCodes.Stloc_S, (byte)location);
                else
                    il.Demit(OpCodes.Stloc, (short)location);
            }

            [MethodImpl((MethodImplOptions)256)]
            private static int EmitStoreLocalVariable(ILGenerator il, Type type)
            {
                var location = il.GetNextLocalVarIndex(type);
                EmitStoreLocalVariable(il, location);
                return location;
            }

            [MethodImpl((MethodImplOptions)256)]
            private static void EmitStoreAndLoadLocalVariable(ILGenerator il, int location)
            {
                if (location == 0)
                {
                    il.Demit(OpCodes.Stloc_0);
                    il.Demit(OpCodes.Ldloc_0);
                }
                else if (location == 1)
                {
                    il.Demit(OpCodes.Stloc_1);
                    il.Demit(OpCodes.Ldloc_1);
                }
                else if (location == 2)
                {
                    il.Demit(OpCodes.Stloc_2);
                    il.Demit(OpCodes.Ldloc_2);
                }
                else if (location == 3)
                {
                    il.Demit(OpCodes.Stloc_3);
                    il.Demit(OpCodes.Ldloc_3);
                }
                else if ((uint)location <= byte.MaxValue)
                {
                    il.Demit(OpCodes.Stloc_S, (byte)location);
                    il.Demit(OpCodes.Ldloc_S, (byte)location);
                }
                else
                {
                    il.Demit(OpCodes.Stloc, (short)location);
                    il.Demit(OpCodes.Ldloc, (short)location);
                }
            }

            private static int EmitStoreAndLoadLocalVariable(ILGenerator il, Type t)
            {
                var location = il.GetNextLocalVarIndex(t);
                EmitStoreAndLoadLocalVariable(il, location);
                return location;
            }

            [MethodImpl((MethodImplOptions)256)]
            private static void EmitStoreAndLoadLocalVariableAddress(ILGenerator il, int location)
            {
                // #if DEBUG
                // var ilLengthField = typeof(ILGenerator).GetField("m_length", BindingFlags.Instance | BindingFlags.NonPublic);
                // var ilStreamField = typeof(ILGenerator).GetField("m_ILStream", BindingFlags.Instance | BindingFlags.NonPublic);
                // var ilLength = (int)ilLengthField.GetValue(il);
                // var ilStream = (byte[])ilStreamField.GetValue(il);

                // var ilMaxMidStackField    = typeof(ILGenerator).GetField("m_maxMidStack", BindingFlags.Instance | BindingFlags.NonPublic);
                // var ilMaxMidStackCurField = typeof(ILGenerator).GetField("m_maxMidStackCur", BindingFlags.Instance | BindingFlags.NonPublic);
                // var ilMaxMidStack    = (int)ilMaxMidStackField.GetValue(il);
                // var ilMaxMidStackCur = (int)ilMaxMidStackCurField.GetValue(il);
                // #endif
                if (location == 0)
                {
                    // todo: @perf
                    // the internal code for this is
                    //
                    // EnsureCapacity(3);
                    // InternalEmit(opcode);
                    // EnsureCapacity(4);
                    // InternalEmit(opcode);
                    // m_ILStream[m_length++] = (byte)arg;
                    //
                    // which translates to -> 
                    //
                    // if (m_length + 7 >= m_ILStream.Length)
                    //     IncreaseCapacity(7);
                    // // No stack change here cause 1st op decrease stack by 1 and second increase by 1
                    // m_ILStream[m_length++] = (byte)OpCodes.Stloc_0.Value;
                    // m_ILStream[m_length++] = (byte)OpCodes.Ldloca_S.Value;
                    // m_ILStream[m_length++] = (byte)0; // we may no need it 
                    //
                    il.Demit(OpCodes.Stloc_0);
                    il.Demit(OpCodes.Ldloca_S, (byte)0);
                }
                else if (location == 1)
                {
                    // todo: @perf we may introduce the EmitOne, EmitBatchNonStackModified(OpCode store, OpCode load, byte value), etc. method overloads 
                    // 
                    // if (ilLength + 7 < ilStream.Length)
                    // {
                    //     ilStream[ilLength++] = (byte)OpCodes.Stloc_1.Value;
                    //     if (ilMaxMidStackCur + 1 > ilMaxMidStack)
                    //         ilMaxMidStackField.SetValue(il, ilMaxMidStackCur + 1);
                    //     ilStream[ilLength++] = (byte)OpCodes.Ldloca_S.Value;
                    //     ilStream[ilLength++] = (byte)1;
                    //     ilLengthField.SetValue(il, ilLength);
                    // }
                    // else
                    // {
                    il.Demit(OpCodes.Stloc_1);
                    il.Demit(OpCodes.Ldloca_S, (byte)1);
                    // }
                }
                else if (location == 2)
                {
                    il.Demit(OpCodes.Stloc_2);
                    il.Demit(OpCodes.Ldloca_S, (byte)2);
                }
                else if (location == 3)
                {
                    il.Demit(OpCodes.Stloc_3);
                    il.Demit(OpCodes.Ldloca_S, (byte)3);
                }
                else if ((uint)location <= byte.MaxValue)
                {
                    il.Demit(OpCodes.Stloc_S, (byte)location);
                    il.Demit(OpCodes.Ldloca_S, (byte)location);
                }
                else
                {
                    il.Demit(OpCodes.Stloc, (short)location);
                    il.Demit(OpCodes.Ldloca, (short)location);
                }
            }

            private static int EmitStoreAndLoadLocalVariableAddress(ILGenerator il, Type type)
            {
                var location = il.GetNextLocalVarIndex(type);
                EmitStoreAndLoadLocalVariableAddress(il, location);
                return location;
            }

            [MethodImpl((MethodImplOptions)256)]
            private static void EmitLoadArg(ILGenerator il, int paramIndex)
            {
                if (paramIndex == 0)
                    il.Demit(OpCodes.Ldarg_0);
                else if (paramIndex == 1)
                    il.Demit(OpCodes.Ldarg_1);
                else if (paramIndex == 2)
                    il.Demit(OpCodes.Ldarg_2);
                else if (paramIndex == 3)
                    il.Demit(OpCodes.Ldarg_3);
                else if ((uint)paramIndex <= byte.MaxValue)
                    il.Demit(OpCodes.Ldarg_S, (byte)paramIndex);
                else
                    il.Demit(OpCodes.Ldarg, (short)paramIndex);
            }

            [MethodImpl((MethodImplOptions)256)]
            private static void EmitLoadArgAddress(ILGenerator il, int paramIndex)
            {
                if ((uint)paramIndex <= byte.MaxValue)
                    il.Demit(OpCodes.Ldarga_S, (byte)paramIndex);
                else
                    il.Demit(OpCodes.Ldarga, (short)paramIndex);
            }
        }
    }

    // Helpers targeting the performance. Extensions method names may be a bit funny (non standard), 
    // in order to prevent conflicts with YOUR helpers with standard names
    public static class Tools
    {
        public static Expression AsExpr(this object obj) => obj as Expression ?? Constant(obj);
        public static Expression[] AsExprs(this object[] obj)
        {
            var exprs = new Expression[obj.Length];
            for (var i = 0; i < obj.Length; i++)
                exprs[i] = obj[i].AsExpr();
            return exprs;
        }

        internal static bool IsUnsigned(this Type type) =>
            type == typeof(byte) ||
            type == typeof(ushort) ||
            type == typeof(uint) ||
            type == typeof(ulong);

        internal static bool IsPrimitiveWithZeroDefault(this Type type)
        {
            switch (Type.GetTypeCode(type))
            {
                case TypeCode.Boolean:
                case TypeCode.Char:
                case TypeCode.SByte:
                case TypeCode.Byte:
                case TypeCode.Int16:
                case TypeCode.UInt16:
                case TypeCode.Int32:
                case TypeCode.UInt32:
                case TypeCode.Int64:
                case TypeCode.UInt64:
                case TypeCode.Single:
                case TypeCode.Double:
                case TypeCode.Decimal:
                    return true;
                // case TypeCode.DateTime:
                // case TypeCode.String:
                default:
                    return false;
            }
        }

        [MethodImpl((MethodImplOptions)256)]
        internal static bool IsNullable(this Type type) =>
            (type.IsValueType & type.IsGenericType) && type.GetGenericTypeDefinition() == typeof(Nullable<>);

        [MethodImpl((MethodImplOptions)256)]
        internal static Type GetUnderlyingNullableTypeOrNull(this Type type) =>
            (type.IsValueType & type.IsGenericType) && type.GetGenericTypeDefinition() == typeof(Nullable<>) ? type.GetGenericArguments()[0] : null;

        [MethodImpl((MethodImplOptions)256)]
        internal static Type GetUnderlyingNullableTypeUnsafe(this Type type) => type.GetGenericArguments()[0];

        public static string GetArithmeticBinaryOperatorMethodName(this ExpressionType nodeType) =>
            nodeType switch
            {
                ExpressionType.Add => "op_Addition",
                ExpressionType.AddChecked => "op_Addition",
                ExpressionType.Subtract => "op_Subtraction",
                ExpressionType.SubtractChecked => "op_Subtraction",
                ExpressionType.Multiply => "op_Multiply",
                ExpressionType.MultiplyChecked => "op_Multiply",
                ExpressionType.Divide => "op_Division",
                ExpressionType.Modulo => "op_Modulus",
                _ => null
            };

        internal static bool IsAssignNodeType(this ExpressionType nodeType) => nodeType switch
        {
            ExpressionType.Assign => true,
            ExpressionType.PowerAssign => true,
            ExpressionType.AndAssign => true,
            ExpressionType.OrAssign => true,
            ExpressionType.AddAssign => true,
            ExpressionType.ExclusiveOrAssign => true,
            ExpressionType.AddAssignChecked => true,
            ExpressionType.SubtractAssign => true,
            ExpressionType.SubtractAssignChecked => true,
            ExpressionType.MultiplyAssign => true,
            ExpressionType.MultiplyAssignChecked => true,
            ExpressionType.DivideAssign => true,
            ExpressionType.LeftShiftAssign => true,
            ExpressionType.RightShiftAssign => true,
            ExpressionType.ModuloAssign => true,
            _ => false
        };

        internal static bool IsBlockLike(this ExpressionType nodeType) =>
            nodeType == ExpressionType.Try |
            nodeType == ExpressionType.Switch |
            nodeType == ExpressionType.Block |
            nodeType == ExpressionType.Loop;

        internal static bool IsReturnable(this ExpressionType nodeType) =>
            nodeType != ExpressionType.Goto &
            nodeType != ExpressionType.Label &
            nodeType != ExpressionType.Throw &&
            !IsBlockLike(nodeType);

        internal static bool IsBlockLikeOrConditional(this ExpressionType nodeType) =>
            nodeType == ExpressionType.Conditional | nodeType == ExpressionType.Coalesce || IsBlockLike(nodeType);

        internal static Expression StripConvertRecursively(this Expression expr) =>
            expr is UnaryExpression convert && convert.NodeType == ExpressionType.Convert
                ? StripConvertRecursively(convert.Operand)
                : expr;

        internal static bool IsConstantOrDefault(this Expression expr)
        {
            var nodeType = StripConvertRecursively(expr).NodeType;
            return nodeType == ExpressionType.Constant | nodeType == ExpressionType.Default;
        }

        internal static bool IsParamOrConstantOrDefault(this Expression expr)
        {
            var nodeType = StripConvertRecursively(expr).NodeType;
            return nodeType == ExpressionType.Parameter | nodeType == ExpressionType.Constant | nodeType == ExpressionType.Default;
        }

        internal static string GetCSharpName(this MemberInfo m)
        {
            var name = m.Name;
            if (m is FieldInfo fi && m.DeclaringType.IsValueType)
            {
                // btw, `fi.IsSpecialName` returns `false` :/
                if (name[0] == '<') // a backing field for the properties in struct, e.g. <Key>k__BackingField
                {
                    var end = name.IndexOf('>');
                    if (end > 1)
                        name = name.Substring(1, end - 1);
                }
            }
            return name;
        }

        [RequiresUnreferencedCode(Trimming.Message)]
        internal static MethodInfo FindMethod(this Type type, string methodName)
        {
            var methods = type.GetMethods();
            for (var i = 0; i < methods.Length; i++)
                if (methods[i].Name == methodName)
                    return methods[i];
            return type.BaseType?.FindMethod(methodName);
        }

        internal static MethodInfo DelegateTargetGetterMethod =
            typeof(Delegate).GetProperty(nameof(Delegate.Target)).GetMethod;

        [RequiresUnreferencedCode(Trimming.Message)]
        [MethodImpl((MethodImplOptions)256)]
        internal static MethodInfo FindDelegateInvokeMethod(this Type type) =>
            type.GetMethod("Invoke");

        [RequiresUnreferencedCode(Trimming.Message)]
        internal static class NullableReflected<T> where T : struct
        {
            public static readonly Type NullableType = typeof(T?);
            public static readonly MethodInfo ValueGetterMethod =
                NullableType.GetProperty("Value").GetMethod;
            public static readonly MethodInfo HasValueGetterMethod =
                NullableType.GetProperty("HasValue").GetMethod;
            public static readonly FieldInfo ValueField =
                NullableType.GetField("value", BindingFlags.Instance | BindingFlags.NonPublic);
            public static readonly ConstructorInfo Constructor =
                NullableType.GetConstructors()[0];
        }

        [RequiresUnreferencedCode(Trimming.Message)]
        [MethodImpl((MethodImplOptions)256)]
        internal static MethodInfo FindNullableValueGetterMethod(this Type type) =>
            type == typeof(int?)
                ? NullableReflected<int>.ValueGetterMethod
                : type.GetProperty("Value").GetMethod;

        [RequiresUnreferencedCode(Trimming.Message)]
        [MethodImpl((MethodImplOptions)256)]
        internal static MethodInfo GetNullableHasValueGetterMethod(this Type type) =>
            type == typeof(int?)
                ? NullableReflected<int>.HasValueGetterMethod
                : type.GetProperty("HasValue").GetMethod;

        [RequiresUnreferencedCode(Trimming.Message)]
        [MethodImpl((MethodImplOptions)256)]
        internal static FieldInfo GetNullableValueUnsafeAkaGetValueOrDefaultMethod(this Type type) =>
            type == typeof(int?)
                ? NullableReflected<int>.ValueField
                : type.GetField("value", BindingFlags.Instance | BindingFlags.NonPublic);

        [RequiresUnreferencedCode(Trimming.Message)]
        [MethodImpl((MethodImplOptions)256)]
        internal static ConstructorInfo GetNullableConstructor(this Type type) =>
            type == typeof(int?)
                ? NullableReflected<int>.Constructor
                : type.GetConstructors()[0];

        [RequiresUnreferencedCode(Trimming.Message)]
        internal static MethodInfo FindConvertOperator(this Type type, Type sourceType, Type targetType)
        {
            if (sourceType == typeof(object) | targetType == typeof(object))
                return null;

            // conversion operators should be declared as static and public 
            var methods = type.GetMethods(BindingFlags.Static | BindingFlags.Public);
            foreach (var m in methods)
                if (m.IsSpecialName && m.ReturnType == targetType)
                {
                    var n = m.Name;
                    if ((n == "op_Implicit" || n == "op_Explicit") &&
                        m.GetParameters()[0].ParameterType == sourceType)
                        return m;
                }

            return null;
        }

        [RequiresUnreferencedCode(Trimming.Message)]
        internal static ConstructorInfo FindSingleParamConstructor(this Type type, Type paramType)
        {
            var ctors = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
            for (var i = 0; i < ctors.Length; i++)
            {
                var ctor = ctors[i];
                var parameters = ctor.GetParameters();
                if (parameters.Length == 1 && parameters[0].ParameterType == paramType)
                    return ctor;
            }

            return null;
        }

        public static T[] AsArray<T>(this IEnumerable<T> xs)
        {
            if (xs is T[] array)
                return array;
            return xs == null ? null : xs.ToArray();
        }

        internal static IList<T> AsList<T>(this IEnumerable<T> source) =>
            source == null ? Empty<T>() : source as IList<T> ?? source.ToList();

        internal static bool TryGetIndexByReferenceEquals<T>(this IList<T> items, out int index, T item, int count)
        {
            for (var i = 0; (uint)i < count; ++i)
                if (ReferenceEquals(items[i], item))
                {
                    index = i;
                    return true;
                }
            index = -1;
            return false;
        }

        private static class EmptyArray<T>
        {
            public static readonly T[] Value = new T[0];
        }

        public static T[] Empty<T>() => EmptyArray<T>.Value;

        public static Type[] GetParamTypes(IReadOnlyList<PE> paramExprs)
        {
            if (paramExprs == null)
                return Empty<Type>();

            var count = paramExprs.Count;
            if (count == 0)
                return Empty<Type>();

            if (count == 1)
                return new[] { paramExprs[0].IsByRef ? paramExprs[0].Type.MakeByRefType() : paramExprs[0].Type };

            var paramTypes = new Type[count];
            for (var i = 0; i < paramTypes.Length; i++)
            {
                var parameterExpr = paramExprs[i];
                paramTypes[i] = parameterExpr.IsByRef ? parameterExpr.Type.MakeByRefType() : parameterExpr.Type;
            }

            return paramTypes;
        }

        public static Type GetFuncOrActionType(Type returnType) =>
            returnType == typeof(void) ? typeof(Action) : typeof(Func<>).MakeGenericType(returnType);

        public static Type GetFuncOrActionType(Type p, Type returnType) =>
            returnType == typeof(void) ? typeof(Action<>).MakeGenericType(p) : typeof(Func<,>).MakeGenericType(p, returnType);

        public static Type GetFuncOrActionType(Type p0, Type p1, Type returnType) =>
            returnType == typeof(void) ? typeof(Action<,>).MakeGenericType(p0, p1) : typeof(Func<,,>).MakeGenericType(p0, p1, returnType);

        public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type returnType) =>
            returnType == typeof(void) ? typeof(Action<,,>).MakeGenericType(p0, p1, p2) : typeof(Func<,,,>).MakeGenericType(p0, p1, p2, returnType);

        public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type returnType) =>
            returnType == typeof(void) ? typeof(Action<,,,>).MakeGenericType(p0, p1, p2, p3) : typeof(Func<,,,,>).MakeGenericType(p0, p1, p2, p3, returnType);

        public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type p4, Type returnType) =>
            returnType == typeof(void) ? typeof(Action<,,,,>).MakeGenericType(p0, p1, p2, p3, p4) : typeof(Func<,,,,,>).MakeGenericType(p0, p1, p2, p3, p4, returnType);

        public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type p4, Type p5, Type returnType) =>
            returnType == typeof(void) ? typeof(Action<,,,,,>).MakeGenericType(p0, p1, p2, p3, p4, p5) : typeof(Func<,,,,,,>).MakeGenericType(p0, p1, p2, p3, p4, p5, returnType);

        public static Type GetFuncOrActionType(Type[] paramTypes, Type returnType)
        {
            if (returnType == typeof(void))
            {
                if (paramTypes.Length == 0)
                    return typeof(Action);

                return GetAction(paramTypes.Length).MakeGenericType(paramTypes);
            }

            Type funcType = GetFunc(paramTypes.Length);
            Type[] typeParams = new Type[paramTypes.Length + 1]; // todo: @perf could we Rent the array?
            Array.Copy(paramTypes, typeParams, paramTypes.Length);
            typeParams[paramTypes.Length] = returnType;
            return funcType.MakeGenericType(typeParams);

            static Type GetAction(int length)
            {
                return length switch
                {
                    1 => typeof(Action<>),
                    2 => typeof(Action<,>),
                    3 => typeof(Action<,,>),
                    4 => typeof(Action<,,,>),
                    5 => typeof(Action<,,,,>),
                    6 => typeof(Action<,,,,,>),
                    7 => typeof(Action<,,,,,,>),
                    8 => typeof(Action<,,,,,,,>),
                    9 => typeof(Action<,,,,,,,,>),
                    10 => typeof(Action<,,,,,,,,,>),
                    11 => typeof(Action<,,,,,,,,,,>),
                    12 => typeof(Action<,,,,,,,,,,,>),
                    13 => typeof(Action<,,,,,,,,,,,,>),
                    14 => typeof(Action<,,,,,,,,,,,,,>),
                    15 => typeof(Action<,,,,,,,,,,,,,,>),
                    16 => typeof(Action<,,,,,,,,,,,,,,,>),
                    _ => throw new NotSupportedException($"Action with so many ({length}) parameters is not supported!")
                };
            }

            static Type GetFunc(int length)
            {
                return length switch
                {
                    0 => typeof(Func<>),
                    1 => typeof(Func<,>),
                    2 => typeof(Func<,,>),
                    3 => typeof(Func<,,,>),
                    4 => typeof(Func<,,,,>),
                    5 => typeof(Func<,,,,,>),
                    6 => typeof(Func<,,,,,,>),
                    7 => typeof(Func<,,,,,,,>),
                    8 => typeof(Func<,,,,,,,,>),
                    9 => typeof(Func<,,,,,,,,,>),
                    10 => typeof(Func<,,,,,,,,,,>),
                    11 => typeof(Func<,,,,,,,,,,,>),
                    12 => typeof(Func<,,,,,,,,,,,,>),
                    13 => typeof(Func<,,,,,,,,,,,,,>),
                    14 => typeof(Func<,,,,,,,,,,,,,,>),
                    15 => typeof(Func<,,,,,,,,,,,,,,,>),
                    16 => typeof(Func<,,,,,,,,,,,,,,,,>),
                    _ => throw new NotSupportedException($"Func with so many ({length}) parameters is not supported!")
                };
            }
        }

        public static T GetFirst<T>(this IEnumerable<T> source)
        {
            // This is pretty much Linq.FirstOrDefault except it does not need to check
            // if source is IPartition<T> (but should it?)

            if (source is IList<T> list)
                return list.Count == 0 ? default : list[0];
            var items = source.GetEnumerator();
            return items.MoveNext() ? items.Current : default;
        }

        public static T GetFirst<T>(this T[] source) => source.Length == 0 ? default : source[0];
    }

    [RequiresUnreferencedCode(Trimming.Message)]
    internal static class ILGeneratorTools
    {
#if DEMIT
        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode);
            Debug.WriteLine($"{opcode}  -- {emitterName}:{emitterLine}");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, Type value, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode, value);
            Debug.WriteLine($"{opcode} {value}  -- {emitterName}:{emitterLine}");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, FieldInfo value, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode, value);
            var t = value.DeclaringType;
            var fieldStr = value.FieldType.Name + " " + t.Name + "." + value.Name;
            Debug.WriteLine($"{opcode} {fieldStr}  -- {emitterName}:{emitterLine}");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, MethodInfo value, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode, value);
            Debug.WriteLine($"{opcode} {value}  -- {emitterName}:{emitterLine}");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, ConstructorInfo value, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode, value);
            var ctorStr = value.ToString().Replace(".", value.DeclaringType.Name + ".");
            Debug.WriteLine($"{opcode} {ctorStr}  -- {emitterName}:{emitterLine}");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, Label value,
            [CallerArgumentExpression("value")] string valueName = null, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode, value);
            Debug.WriteLine($"{opcode} {valueName ?? value.ToString()}  -- {emitterName}:{emitterLine}");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void DmarkLabel(this ILGenerator il, Label value,
            [CallerArgumentExpression("value")] string valueName = null, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.MarkLabel(value);
            Debug.WriteLine($"{valueName ?? value.ToString()}  -- {emitterName}:{emitterLine}: ");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, byte value, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode, value);
            Debug.WriteLine($"{opcode} {value}  -- {emitterName}:{emitterLine}");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, sbyte value, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode, value);
            Debug.WriteLine($"{opcode} {value}  -- {emitterName}:{emitterLine}");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, short value, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode, value);
            Debug.WriteLine($"{opcode} {value}  -- {emitterName}:{emitterLine}");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, int value, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode, value);
            Debug.WriteLine($"{opcode} {value}  -- {emitterName}:{emitterLine}");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, long value, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode, value);
            Debug.WriteLine($"{opcode} {value}  -- {emitterName}:{emitterLine}");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, float value, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode, value);
            Debug.WriteLine($"{opcode} {value}  -- {emitterName}:{emitterLine}");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, double value, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode, value);
            Debug.WriteLine($"{opcode} {value}  -- {emitterName}:{emitterLine}");
        }

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, string value, OpCode opcode, [CallerMemberName] string emitterName = null, [CallerLineNumber] int emitterLine = 0)
        {
            il.Emit(opcode, value);
            Debug.WriteLine($"{opcode} {value}  -- {emitterName}:{emitterLine}");
        }

#else // not DEMIT :)

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode) => il.Emit(opcode);

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, Type value) => il.Emit(opcode, value);

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, FieldInfo value) => il.Emit(opcode, value);

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, MethodInfo value) => il.Emit(opcode, value);

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, ConstructorInfo value) => il.Emit(opcode, value);

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, Label value) => il.Emit(opcode, value);

        [MethodImpl((MethodImplOptions)256)]
        public static void DmarkLabel(this ILGenerator il, Label value) => il.MarkLabel(value);

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, byte value) => il.Emit(opcode, value);

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, sbyte value) => il.Emit(opcode, value);

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, short value) => il.Emit(opcode, value);

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, int value) => il.Emit(opcode, value);

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, long value) => il.Emit(opcode, value);

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, float value) => il.Emit(opcode, value);

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, OpCode opcode, double value) => il.Emit(opcode, value);

        [MethodImpl((MethodImplOptions)256)]
        public static void Demit(this ILGenerator il, string value, OpCode opcode) => il.Emit(opcode, value);
#endif
    }

    /// <summary>Reflecting the internal methods to access the more performant for defining the local variable</summary>
    [RequiresUnreferencedCode(Trimming.Message)]
    public static class ILGeneratorHacks
    {
        // The original ILGenerator methods we are trying to hack without allocating the `LocalBuilder`
        /*
        public virtual LocalBuilder DeclareLocal(Type localType)
        {
            return this.DeclareLocal(localType, false);
        }

        public virtual LocalBuilder DeclareLocal(Type localType, bool pinned)
        {
            MethodBuilder methodBuilder = this.m_methodBuilder as MethodBuilder;
            if ((MethodInfo)methodBuilder == (MethodInfo)null)
                throw new NotSupportedException();
            if (methodBuilder.IsTypeCreated())
                throw new InvalidOperationException(SR.InvalidOperation_TypeHasBeenCreated);
            if (localType == (Type)null)
                throw new ArgumentNullException(nameof(localType));
            if (methodBuilder.m_bIsBaked)
                throw new InvalidOperationException(SR.InvalidOperation_MethodBaked);
            this.m_localSignature.AddArgument(localType, pinned);
            LocalBuilder localBuilder = new LocalBuilder(this.m_localCount, localType, (MethodInfo)methodBuilder, pinned);
            ++this.m_localCount;
            return localBuilder;
        }
        */

        private static readonly Func<ILGenerator, Type, int> _getNextLocalVarIndex;

        internal static int PostInc(ref int i) => i++;

        static ILGeneratorHacks()
        {
            // the default allocatee method
            _getNextLocalVarIndex = (i, t) => i.DeclareLocal(t).LocalIndex;

            // now let's try to acquire the more efficient less allocating method
            var ilGenTypeInfo = typeof(ILGenerator).GetTypeInfo();
            var localSignatureField = ilGenTypeInfo.GetDeclaredField("m_localSignature");
            if (localSignatureField == null)
                return;

            var localCountField = ilGenTypeInfo.GetDeclaredField("m_localCount");
            if (localCountField == null)
                return;

            // looking for the `SignatureHelper.AddArgument(Type argument, bool pinned)`
            MethodInfo addArgumentMethod = null;
            foreach (var m in typeof(SignatureHelper).GetTypeInfo().GetDeclaredMethods("AddArgument"))
            {
                var ps = m.GetParameters();
                if (ps.Length == 2 && ps[0].ParameterType == typeof(Type) && ps[1].ParameterType == typeof(bool))
                {
                    addArgumentMethod = m;
                    break;
                }
            }

            if (addArgumentMethod == null)
                return;

            // our own helper - always available
            var postIncMethod = typeof(ILGeneratorHacks).GetTypeInfo().GetDeclaredMethod(nameof(PostInc));

            var efficientMethod = new DynamicMethod(string.Empty,
                typeof(int), new[] { typeof(ExpressionCompiler.ArrayClosure), typeof(ILGenerator), typeof(Type) },
                typeof(ExpressionCompiler.ArrayClosure), skipVisibility: true);
            var il = efficientMethod.GetILGenerator();

            // emitting `il.m_localSignature.AddArgument(type);`
            il.Emit(OpCodes.Ldarg_1);  // load `il` argument (arg_0 is the empty closure object)
            il.Emit(OpCodes.Ldfld, localSignatureField);
            il.Emit(OpCodes.Ldarg_2);  // load `type` argument
            il.Emit(OpCodes.Ldc_I4_0); // load `pinned: false` argument
            il.Emit(OpCodes.Call, addArgumentMethod);

            // emitting `return PostInc(ref il.LocalCount);`
            il.Emit(OpCodes.Ldarg_1); // load `il` argument
            il.Emit(OpCodes.Ldflda, localCountField);
            il.Emit(OpCodes.Call, postIncMethod);

            il.Emit(OpCodes.Ret);

            _getNextLocalVarIndex = (Func<ILGenerator, Type, int>)efficientMethod.CreateDelegate(
                typeof(Func<ILGenerator, Type, int>), ExpressionCompiler.EmptyArrayClosure);

            // todo: @perf do batch Emit by manually calling `EnsureCapacity` once then `InternalEmit` multiple times
            // todo: @perf Replace the `Emit(opcode, int)` with the more specialized `Emit(opcode)`, `Emit(opcode, byte)` or `Emit(opcode, short)` 
            // avoiding internal check for Ldc_I4, Ldarg, Ldarga, Starg then call `PutInteger4` only if needed see https://source.dot.net/#System.Private.CoreLib/src/System/Reflection/Emit/ILGenerator.cs,690f350859394132
            // var ensureCapacityMethod = ilGenTypeInfo.GetDeclaredMethod("EnsureCapacity");
            // var internalEmitMethod   = ilGenTypeInfo.GetDeclaredMethod("InternalEmit");
            // var putInteger4Method    = ilGenTypeInfo.GetDeclaredMethod("PutInteger4");
        }


#if DEBUG_INFO_LOCAL_VARIABLE_USAGE
        public static readonly Dictionary<Type, int> LocalVarUsage = new Dictionary<Type, int>(); 
#endif
        // todo: @perf add the map of the used local variables that can be reused, e.g. we are getting the variable used in the local scope but then we may return them into POOL and reuse (many of int variable can be reuses, say for indexes)
        /// <summary>Efficiently returns the next variable index, hopefully without unnecessary allocations.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static int GetNextLocalVarIndex(this ILGenerator il, Type t)
        {
#if DEBUG_INFO_LOCAL_VARIABLE_USAGE
            if (!LocalVarUsage.ContainsKey(t)) // todo: @perf use FHashMap?
                LocalVarUsage[t] = 1;
            else 
                ++LocalVarUsage[t];
#endif
            return _getNextLocalVarIndex(il, t);
        }

        // todo: @perf add MultiOpCodes emit to save on the EnsureCapacity calls
        // todo: @perf create EmitMethod without additional GetParameters call
        /*
        // original code:
        public override void Emit(OpCode opcode, MethodInfo meth)
        {
            ArgumentNullException.ThrowIfNull(meth);
 
            int stackchange = 0;
            int token;
            DynamicMethod? dynMeth = meth as DynamicMethod;
            if (dynMeth == null)
            {
                RuntimeMethodInfo? rtMeth = meth as RuntimeMethodInfo;
                if (rtMeth == null)
                    throw new ArgumentException(SR.Argument_MustBeRuntimeMethodInfo, nameof(meth));
 
                RuntimeType declaringType = rtMeth.GetRuntimeType();
                if (declaringType != null && (declaringType.IsGenericType || declaringType.IsArray))
                    token = GetTokenFor(rtMeth, declaringType);
                else
                    token = GetTokenFor(rtMeth);
            }
            else
            {
                // rule out not allowed operations on DynamicMethods
                if (opcode.Equals(OpCodes.Ldtoken) || opcode.Equals(OpCodes.Ldftn) || opcode.Equals(OpCodes.Ldvirtftn))
                {
                    throw new ArgumentException(SR.Argument_InvalidOpCodeOnDynamicMethod);
                }
                token = GetTokenFor(dynMeth);
            }
 
            EnsureCapacity(7);
            InternalEmit(opcode);
 
            if (opcode.StackBehaviourPush == StackBehaviour.Varpush
                && meth.ReturnType != typeof(void))
            {
                stackchange++;
            }
            if (opcode.StackBehaviourPop == StackBehaviour.Varpop)
            {
                stackchange -= meth.GetParametersNoCopy().Length;
            }
            // Pop the "this" parameter if the method is non-static,
            //  and the instruction is not newobj/ldtoken/ldftn.
            if (!meth.IsStatic &&
                !(opcode.Equals(OpCodes.Newobj) || opcode.Equals(OpCodes.Ldtoken) || opcode.Equals(OpCodes.Ldftn)))
            {
                stackchange--;
            }
 
            UpdateStackSize(opcode, stackchange);
            PutInteger4(token);
        }

        // stripped down code for not generic method and not array method:
        public override void Emit(OpCode opcode, MethodInfo meth, int paramCount)
        {
            m_scope.m_tokens.Add(((RuntimeMethodInfo)meth).MethodHandle);
            var token = m_scope.m_tokens.Count - 1 | (int)MetadataTokenType.MethodDef; // MethodDef is 0x06000000

            // Guarantees an array capable of holding at least size elements.
            if (m_length + size >= m_ILStream.Length)
                IncreaseCapacity(7);

            m_ILStream[m_length++] = (byte)opcode.Value; 
            UpdateStackSize(opcode, 0);
 
            int stackchange = 0;
            if (meth.ReturnType != typeof(void))
                stackchange++;
            stackchange -= paramCount;
            if (!meth.IsStatic)
                stackchange--;
 
            UpdateStackSize(opcode, stackchange);

            BinaryPrimitives.WriteInt32LittleEndian(m_ILStream.AsSpan(m_length), token);
            m_length += 4;
        }
        */
    }

    [RequiresUnreferencedCode(Trimming.Message)]
    public static class ToExpressionPrinter
    {
        /// <summary>
        /// Prints the expression in its constructing syntax - 
        /// helpful to get the expression from the debug session and put into it the code for the test.
        /// </summary>
        public static string ToExpressionString(this Expression expr, CodePrinter.ObjectToCode notRecognizedToCode = null) =>
            expr.ToExpressionString(out var _, out var _, out var _, notRecognizedToCode: notRecognizedToCode);

        // todo: @api There should be a version returning StringBuilder the same as for ToCSharpString
        /// <summary>
        /// Prints the expression in its constructing syntax - 
        /// helpful to get the expression from the debug session and put into it the code for the test.
        /// In addition, returns the gathered expressions, parameters ad labels. 
        /// </summary>
        public static string ToExpressionString(this Expression expr,
            out List<ParameterExpression> paramsExprs, out List<Expression> uniqueExprs, out List<LabelTarget> lts,
            bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2, CodePrinter.ObjectToCode notRecognizedToCode = null)
        {
            var sb = new StringBuilder(1024);
            sb.Append("var expr = ");
            paramsExprs = new List<ParameterExpression>();
            uniqueExprs = new List<Expression>();
            lts = new List<LabelTarget>();
            sb = expr.CreateExpressionString(sb, paramsExprs, uniqueExprs, lts, 2, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(';');

            if (lts.Count > 0)
                sb.Insert(0, $"var l = new LabelTarget[{lts.Count}]; // the labels{NewLine}");
            if (uniqueExprs.Count > 0)
                sb.Insert(0, $"var e = new Expression[{uniqueExprs.Count}]; // the unique expressions{NewLine}");
            if (paramsExprs.Count > 0)
                sb.Insert(0, $"var p = new ParameterExpression[{paramsExprs.Count}]; // the parameter expressions{NewLine}");

            return sb.ToString();
        }

        // Searches first for the expression reference in the `uniqueExprs` and adds the reference to expression by index, 
        // otherwise delegates to `CreateExpressionCodeString`
        internal static StringBuilder ToExpressionString(this Expression expr, StringBuilder sb,
            List<ParameterExpression> paramsExprs, List<Expression> uniqueExprs, List<LabelTarget> lts,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode)
        {
            if (expr is ParameterExpression p)
                return p.ToExpressionString(sb, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);

            if (uniqueExprs.TryGetIndexByReferenceEquals(out var i, expr, uniqueExprs.Count))
                return sb.Append("e[").Append(i)
                    // output expression type and kind to help to understand what is it
                    .Append(" // ").Append(expr.NodeType.ToString()).Append(" of ")
                    .Append(expr.Type.ToCode(stripNamespace, printType))
                    .NewLineIdent(lineIdent).Append("]");

            uniqueExprs.Add(expr);
            sb.Append("e[").Append(uniqueExprs.Count - 1).Append("]=");
            return expr.CreateExpressionString(sb, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
        }

        internal static StringBuilder ToExpressionString(this ParameterExpression pe, StringBuilder sb,
            List<ParameterExpression> paramsExprs, List<Expression> uniqueExprs, List<LabelTarget> lts,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode)
        {
            if (paramsExprs.TryGetIndexByReferenceEquals(out var i, pe, paramsExprs.Count))
                return sb
                    .Append("p[").Append(i)
                    .Append(" // (")
                    .Append(!pe.Type.IsPrimitive && pe.Type.IsValueType ? "[struct] " : string.Empty)
                    .Append(pe.Type.ToCode(stripNamespace, printType))
                    .Append(' ').AppendName(pe.Name, pe.Type, pe).Append(')')
                    .NewLineIdent(lineIdent)
                    .Append(']');

            paramsExprs.Add(pe);
            sb.Append("p[").Append(paramsExprs.Count - 1).Append("]=");
            return pe.CreateExpressionString(sb, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
        }

        internal static StringBuilder ToExpressionString(this LabelTarget lt, StringBuilder sb, List<LabelTarget> labelTargets,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType)
        {
            if (labelTargets.TryGetIndexByReferenceEquals(out var i, lt, labelTargets.Count))
                return sb.Append("l[").Append(i)
                    .Append(" // (").AppendName(lt.Name, lt.Type, lt).Append(')')
                    .NewLineIdent(lineIdent).Append(']');

            labelTargets.Add(lt);
            sb.Append("l[").Append(labelTargets.Count - 1).Append("]=Label(");
            sb.AppendTypeOf(lt.Type, stripNamespace, printType);

            return (lt.Name != null ? sb.Append(", \"").Append(lt.Name).Append("\"") : sb).Append(")");
        }

        private static StringBuilder ToExpressionString(this IReadOnlyList<CatchBlock> bs, StringBuilder sb,
            List<ParameterExpression> paramsExprs, List<Expression> uniqueExprs, List<LabelTarget> lts,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode)
        {
            if (bs.Count == 0)
                return sb.Append("new CatchBlock[0]");
            for (var i = 0; i < bs.Count; i++)
                bs[i].ToExpressionString((i > 0 ? sb.Append(',') : sb).NewLineIdent(lineIdent),
                    paramsExprs, uniqueExprs, lts, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
            return sb;
        }

        private static StringBuilder ToExpressionString(this CatchBlock b, StringBuilder sb,
            List<ParameterExpression> paramsExprs, List<Expression> uniqueExprs, List<LabelTarget> lts,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode)
        {
            sb.Append("MakeCatchBlock(");
            sb.NewLineIdent(lineIdent).AppendTypeOf(b.Test, stripNamespace, printType).Append(',');
            sb.NewLineIdentExpr(b.Variable, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
            sb.NewLineIdentExpr(b.Body, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
            sb.NewLineIdentExpr(b.Filter, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
            return sb.Append(')');
        }

        private static StringBuilder ToExpressionString(this IReadOnlyList<SwitchCase> items, StringBuilder sb,
            List<ParameterExpression> paramsExprs, List<Expression> uniqueExprs, List<LabelTarget> lts,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode)
        {
            if (items.Count == 0)
                return sb.Append("new SwitchCase[0]");
            for (var i = 0; i < items.Count; i++)
                items[i].ToExpressionString((i > 0 ? sb.Append(',') : sb).NewLineIdent(lineIdent),
                    paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
            return sb;
        }

        private static StringBuilder ToExpressionString(this SwitchCase s, StringBuilder sb,
            List<ParameterExpression> paramsExprs, List<Expression> uniqueExprs, List<LabelTarget> lts,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode)
        {
            sb.Append("SwitchCase(");
            sb.NewLineIdentExpr(s.Body, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
            sb.NewLineIdentArgumentExprs(s.TestValues, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
            return sb.Append(')');
        }

        private static StringBuilder ToExpressionString(this MemberBinding mb, StringBuilder sb,
            List<ParameterExpression> paramsExprs, List<Expression> uniqueExprs, List<LabelTarget> lts,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode)
        {
            if (mb is MemberAssignment ma)
            {
                sb.Append("Bind(");
                sb.NewLineIdent(lineIdent).AppendMember(mb.Member, stripNamespace, printType).Append(", ");
                sb.NewLineIdentExpr(ma.Expression, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                return sb.Append(")");
            }

            if (mb is MemberMemberBinding mmb)
            {
                sb.NewLineIdent(lineIdent).Append(NotSupportedExpression).Append(nameof(MemberMemberBinding)).NewLineIdent(lineIdent);
                sb.Append("MemberBind(");
                sb.NewLineIdent(lineIdent).AppendMember(mb.Member, stripNamespace, printType);

                for (int i = 0; i < mmb.Bindings.Count; i++)
                    mmb.Bindings[i].ToExpressionString(sb.Append(", ").NewLineIdent(lineIdent),
                        paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                return sb.Append(")");
            }

            if (mb is MemberListBinding mlb)
            {
                sb.NewLineIdent(lineIdent).Append(NotSupportedExpression).Append(nameof(MemberListBinding)).NewLineIdent(lineIdent);
                sb.Append("ListBind(");
                sb.NewLineIdent(lineIdent).AppendMember(mb.Member, stripNamespace, printType);

                for (int i = 0; i < mlb.Initializers.Count; i++)
                    mlb.Initializers[i].ToExpressionString(sb.Append(", ").NewLineIdent(lineIdent),
                        paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);

                return sb.Append(")");
            }

            return sb;
        }

        private static StringBuilder ToExpressionString(this ElementInit ei, StringBuilder sb,
            List<ParameterExpression> paramsExprs, List<Expression> uniqueExprs, List<LabelTarget> lts,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode)
        {
            sb.Append("ElementInit(");
            sb.NewLineIdent(lineIdent).AppendMethod(ei.AddMethod, stripNamespace, printType).Append(", ");
            sb.NewLineIdentArgumentExprs(ei.Arguments, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
            return sb.Append(")");
        }

        private const string NotSupportedExpression = "// NOT_SUPPORTED_EXPRESSION: ";

        internal static StringBuilder CreateExpressionString(this Expression e, StringBuilder sb,
            List<ParameterExpression> paramsExprs, List<Expression> uniqueExprs, List<LabelTarget> lts,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2, CodePrinter.ObjectToCode notRecognizedToCode = null)
        {
            switch (e.NodeType)
            {
                case ExpressionType.Constant:
                    {
                        var x = (ConstantExpression)e;
                        sb.Append("Constant(");
                        if (x.Value == null)
                        {
                            sb.Append("null");
                            if (x.Type != typeof(object))
                                sb.Append(", ").AppendTypeOf(x.Type, stripNamespace, printType);
                        }
                        else if (x.Value is Type t)
                            sb.AppendTypeOf(t, stripNamespace, printType);
                        else
                        {
                            sb.Append(x.Value.ToCode(notRecognizedToCode ?? CodePrinter.DefaultNotRecognizedToCode, stripNamespace, printType));
                            if (x.Value.GetType() != x.Type)
                                sb.Append(", ").AppendTypeOf(x.Type, stripNamespace, printType);
                        }
                        return sb.Append(')');
                    }
                case ExpressionType.Parameter:
                    {
                        var x = (ParameterExpression)e;
                        sb.Append("Parameter(").AppendTypeOf(x.Type, stripNamespace, printType);
                        if (x.IsByRef)
                            sb.Append(".MakeByRefType()");
                        if (x.Name != null)
                            sb.Append(", \"").Append(x.Name).Append('"');
                        return sb.Append(')');
                    }
                case ExpressionType.New:
                    {
                        var x = (NewExpression)e;
                        var args = x.Arguments;

                        if (args.Count == 0 && e.Type.IsValueType)
                            return sb.Append("New(").AppendTypeOf(e.Type, stripNamespace, printType).Append(')');

                        sb.Append("New( // ").Append(args.Count).Append(" args");
                        var ctorIndex = x.Constructor.DeclaringType.GetTypeInfo().DeclaredConstructors.AsArray().GetFirstIndexByReferenceEquals(x.Constructor);
                        sb.NewLineIdent(lineIdent).AppendTypeOf(x.Type, stripNamespace, printType)
                            .Append(".GetTypeInfo().DeclaredConstructors.AsArray()[").Append(ctorIndex).Append("],");
                        sb.NewLineIdentArgumentExprs(args, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb.Append(')');
                    }
                case ExpressionType.Call:
                    {
                        var mc = (MethodCallExpression)e;
                        var diffTypes = mc.Type != mc.Method.ReturnType;
                        sb.Append(diffTypes ? "Convert(Call(" : "Call(");
                        sb.NewLineIdentExpr(mc.Object, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(", ");
                        sb.NewLineIdent(lineIdent).AppendMethod(mc.Method, stripNamespace, printType);
                        if (mc.Arguments.Count > 0)
                            sb.Append(',').NewLineIdentArgumentExprs(mc.Arguments, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return diffTypes ? sb.Append("), ").AppendTypeOf(e.Type, stripNamespace, printType).Append(')') : sb.Append(')');
                    }
                case ExpressionType.MemberAccess:
                    {
                        var x = (MemberExpression)e;
                        if (x.Member is PropertyInfo p)
                        {
                            sb.Append("Property(");
                            sb.NewLineIdentExpr(x.Expression, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                            sb.NewLineIdent(lineIdent).AppendProperty(p, stripNamespace, printType);
                        }
                        else
                        {
                            sb.Append("Field(");
                            sb.NewLineIdentExpr(x.Expression, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                            sb.NewLineIdent(lineIdent).AppendField((FieldInfo)x.Member, stripNamespace, printType);
                        }
                        return sb.Append(')');
                    }

                case ExpressionType.NewArrayBounds:
                case ExpressionType.NewArrayInit:
                    {
                        var x = (NewArrayExpression)e;
                        if (e.NodeType == ExpressionType.NewArrayInit)
                        {
                            // todo: @feature multi-dimensional array initializers are not supported yet, they also are not supported by the hoisted expression
                            if (e.Type.GetArrayRank() > 1)
                                sb.NewLineIdent(lineIdent).Append(NotSupportedExpression).Append(e.NodeType).NewLineIdent(lineIdent);
                            sb.Append("NewArrayInit(");
                        }
                        else
                        {
                            sb.Append("NewArrayBounds(");
                        }
                        sb.NewLineIdent(lineIdent).AppendTypeOf(x.Type.GetElementType(), stripNamespace, printType).Append(", ");
                        sb.NewLineIdentArgumentExprs(x.Expressions, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb.Append(')');
                    }
                case ExpressionType.MemberInit:
                    {
                        var x = (MemberInitExpression)e;
                        sb.Append("MemberInit((NewExpression)(");
                        sb.NewLineIdentExpr(x.NewExpression, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode)
                          .Append(')');
                        for (var i = 0; i < x.Bindings.Count; i++)
                            x.Bindings[i].ToExpressionString(sb.Append(", ").NewLineIdent(lineIdent),
                                paramsExprs, uniqueExprs, lts, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb.Append(')');
                    }
                case ExpressionType.Lambda:
                    {
                        var x = (LambdaExpression)e;
                        sb.Append("Lambda<").Append(x.Type.ToCode(stripNamespace, printType)).Append(">(");
                        sb.NewLineIdentExpr(x.Body, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                        sb.NewLineIdentArgumentExprs(x.Parameters, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb.Append(')');
                    }
                case ExpressionType.Invoke:
                    {
                        var x = (InvocationExpression)e;
                        sb.Append("Invoke(");
                        sb.NewLineIdentExpr(x.Expression, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                        sb.NewLineIdentArgumentExprs(x.Arguments, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb.Append(")");
                    }
                case ExpressionType.Conditional:
                    {
                        var x = (ConditionalExpression)e;
                        sb.Append("Condition(");
                        sb.NewLineIdentExpr(x.Test, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                        sb.NewLineIdentExpr(x.IfTrue, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                        sb.NewLineIdentExpr(x.IfFalse, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                        sb.NewLineIdent(lineIdent).AppendTypeOf(x.Type, stripNamespace, printType);
                        return sb.Append(')');
                    }
                case ExpressionType.Block:
                    {
                        var x = (BlockExpression)e;
                        sb.Append("Block(");
                        sb.NewLineIdent(lineIdent).AppendTypeOf(x.Type, stripNamespace, printType).Append(',');

                        if (x.Variables.Count == 0)
                            sb.NewLineIdent(lineIdent).Append("new ParameterExpression[0], ");
                        else
                        {
                            sb.NewLineIdent(lineIdent).Append("new[] {");
                            for (var i = 0; i < x.Variables.Count; i++)
                                x.Variables[i].ToExpressionString(
                                    (i > 0 ? sb.Append(',') : sb).NewLineIdent(lineIdent + identSpaces),
                                    paramsExprs, uniqueExprs, lts, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            sb.NewLineIdent(lineIdent).Append("},");
                        }

                        sb.NewLineIdentArgumentExprs(x.Expressions, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb.Append(')');
                    }
                case ExpressionType.Loop:
                    {
                        var x = (LoopExpression)e;
                        sb.Append("Loop(");
                        sb.NewLineIdentExpr(x.Body, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);

                        if (x.BreakLabel != null)
                            x.BreakLabel.ToExpressionString(sb.Append(',').NewLineIdent(lineIdent), lts, lineIdent, stripNamespace, printType);

                        if (x.ContinueLabel != null)
                            x.ContinueLabel.ToExpressionString(sb.Append(',').NewLineIdent(lineIdent), lts, lineIdent, stripNamespace, printType);

                        return sb.Append(')');
                    }
                case ExpressionType.Index:
                    {
                        var x = (IndexExpression)e;
                        sb.Append(x.Indexer != null ? "MakeIndex(" : "ArrayAccess(");
                        sb.NewLineIdentExpr(x.Object, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(", ");

                        if (x.Indexer != null)
                            sb.NewLineIdent(lineIdent).AppendProperty(x.Indexer, stripNamespace, printType).Append(", ");

                        sb.Append("new Expression[] {");
                        for (var i = 0; i < x.Arguments.Count; i++)
                            (i > 0 ? sb.Append(',') : sb)
                            .NewLineIdentExpr(x.Arguments[i], paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb.Append("})");
                    }
                case ExpressionType.Try:
                    {
                        var x = (TryExpression)e;
                        if (x.Finally == null)
                        {
                            sb.Append("TryCatch(");
                            sb.NewLineIdentExpr(x.Body, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                            x.Handlers.ToExpressionString(sb, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        }
                        else if (x.Handlers == null)
                        {
                            sb.Append("TryFinally(");
                            sb.NewLineIdentExpr(x.Body, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                            sb.NewLineIdentExpr(x.Finally, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        }
                        else
                        {
                            sb.Append("TryCatchFinally(");
                            sb.NewLineIdentExpr(x.Body, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                            sb.NewLineIdentExpr(x.Finally, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                            x.Handlers.ToExpressionString(sb, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        }

                        return sb.Append(')');
                    }
                case ExpressionType.Label:
                    {
                        var x = (LabelExpression)e;
                        sb.Append("Label(");
                        x.Target.ToExpressionString(sb, lts, lineIdent, stripNamespace, printType);
                        if (x.DefaultValue != null)
                            sb.Append(',').NewLineIdentExpr(x.DefaultValue, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb.Append(')');
                    }
                case ExpressionType.Goto:
                    {
                        var x = (GotoExpression)e;
                        sb.Append("MakeGoto(").AppendEnum(x.Kind, stripNamespace, printType).Append(',');

                        sb.NewLineIdent(lineIdent);
                        x.Target.ToExpressionString(sb, lts, lineIdent, stripNamespace, printType).Append(',');

                        sb.NewLineIdentExpr(x.Value, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                        sb.NewLineIdent(lineIdent).AppendTypeOf(x.Type, stripNamespace, printType);
                        return sb.Append(')');
                    }
                case ExpressionType.Switch:
                    {
                        var x = (SwitchExpression)e;
                        sb.Append("Switch(");
                        sb.NewLineIdentExpr(x.SwitchValue, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                        sb.NewLineIdentExpr(x.DefaultBody, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                        sb.NewLineIdent(lineIdent).AppendMethod(x.Comparison, stripNamespace, printType);
                        ToExpressionString(x.Cases, sb, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb.Append(')');
                    }
                case ExpressionType.Default:
                    {
                        return e.Type == typeof(void) ? sb.Append("Empty()")
                            : sb.Append("Default(").AppendTypeOf(e.Type, stripNamespace, printType).Append(')');
                    }
                case ExpressionType.TypeIs:
                case ExpressionType.TypeEqual:
                    {
                        var x = (TypeBinaryExpression)e;
                        sb.Append(e.NodeType == ExpressionType.TypeIs ? "TypeIs(" : "TypeEqual(");
                        sb.NewLineIdentExpr(x.Expression, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                        sb.NewLineIdent(lineIdent).AppendTypeOf(x.TypeOperand, stripNamespace, printType);
                        return sb.Append(')');
                    }
                case ExpressionType.Coalesce:
                    {
                        var x = (BinaryExpression)e;
                        sb.Append("Coalesce(");
                        sb.NewLineIdentExpr(x.Left, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                        sb.NewLineIdentExpr(x.Right, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        if (x.Conversion != null)
                            sb.Append(',').NewLineIdentExpr(x.Conversion, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb.Append(')');
                    }
                case ExpressionType.ListInit:
                    {
                        var x = (ListInitExpression)e;
                        sb.Append("ListInit((NewExpression)(");
                        sb.NewLineIdentExpr(x.NewExpression, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(')');
                        for (var i = 0; i < x.Initializers.Count; i++)
                            x.Initializers[i].ToExpressionString(sb.Append(", ").NewLineIdent(lineIdent),
                                paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb.Append(")");
                    }
                case ExpressionType.Extension:
                    {
                        var reduced = e.Reduce(); // proceed with the reduced expression
                        return reduced.CreateExpressionString(sb, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                    }
                case ExpressionType.Dynamic:
                case ExpressionType.RuntimeVariables:
                case ExpressionType.DebugInfo:
                case ExpressionType.Quote:
                    {
                        return sb.NewLineIdent(lineIdent).Append(NotSupportedExpression).Append(e.NodeType).NewLineIdent(lineIdent);
                    }
                default:
                    {
                        var name = Enum.GetName(typeof(ExpressionType), e.NodeType);
                        if (e is UnaryExpression u)
                        {
                            sb.Append(name).Append('(');
                            // todo: @feature maybe for big expression it makes sense to print the Type in comment here so you don't navigate to the closing parentheses to find it
                            sb.NewLineIdentExpr(u.Operand, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);

                            if (e.NodeType == ExpressionType.Convert ||
                                e.NodeType == ExpressionType.ConvertChecked ||
                                e.NodeType == ExpressionType.Unbox ||
                                e.NodeType == ExpressionType.Throw ||
                                e.NodeType == ExpressionType.TypeAs)
                                sb.Append(',').NewLineIdent(lineIdent).AppendTypeOf(e.Type, stripNamespace, printType);

                            if ((e.NodeType == ExpressionType.Convert || e.NodeType == ExpressionType.ConvertChecked)
                                && u.Method != null)
                                sb.Append(',').NewLineIdent(lineIdent).AppendMethod(u.Method, stripNamespace, printType);
                        }

                        if (e is BinaryExpression b)
                        {
                            sb.Append("MakeBinary(").Append(typeof(ExpressionType).Name).Append('.').Append(name).Append(',');
                            sb.NewLineIdentExpr(b.Left, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(',');
                            sb.NewLineIdentExpr(b.Right, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            if (b.IsLiftedToNull || b.Method != null)
                            {
                                sb.Append(',').NewLineIdent(lineIdent).Append("liftToNull: ").Append(b.IsLiftedToNull.ToCode());
                                sb.Append(',').NewLineIdent(lineIdent).AppendMethod(b.Method, stripNamespace, printType);
                                if (b.Conversion != null)
                                    sb.Append(',').NewLineIdentExpr(b.Conversion, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            }

                            if (b.Conversion != null)
                                sb.Append(',').NewLineIdentExpr(b.Conversion, paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        }

                        return sb.Append(')');
                    }
            }
        }
    }

    /// <summary>Converts the expression into the valid C# code representation</summary>
    [RequiresUnreferencedCode(Trimming.Message)]
    public static class ToCSharpPrinter
    {
        /// <summary>Tries hard to convert the expression into the valid C# code</summary>
        public static string ToCSharpString(this Expression expr) =>
            expr.ToCSharpString(new StringBuilder(1024), stripNamespace: true).Append(';').ToString();

        /// <summary>Tries hard to convert the expression into the valid C# code</summary>
        public static string ToCSharpString(this Expression expr, CodePrinter.ObjectToCode notRecognizedToCode) =>
            expr.ToCSharpString(new StringBuilder(1024), stripNamespace: true, notRecognizedToCode: notRecognizedToCode).Append(';').ToString();

        /// <summary>Tries hard to convert the expression into the valid C# code</summary>
        public static StringBuilder ToCSharpString(this Expression e, StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4, CodePrinter.ObjectToCode notRecognizedToCode = null) =>
            e.ToCSharpString(sb, EnclosedIn.ParensByDefault, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);

        /// <summary>Indicates the expression container</summary>
        public enum EnclosedIn
        {
            /// <summary>Prefers the parens by default</summary>
            ParensByDefault = 0,
            /// <summary>The test part of the If expression</summary>
            IfTest,
            /// <summary>The `if (test)` part</summary>
            Block,
            /// <summary>The lambda</summary>
            LambdaBody,
            /// <summary>Return expression</summary>
            Return,
            /// <summary>Instructs the client code to avoid parenthesis for the generated C# code, e.g. if we have as single argument in a method</summary>
            AvoidParens,
            /// <summary>The instance when calling the instance method or accessing the instance member</summary>
            Instance
        }

        private static StringBuilder NullConstantOrDefaultToCSharpString(Type exprType, StringBuilder sb, EnclosedIn encloseIn,
            bool stripNamespace, Func<Type, string, string> printType) =>
            exprType == typeof(object)
                ? sb.Append("null")
            : exprType.IsValueType && !exprType.IsNullable()
                ? sb.Append("default(").Append(exprType.ToCode(stripNamespace, printType)).Append(')')
                : sb.Append(encloseIn == EnclosedIn.Instance ? "((" : "(")
                    .Append(exprType.ToCode(stripNamespace, printType)).Append(")null")
                    .Append(encloseIn == EnclosedIn.Instance ? ")" : "");

        private static StringBuilder InsertTopFFuncDefinitionOnce(StringBuilder sb) =>
            sb[0] != 'T' || sb[2] != '_' || sb[3] != '_' || sb[4] != 'f' || sb[5] != '<'
                ? sb.Insert(0, "T __f<T>(System.Func<T> f) => f();\n")
                : sb;

        internal static StringBuilder ToCSharpString(this Expression e, StringBuilder sb, EnclosedIn enclosedIn,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4,
            CodePrinter.ObjectToCode notRecognizedToCode = null)
        {
#if LIGHT_EXPRESSION
            if (e.IsCustomToCSharpString)
                return e.CustomToCSharpString(sb, enclosedIn, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
#endif
            switch (e.NodeType)
            {
                case ExpressionType.Constant:
                    {
                        var x = (ConstantExpression)e;
                        if (x.Value == null)
                            return x.Type == null ? sb.Append("null") : NullConstantOrDefaultToCSharpString(x.Type, sb, enclosedIn, stripNamespace, printType);

                        if (x.Value is Type t)
                            return sb.AppendTypeOf(t, stripNamespace, printType);

                        if (x.Value.GetType() != x.Type) // add the Type cast
                            sb.Append('(').Append(x.Type.ToCode(stripNamespace, printType)).Append(')');

                        // value output may also add the cast for the primitive values
                        return sb.Append(x.Value.ToCode(notRecognizedToCode ?? CodePrinter.DefaultNotRecognizedToCode, stripNamespace, printType));
                    }
                case ExpressionType.Parameter:
                    {
                        return sb.AppendName(((ParameterExpression)e).Name, e.Type, e);
                    }
                case ExpressionType.New:
                    {
                        var x = (NewExpression)e;
                        sb.Append("new ").Append(e.Type.ToCode(stripNamespace, printType)).Append('(');
                        var args = x.Arguments;
                        if (args.Count == 1)
                            args[0].ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        else if (args.Count > 1)
                            for (var i = 0; i < args.Count; i++)
                            {
                                // @debug
                                // sb.Append($"[lineIdent:{lineIdent}]");
                                (i > 0 ? sb.Append(',') : sb).NewLineIdent(lineIdent);
                                args[i].ToCSharpString(sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            }
                        return sb.Append(')');
                    }
                case ExpressionType.Call:
                    {
                        var mc = (MethodCallExpression)e;

                        // output convert only if it is required, e.g. it may happen for custom expressions designed by users
                        var diffTypes = mc.Type != mc.Method.ReturnType;
                        if (diffTypes) sb.Append("((").Append(mc.Type.ToCode(stripNamespace, printType)).Append(')');

                        if (mc.Object != null)
                            mc.Object.ToCSharpString(sb, EnclosedIn.Instance, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        else // for the static method or the static extension method we need to qualify with the class
                            sb.Append(mc.Method.DeclaringType.ToCode(stripNamespace, printType));

                        var name = mc.Method.Name;
                        // check for the special methods, e.g. property access `get_` or `set_` and output them as properties
                        if (mc.Method.IsSpecialName && (name.StartsWith("get_") || name.StartsWith("set_")))
                            return sb.Append('.').Append(name.Substring(4));

                        sb.Append('.').Append(name);
                        if (mc.Method.IsGenericMethod)
                        {
                            sb.Append('<');
                            var typeArgs = mc.Method.GetGenericArguments();
                            for (var i = 0; i < typeArgs.Length; i++)
                                (i == 0 ? sb : sb.Append(", ")).Append(typeArgs[i].ToCode(stripNamespace, printType));
                            sb.Append('>');
                        }

                        sb.Append('(');
                        var pars = mc.Method.GetParameters();
                        var args = mc.Arguments;
                        if (args.Count == 1)
                        {
                            var p = pars[0];
                            var a = args[0];
                            if (p.ParameterType.IsByRef && !a.IsConstantOrDefault())
                                sb.Append(p.IsOut ? "out " : p.IsIn ? "in" : "ref ");
                            a.ToCSharpString(sb, EnclosedIn.AvoidParens, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        }
                        else if (args.Count > 1)
                        {
                            for (var i = 0; i < args.Count; i++)
                            {
                                (i == 0 ? sb : sb.Append(',')).NewLineIdent(lineIdent);
                                var p = pars[i];
                                var a = args[i];
                                if (p.ParameterType.IsByRef && !a.IsConstantOrDefault())
                                    sb.Append(p.IsOut ? "out " : p.IsIn ? "in " : "ref ");
                                a.ToCSharpString(sb, EnclosedIn.AvoidParens, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            }
                        }
                        // for the different return and expression types wrapping the whole expression including the cast with additional parentheses
                        return diffTypes ? sb.Append("))") : sb.Append(')');
                    }
                case ExpressionType.MemberAccess:
                    {
                        var x = (MemberExpression)e;
                        if (x.Expression != null)
                            x.Expression.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        else
                            sb.Append(x.Member.DeclaringType.ToCode(stripNamespace, printType));
                        return sb.Append('.').Append(x.Member.GetCSharpName());
                    }
                case ExpressionType.NewArrayBounds:
                case ExpressionType.NewArrayInit:
                    {
                        var x = (NewArrayExpression)e;
                        sb.Append("new ").Append(e.Type.GetElementType().ToCode(stripNamespace, printType));
                        sb.Append(e.NodeType == ExpressionType.NewArrayInit ? "[]{" : "[");

                        var exprs = x.Expressions;
                        if (exprs.Count == 1)
                            exprs[0].ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        else if (exprs.Count > 1)
                            for (var i = 0; i < exprs.Count; i++)
                                exprs[i].ToCSharpString(
                                    (i > 0 ? sb.Append(',') : sb).NewLineIdent(lineIdent),
                                    lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);

                        return sb.Append(e.NodeType == ExpressionType.NewArrayInit ? "}" : "]");
                    }
                case ExpressionType.MemberInit:
                    {
                        var x = (MemberInitExpression)e;
                        x.NewExpression.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        sb.NewLine(lineIdent, identSpaces).Append('{');
                        x.Bindings.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb.NewLine(lineIdent, identSpaces).Append('}');
                    }
                case ExpressionType.ListInit:
                    {
                        var x = (ListInitExpression)e;
                        x.NewExpression.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        sb.NewLine(lineIdent, identSpaces).Append('{');

                        var inits = x.Initializers;
                        for (var i = 0; i < inits.Count; ++i)
                        {
                            (i == 0 ? sb : sb.Append(", ")).NewLineIdent(lineIdent);
                            var elemInit = inits[i];
                            var args = elemInit.Arguments;
                            if (args.Count == 1)
                            {
                                args.GetArgument(0).ToCSharpString(sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            }
                            else
                            {
                                sb.Append('{');
                                for (var j = 0; j < args.Count; ++j)
                                    args.GetArgument(j).ToCSharpString(j == 0 ? sb : sb.Append(", "),
                                        lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
                                sb.Append('}');
                            }
                        }
                        return sb.NewLine(lineIdent, identSpaces).Append("};");
                    }
                case ExpressionType.Lambda:
                    {
                        var x = (LambdaExpression)e;
                        // The result should be something like this (taken from the #237)
                        //
                        // `(DeserializerDlg<Word>)((ref ReadOnlySequence<Byte> input, Word value, out Int64 bytesRead) => {...})`
                        // 
                        sb.Append('(').Append(e.Type.ToCode(stripNamespace, printType)).Append(")((");
                        var lambdaMethod = x.Type.FindDelegateInvokeMethod();
                        var count = x.Parameters.Count;
                        if (count > 0)
                        {
                            var pars = lambdaMethod.GetParameters();
                            for (var i = 0; i < count; i++)
                            {
                                if (i > 0)
                                    sb.Append(", ");
                                if (count > 1)
                                    sb.NewLineIdent(lineIdent + identSpaces);

                                var pe = x.Parameters[i];
                                var p = pars[i];
                                if (pe.IsByRef)
                                    sb.Append(p.IsOut ? "out " : p.IsIn ? "in " : "ref ");
                                sb.Append(pe.Type.ToCode(stripNamespace, printType)).Append(' ');
                                sb.AppendName(pe.Name, pe.Type, pe);
                            }
                        }

                        sb.Append(") => //").Append(lambdaMethod.ReturnType.ToCode(stripNamespace, printType));
                        var body = x.Body;
                        var bNodeType = body.NodeType;
                        var isReturnable = bNodeType.IsReturnable();
                        var ignoresResult = x.ReturnType == typeof(void);
                        if (isReturnable & !ignoresResult)
                            sb.NewLineIdentCs(body, EnclosedIn.LambdaBody, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        else
                        {
                            sb.NewLine(lineIdent, identSpaces).Append('{');
                            // Body handles `;` itself
                            if (body is BlockExpression bb)
                                bb.BlockToCSharpString(sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode,
                                    inTheLastBlock: true, containerIgnoresResult: ignoresResult);
                            else
                            {
                                sb.NewLineIdentCs(body, EnclosedIn.LambdaBody, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
                                if (isReturnable)
                                    sb.AppendSemicolonOnce();
                            }
                            sb.NewLine(lineIdent, identSpaces).Append('}');
                        }
                        return sb.Append(')');
                    }
                case ExpressionType.Invoke:
                    {
                        var x = (InvocationExpression)e;
                        // wrap the expression in the possibly excessive parentheses, because usually the expression is the delegate (except if delegate is parameter)
                        // which should be cast to the proper delegate type, e.g. `(Func<int>)(() => 1)`, so we need an additional `(<whole thing>)` to call `.Invoke`.
                        var encloseInParens = x.Expression.NodeType != ExpressionType.Parameter;
                        if (encloseInParens)
                            sb.Append('(');
                        x.Expression.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        if (encloseInParens)
                            sb.Append(')');

                        // Indicates the lambda invocation more explicitly with the new line, 
                        // it also helps to pair the identation of invacation expression, specifically where it starts. 
                        if (x.Expression.NodeType == ExpressionType.Lambda)
                            sb.NewLine(lineIdent, identSpaces);

                        sb.Append(".Invoke(");
                        for (var i = 0; i < x.Arguments.Count; i++)
                            (i > 0 ? sb.Append(',') : sb)
                            .NewLineIdentCs(x.Arguments[i], EnclosedIn.AvoidParens,
                                lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb.Append(")");
                    }
                case ExpressionType.Conditional:
                    {
                        var x = (ConditionalExpression)e;
                        if (e.Type == typeof(void)) // otherwise output as ternary expression
                        {
                            sb.Append("if (");
                            x.Test.ToCSharpString(sb, EnclosedIn.IfTest, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            sb.Append(')');
                            x.IfTrue.ToCSharpBlock(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);

                            if (x.IfFalse.NodeType != ExpressionType.Default || x.IfFalse.Type != typeof(void))
                                x.IfFalse.ToCSharpBlock(sb.NewLine(lineIdent, identSpaces).Append("else"),
                                    lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        }
                        else
                        {
                            x.Test.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            sb.Append(" ? ");
                            var doNewLine = !x.IfTrue.IsParamOrConstantOrDefault();
                            x.IfTrue.ToCSharpExpression(sb, EnclosedIn.AvoidParens, doNewLine, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            sb.Append(" : ");
                            doNewLine = !x.IfFalse.IsParamOrConstantOrDefault();
                            x.IfFalse.ToCSharpExpression(sb, EnclosedIn.AvoidParens, doNewLine, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        }
                        return sb;
                    }
                case ExpressionType.Block:
                    {
                        return ((BlockExpression)e).BlockToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                    }
                case ExpressionType.Loop:
                    {
                        var x = (LoopExpression)e;
                        sb.NewLine(lineIdent, identSpaces).Append("while (true)");
                        sb.NewLine(lineIdent, identSpaces).Append("{");

                        if (x.ContinueLabel != null)
                        {
                            sb.NewLine(lineIdent, identSpaces);
                            x.ContinueLabel.ToCSharpString(sb).Append(":;"); // todo: @improve the label is with the semicolon, because it will invalid code at the end of lambda without it
                        }

                        x.Body.ToCSharpString(sb.NewLineIdent(lineIdent), lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);

                        sb.NewLine(lineIdent, identSpaces).Append("}");

                        if (x.BreakLabel != null)
                        {
                            sb.NewLine(lineIdent, identSpaces);
                            x.BreakLabel.ToCSharpString(sb).Append(":;"); // todo: @improve the label is with the semicolon, because it will invalid code at the end of lambda without it
                        }
                        return sb;
                    }
                case ExpressionType.Index:
                    {
                        var x = (IndexExpression)e;
                        x.Object.ToCSharpString(sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);

                        var isStandardIndexer = x.Indexer == null || x.Indexer.Name == "Item";
                        if (isStandardIndexer)
                            sb.Append('[');
                        else
                            sb.Append('.').Append(x.Indexer.Name).Append('(');

                        for (var i = 0; i < x.Arguments.Count; i++)
                            x.Arguments[i].ToCSharpString(i > 0 ? sb.Append(", ") : sb, EnclosedIn.AvoidParens,
                                lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);

                        return sb.Append(isStandardIndexer ? ']' : ')');
                    }
                case ExpressionType.Try:
                    {
                        var x = (TryExpression)e;
                        var returnsValue = e.Type != typeof(void);
                        void PrintPart(Expression part)
                        {
                            if (part is BlockExpression pb)
                                pb.BlockToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode, inTheLastBlock: true);
                            else
                            {
                                // avoid additional new line between `try {\n\n while().. }`
                                if (!part.NodeType.IsBlockLike())
                                    sb.NewLineIdent(lineIdent);
                                var isReturnable = returnsValue && part.NodeType.IsReturnable();
                                if (isReturnable)
                                    sb.Append("return ");
                                part.ToCSharpString(sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode)
                                    .AppendSemicolonOnce();
                            }
                        }

                        sb.Append("try");
                        sb.NewLine(lineIdent, identSpaces).Append('{');
                        PrintPart(x.Body);
                        sb.NewLine(lineIdent, identSpaces).Append('}');

                        var handlers = x.Handlers;
                        if (handlers != null && handlers.Count > 0)
                        {
                            for (var i = 0; i < handlers.Count; i++)
                            {
                                var h = handlers[i];
                                sb.NewLine(lineIdent, identSpaces).Append("catch (");
                                var exTypeName = h.Test.ToCode(stripNamespace, printType);
                                sb.Append(exTypeName);

                                if (h.Variable != null)
                                    sb.Append(' ').AppendName(h.Variable.Name, h.Variable.Type, h.Variable);

                                sb.Append(')');
                                if (h.Filter != null)
                                {
                                    sb.Append("when (");
                                    sb.NewLineIdentCs(h.Filter, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                                    sb.NewLine(lineIdent, identSpaces).Append(')');
                                }
                                sb.NewLine(lineIdent, identSpaces).Append('{');
                                PrintPart(h.Body);
                                sb.NewLine(lineIdent, identSpaces).Append('}');
                            }
                        }

                        if (x.Finally != null)
                        {
                            sb.NewLine(lineIdent, identSpaces).Append("finally");
                            sb.NewLine(lineIdent, identSpaces).Append('{');
                            PrintPart(x.Finally);
                            sb.NewLine(lineIdent, identSpaces).Append('}');
                        }
                        return sb;
                    }
                case ExpressionType.Label:
                    {
                        var x = (LabelExpression)e;
                        sb.NewLineIdent(lineIdent);
                        x.Target.ToCSharpString(sb).Append(':');
                        return sb; // we don't output the default value and relying on the Goto Return `return` instead, otherwise we may change the logic of the code
                    }
                case ExpressionType.Goto:
                    {
                        var gt = (GotoExpression)e;
                        if (gt.Kind == GotoExpressionKind.Return || gt.Value != null)
                        {
                            var gtValue = gt.Value;
                            if (gtValue == null)
                                return sb.Append("return;");

                            var isReturnable = gtValue.NodeType.IsReturnable();
                            if (isReturnable)
                                sb.Append("return ");
                            gtValue.ToCSharpString(sb, lineIdent - identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            if (isReturnable)
                                sb.AppendSemicolonOnce();
                            return sb;
                        }
                        return gt.Target.ToCSharpString(sb.Append("goto "));
                    }
                case ExpressionType.Switch:
                    {
                        var x = (SwitchExpression)e;
                        sb.Append("switch (");
                        x.SwitchValue.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(')');
                        sb.NewLine(lineIdent, identSpaces).Append('{');

                        foreach (var cs in x.Cases)
                        {
                            foreach (var tv in cs.TestValues)
                            {
                                sb.NewLineIdent(lineIdent).Append("case ");
                                tv.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(':');
                            }

                            sb.NewLineIdent(lineIdent + identSpaces);
                            if (enclosedIn == EnclosedIn.LambdaBody)
                            {
                                if (cs.Body is BlockExpression bl)
                                    bl.BlockToCSharpString(sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode, inTheLastBlock: true);
                                else
                                    cs.Body.ToCSharpString(sb.Append("return "), EnclosedIn.Return, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).AppendSemicolonOnce();
                            }
                            else
                                cs.Body.ToCSharpString(sb, enclosedIn, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).AppendSemicolonOnce();
                        }

                        if (x.DefaultBody != null)
                        {
                            sb.NewLineIdent(lineIdent).Append("default:").NewLineIdent(lineIdent + identSpaces);
                            if (enclosedIn == EnclosedIn.LambdaBody)
                            {
                                if (x.DefaultBody is BlockExpression bl)
                                    bl.BlockToCSharpString(sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode, inTheLastBlock: true);
                                else
                                    x.DefaultBody.ToCSharpString(sb.Append("return "), EnclosedIn.Return, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).AppendSemicolonOnce();
                            }
                            else
                                x.DefaultBody.ToCSharpString(sb, enclosedIn, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).AppendSemicolonOnce();
                        }

                        return sb.NewLine(lineIdent, identSpaces).Append("}");
                    }
                case ExpressionType.Default:
                    return e.Type == typeof(void)
                            ? sb // `default(void)` does not make sense in the C#
                            : NullConstantOrDefaultToCSharpString(e.Type, sb, enclosedIn, stripNamespace, printType);

                case ExpressionType.TypeIs:
                case ExpressionType.TypeEqual:
                    {
                        var x = (TypeBinaryExpression)e;
                        sb.Append('(');
                        // Use C# `is T` even for TypeEqual if the two are equivalent (this syntax is nicer)
                        // IsSealed returns true for arrays, but arrays are cursed and don't behave like sealed classes (`new string[0] is object[]`, and even `new int[0] is uint[]`)
                        if (x.NodeType == ExpressionType.TypeIs || (x.TypeOperand.IsSealed && !x.TypeOperand.IsArray))
                        {
                            x.Expression.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            sb.Append(" is ").Append(x.TypeOperand.ToCode(stripNamespace, printType));
                        }
                        else
                        {
                            x.Expression.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            sb.Append(".GetType() == typeof(").Append(x.TypeOperand.ToCode(stripNamespace, printType)).Append(')');

                        }
                        return sb.Append(')');
                    }
                case ExpressionType.Coalesce:
                    {
                        var x = (BinaryExpression)e;
                        x.Left.ToCSharpExpression(sb, EnclosedIn.ParensByDefault, false, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        sb.Append(" ?? ");
                        x.Right.ToCSharpExpression(sb, EnclosedIn.ParensByDefault, false, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                        return sb;
                    }
                case ExpressionType.Extension:
                    {
                        var reduced = e.Reduce(); // proceed with the reduced expression
                        return reduced.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                    }
                case ExpressionType.Dynamic:
                case ExpressionType.RuntimeVariables:
                case ExpressionType.DebugInfo:
                case ExpressionType.Quote:
                    {
                        return sb.NewLineIdent(lineIdent).Append(NotSupportedExpression).Append(e.NodeType).NewLineIdent(lineIdent);
                    }
                default:
                    {
                        // By default enclose in the parentheses, and look at the specific cases for the individual types of expressions
                        var encloseInParens = enclosedIn == EnclosedIn.ParensByDefault;

                        var name = Enum.GetName(typeof(ExpressionType), e.NodeType);
                        if (e is UnaryExpression u)
                        {
                            var op = u.Operand;
                            switch (e.NodeType)
                            {
                                case ExpressionType.ArrayLength:
                                    return op.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(".Length");

                                case ExpressionType.Not: // either the bool not or the binary not
                                    return op.ToCSharpString(
                                        e.Type == typeof(bool) ? sb.Append("!(") : sb.Append("~("), enclosedIn,
                                        lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(')');

                                case ExpressionType.Convert:
                                case ExpressionType.ConvertChecked:
                                    if (e.Type == op.Type || e.Type == typeof(Enum) && op.Type.IsEnum)
                                        return op.ToCSharpExpression(sb, EnclosedIn.AvoidParens, false, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);

                                    sb = encloseInParens ? sb.Append("((") : sb.Append('(');
                                    sb.Append(e.Type.ToCode(stripNamespace, printType)).Append(')');
                                    sb = op.ToCSharpExpression(sb, EnclosedIn.AvoidParens, false, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                                    return encloseInParens ? sb.Append(')') : sb;

                                case ExpressionType.Decrement:
                                case ExpressionType.Increment:
                                    if (encloseInParens) sb.Append('(');
                                    sb = op.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                                    sb = e.NodeType == ExpressionType.Decrement ? sb.Append(" - 1") : sb.Append(" + 1");
                                    if (encloseInParens) sb.Append(')');
                                    return sb;

                                case ExpressionType.Negate:
                                case ExpressionType.NegateChecked:
                                    if (encloseInParens) sb.Append('(');
                                    op.ToCSharpString(sb.Append('-'), lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                                    if (encloseInParens) sb.Append(')');
                                    return sb;

                                case ExpressionType.PostIncrementAssign:
                                case ExpressionType.PreIncrementAssign:
                                case ExpressionType.PostDecrementAssign:
                                case ExpressionType.PreDecrementAssign:
                                    if (encloseInParens) sb.Append('(');
                                    sb = e.NodeType == ExpressionType.PreIncrementAssign ? sb.Append("++") : e.NodeType == ExpressionType.PreDecrementAssign ? sb.Append("--") : sb;
                                    op.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                                    sb = e.NodeType == ExpressionType.PostIncrementAssign ? sb.Append("++") : e.NodeType == ExpressionType.PostDecrementAssign ? sb.Append("--") : sb;
                                    if (encloseInParens) sb.Append(')');
                                    return sb;

                                case ExpressionType.IsTrue:
                                    return op.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append("==true");

                                case ExpressionType.IsFalse:
                                    return op.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append("==false");

                                case ExpressionType.TypeAs:
                                case ExpressionType.TypeIs:
                                    if (encloseInParens) sb.Append('(');
                                    op.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                                    sb = e.NodeType == ExpressionType.TypeAs ? sb.Append(" as ") : sb.Append(" is ");
                                    sb.Append(e.Type.ToCode(stripNamespace, printType));
                                    if (encloseInParens) sb.Append(')');
                                    return sb;

                                case ExpressionType.Throw:
                                    return op is null ? sb.Append("throw") :
                                        op.ToCSharpString(sb.Append("throw "), lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);

                                case ExpressionType.Unbox: // output it as the cast
                                    sb.Append("((").Append(e.Type.ToCode(stripNamespace, printType)).Append(')');
                                    return op.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(')');

                                default:
                                    return sb.Append(e.ToString()); // falling back ro ToString as a closest to C# code output 
                            }
                        }

                        if (e is BinaryExpression b)
                        {
                            var nodeType = e.NodeType;
                            if (nodeType == ExpressionType.ArrayIndex)
                            {
                                b.Left.ToCSharpString(sb.Append('('), lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(')');
                                return b.Right.ToCSharpString(sb.Append("["), lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append("]");
                            }

                            if (nodeType.IsAssignNodeType())
                            {
                                // todo: @perf handle the right part is condition with the blocks for If and/or Else, e.g. see #261 test `Serialize_the_nullable_struct_array` 
                                if (b.Right is BlockExpression rightBlock) // it is valid to assign the block and it is used to my surprise
                                {
                                    sb.Append("// { The block result will be assigned to `")
                                        .Append(b.Left.ToCSharpString(new StringBuilder(), lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode))
                                        .Append('`');
                                    rightBlock.BlockToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode, false, blockResultAssignment: b);
                                    return sb.NewLineIdent(lineIdent).Append("// } end of block assignment");
                                }

                                b.Left.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                                if (nodeType == ExpressionType.PowerAssign)
                                {
                                    sb.Append(" = System.Math.Pow(");
                                    b.Left.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(", ");
                                    return b.Right.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(")");
                                }

                                sb.Append(OperatorToCSharpString(nodeType));

                                if (b.Left is ParameterExpression leftParam && leftParam.IsByRef && !b.Right.IsConstantOrDefault())
                                    sb.Append("ref ");

                                return b.Right.ToCSharpExpression(sb, EnclosedIn.AvoidParens, false, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            }

                            // remove the parens from the simple comparisons and ops between params, variables and constants
                            if (b.Left.IsParamOrConstantOrDefault() && b.Right.IsParamOrConstantOrDefault())
                                encloseInParens = false;

                            sb = encloseInParens ? sb.Append('(') : sb;
                            b.Left.ToCSharpExpression(sb, EnclosedIn.ParensByDefault, false,
                                lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);

                            if (nodeType == ExpressionType.Equal)
                            {
                                if (b.Right is ConstantExpression r && r.Value is bool rb && rb)
                                    return sb;
                                sb.Append(" == ");
                            }
                            else if (nodeType == ExpressionType.NotEqual)
                            {
                                if (b.Right is ConstantExpression r && r.Value is bool rb)
                                    return rb ? sb.Append(" == false") : sb;
                                sb.Append(" != ");
                            }
                            else
                                sb.Append(OperatorToCSharpString(nodeType));

                            b.Right.ToCSharpExpression(sb, EnclosedIn.ParensByDefault, false,
                                lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                            return encloseInParens ? sb.Append(')') : sb;
                        }

                        return sb.Append(e.ToString()); // falling back ToString and hoping for the best 
                    }
            }
        }

        private static StringBuilder ToCSharpBlock(this Expression expr, StringBuilder sb,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode)
        {
            sb.NewLine(lineIdent, identSpaces).Append('{');
            if (expr is BlockExpression fb)
                fb.BlockToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode, inTheLastBlock: false);
            else
                sb.NewLineIdentCs(expr, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).AppendSemicolonOnce();
            return sb.NewLine(lineIdent, identSpaces).Append('}');
        }

        private static StringBuilder ToCSharpExpression(this Expression expr, StringBuilder sb, EnclosedIn enclosedIn, bool newLineExpr,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode)
        {
            if (!expr.NodeType.IsBlockLike())
                return newLineExpr
                    ? sb.NewLineIdentCs(expr, enclosedIn, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode)
                    : expr.ToCSharpString(sb, enclosedIn, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);

            InsertTopFFuncDefinitionOnce(sb);
            sb.NewLineIdent(lineIdent).Append("__f(() => {");
            if (expr is BlockExpression bl)
                bl.BlockToCSharpString(sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode, inTheLastBlock: true);
            else
                sb.NewLineIdentCs(expr, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
            return sb.NewLineIdent(lineIdent).Append("})");
        }

        internal static StringBuilder AppendSemicolonOnce(this StringBuilder sb) =>
            sb[sb.Length - 1] != ';' ? sb.Append(";") : sb;

        internal static StringBuilder AppendLineOnce(this StringBuilder sb)
        {
            for (var end = sb.Length - 1; end >= 0; --end)
            {
                if (sb[end] == '\n')
                    return sb; // return the unchanged sb when new line is already present
                if (sb[end] != ' ') // skip spaces if any
                    break;
            }
            return sb.Append(NewLine);
        }

        private const string NotSupportedExpression = "// NOT_SUPPORTED_EXPRESSION: ";

        internal static StringBuilder ToCSharpString(this LabelTarget target, StringBuilder sb) =>
            sb.AppendName(target.Name, target.Type, target);

        private static StringBuilder ToCSharpString(this IReadOnlyList<MemberBinding> bindings, StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4, CodePrinter.ObjectToCode notRecognizedToCode = null)
        {
            foreach (var b in bindings)
            {
                sb.NewLineIdent(lineIdent);
                sb.Append(b.Member.Name).Append(" = ");

                if (b is MemberAssignment ma)
                {
                    ma.Expression.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                }
                else if (b is MemberMemberBinding mmb)
                {
                    sb.Append("{");
                    ToCSharpString(mmb.Bindings, sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
                    sb.NewLineIdent(lineIdent + identSpaces).Append("}");
                }
                else if (b is MemberListBinding mlb)
                {
                    sb.Append("{");
                    foreach (var i in mlb.Initializers)
                    {
                        sb.NewLineIdent(lineIdent + identSpaces);
                        if (i.Arguments.Count > 1)
                            sb.Append("(");

                        var n = 0;
                        foreach (var a in i.Arguments)
                            a.ToCSharpString((++n > 1 ? sb.Append(", ") : sb), lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);

                        if (i.Arguments.Count > 1)
                            sb.Append(")");

                        sb.Append(",");
                    }
                    sb.NewLineIdent(lineIdent + identSpaces).Append("}");
                }
                sb.Append(",");
            }
            return sb;
        }

        private static StringBuilder BlockToCSharpString(this BlockExpression b, StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4,
            CodePrinter.ObjectToCode notRecognizedToCode = null, bool inTheLastBlock = false, BinaryExpression blockResultAssignment = null,
            bool containerIgnoresResult = false // in case of the container is lambda which is the Action/void delegate and ignores result, we don't need the `return` - it will be invalid c#
        )
        {
            var vars = b.Variables.AsList();
            var exprs = b.Expressions.AsList();

            // handling the special case, AutoMapper like using the tmp variable to reassign the property
            if (vars.Count == 1 & exprs.Count == 2 &&
                exprs[0] is BinaryExpression st0 && st0.NodeType == ExpressionType.Assign &&
                exprs[1] is BinaryExpression st1 && st1.NodeType == ExpressionType.Assign &&
                st0.Left == vars[0] && st1.Right == vars[0])
                return Assign(st1.Left, st0.Right).ToCSharpString(sb.NewLineIdent(lineIdent),
                    EnclosedIn.Block, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode)
                    .AppendSemicolonOnce();

            foreach (var v in vars)
            {
                sb.NewLineIdent(lineIdent);
                var vType = v.Type;
                var vTypeCode = vType.ToCode(stripNamespace, printType);
                var vIsByRef = v.IsByRef;
                var vNameSuffix = !vIsByRef ? "" : "__discard_init_by_ref";

                var vName = new StringBuilder().AppendName(v.Name, vTypeCode, v, vNameSuffix);
                sb.Append(vTypeCode).Append(' ').Append(vName).Append(vType.IsValueType && !vType.IsNullable() ? " = default;" : " = null;");

                if (vIsByRef)
                    sb.Append(" ref var ").AppendName(v.Name, vTypeCode, v).Append(" = ref ").Append(vName).Append(';');
            }

            // we don't inline a single expression case because it can always go crazy with assignment, e.g. `var a; a = 1 + (a = 2) + a * 2`
            for (var i = 0; i < exprs.Count - 1; i++)
            {
                var expr = exprs[i];

                // this is basically the return pattern (see #237) so we don't care for the rest of the expressions
                // Note (#300) the sentence above is slightly wrong because that may be a goto to this specific label, so we still need to print the label
                if (expr is GotoExpression gt && gt.Kind == GotoExpressionKind.Return &&
                    exprs[i + 1] is LabelExpression label && label.Target == gt.Target)
                {
                    sb.NewLineIdent(lineIdent);
                    if (gt.Value == null)
                        sb.Append("return;");
                    else
                        gt.Value.ToCSharpString(sb.Append("return "),
                            EnclosedIn.Return, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode)
                            .AppendSemicolonOnce();

                    sb.NewLineIdent(lineIdent);
                    label.Target.ToCSharpString(sb).Append(':');
                    if (label.DefaultValue == null)
                        return sb.AppendLine(); // no return because we may have other expressions after label
                    sb.NewLineIdent(lineIdent);
                    return label.DefaultValue.ToCSharpString(sb.Append("return "),
                        EnclosedIn.Return, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode)
                        .AppendSemicolonOnce();
                }

                if (expr is BlockExpression bl)
                {
                    // Unrolling the block on the same vertical line
                    bl.BlockToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode, inTheLastBlock: false);
                }
                else
                {
                    sb.NewLineIdent(lineIdent);

                    if (expr is LabelExpression) // keep the label on the same vertical line
                        expr.ToCSharpString(sb, EnclosedIn.Block, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                    else
                        expr.ToCSharpString(sb, EnclosedIn.Block, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);

                    // Preventing the `};` kind of situation and separating the conditional block with empty line
                    var nodeType = expr.NodeType;
                    if (nodeType.IsBlockLikeOrConditional())
                        sb.NewLineIdent(lineIdent);
                    else if (nodeType != ExpressionType.Label & nodeType != ExpressionType.Default)
                        sb.AppendSemicolonOnce();
                }
            }

            var lastExpr = exprs[exprs.Count - 1];
            if (lastExpr.NodeType == ExpressionType.Default && lastExpr.Type == typeof(void))
                return sb;

            if (lastExpr is BlockExpression lastBlock)
                return lastBlock.BlockToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode,
                    inTheLastBlock, // the last block is marked so if only it is itself in the last block
                    blockResultAssignment);

            // todo: @improve the label is already used by the Return GoTo we should skip it output here OR we need to replace the Return Goto `return` with `goto`  
            if (lastExpr is LabelExpression) // keep the last label on the same vertical line
            {
                lastExpr.ToCSharpString(sb, EnclosedIn.Block, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                if (inTheLastBlock)
                    sb.AppendSemicolonOnce(); // the last label forms the invalid C#, so we need at least ';' at the end
                return sb;
            }

            sb.NewLineIdent(lineIdent);
            var enclosedIn = EnclosedIn.Block;
            if (blockResultAssignment != null)
            {
                blockResultAssignment.Left.ToCSharpString(sb, enclosedIn, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                if (blockResultAssignment.NodeType != ExpressionType.PowerAssign)
                    sb.Append(OperatorToCSharpString(blockResultAssignment.NodeType));
                else
                {
                    sb.Append(" = System.Math.Pow(");
                    blockResultAssignment.Left.ToCSharpString(sb, enclosedIn, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode).Append(", ");
                }
            }
            else if (inTheLastBlock & !containerIgnoresResult &&
                b.Type != typeof(void) && lastExpr.Type != typeof(void))
            {
                // todo: @hack if the last expression is the Assignment BinaryExpression, 
                // it is very doubtful that it is supposed to be returned result.
                // but I need to find a better indicator later.
                if (!lastExpr.NodeType.IsAssignNodeType())
                {
                    enclosedIn = EnclosedIn.Return;
                    sb.Append("return ");
                }
            }

            if (lastExpr.NodeType.IsBlockLike() ||
                lastExpr is DefaultExpression d && d.Type == typeof(void))
            {
                lastExpr.ToCSharpString(sb, EnclosedIn.Block, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
            }
            else if (lastExpr.NodeType == ExpressionType.Assign && ((BinaryExpression)lastExpr).Right is BlockExpression)
            {
                lastExpr.ToCSharpString(sb, EnclosedIn.Block, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
                if (enclosedIn == EnclosedIn.Return)
                    sb.AppendSemicolonOnce();
            }
            else
            {
                lastExpr.ToCSharpString(sb, enclosedIn, lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode);
                sb = blockResultAssignment?.NodeType == ExpressionType.PowerAssign ? sb.Append(')') : sb;
                sb.AppendSemicolonOnce();
            }
            return sb;
        }

        private static string OperatorToCSharpString(ExpressionType nodeType) =>
            nodeType switch
            {
                ExpressionType.And => " & ",
                ExpressionType.AndAssign => " &= ",
                ExpressionType.AndAlso => " && ",
                ExpressionType.Or => " | ",
                ExpressionType.OrAssign => " |= ",
                ExpressionType.OrElse => " || ",
                ExpressionType.GreaterThan => " > ",
                ExpressionType.GreaterThanOrEqual => " >= ",
                ExpressionType.LessThan => " < ",
                ExpressionType.LessThanOrEqual => " <= ",
                ExpressionType.Equal => " == ",
                ExpressionType.NotEqual => " != ",
                ExpressionType.Add => " + ",
                ExpressionType.AddChecked => " + ",
                ExpressionType.AddAssign => " += ",
                ExpressionType.AddAssignChecked => " += ",
                ExpressionType.Subtract => " - ",
                ExpressionType.SubtractChecked => " - ",
                ExpressionType.SubtractAssign => " -= ",
                ExpressionType.SubtractAssignChecked => " -= ",
                ExpressionType.Assign => " = ",
                ExpressionType.ExclusiveOr => " ^ ",
                ExpressionType.ExclusiveOrAssign => " ^= ",
                ExpressionType.LeftShift => " << ",
                ExpressionType.LeftShiftAssign => " <<= ",
                ExpressionType.RightShift => " >> ",
                ExpressionType.RightShiftAssign => " >>= ",
                ExpressionType.Modulo => " % ",
                ExpressionType.ModuloAssign => " %= ",
                ExpressionType.Multiply => " * ",
                ExpressionType.MultiplyChecked => " * ",
                ExpressionType.MultiplyAssign => " *= ",
                ExpressionType.MultiplyAssignChecked => " *= ",
                ExpressionType.Divide => " / ",
                ExpressionType.DivideAssign => " /= ",
                _ => "???" // todo: @unclear wanna be good
            };

    }

    [RequiresUnreferencedCode(Trimming.Message)]
    public static class CodePrinter
    {
        public static readonly Func<Type, string, string> PrintTypeStripOuterClasses = (type, name) =>
        {
            if (!type.IsNested)
                return name;
            var index = name.LastIndexOf('.');
            return index == -1 ? name : name.Substring(index + 1);
        };

        public static StringBuilder AppendTypeOf(this StringBuilder sb, Type type,
            bool stripNamespace = false, Func<Type, string, string> printType = null, bool printGenericTypeArgs = false)
        {
            if (type == null)
                return sb.Append("null");
            sb.Append("typeof(").Append(type.ToCode(stripNamespace, printType, printGenericTypeArgs)).Append(')');
            return type.IsByRef ? sb.Append(".MakeByRefType()") : sb;
        }

        public static StringBuilder AppendTypeOfList(this StringBuilder sb, Type[] types,
            bool stripNamespace = false, Func<Type, string, string> printType = null, bool printGenericTypeArgs = false)
        {
            for (var i = 0; i < types.Length; i++)
                (i > 0 ? sb.Append(", ") : sb).AppendTypeOf(types[i], stripNamespace, printType, printGenericTypeArgs);
            return sb;
        }

        internal static StringBuilder AppendMember(this StringBuilder sb, MemberInfo member,
            bool stripNamespace = false, Func<Type, string, string> printType = null) =>
            member is FieldInfo f
                ? sb.AppendField(f, stripNamespace, printType)
                : sb.AppendProperty((PropertyInfo)member, stripNamespace, printType);

        internal static StringBuilder AppendField(this StringBuilder sb, FieldInfo field,
            bool stripNamespace = false, Func<Type, string, string> printType = null) =>
            sb.AppendTypeOf(field.DeclaringType, stripNamespace, printType)
              .Append(".GetTypeInfo().GetDeclaredField(\"").Append(field.Name).Append("\")");

        internal static StringBuilder AppendProperty(this StringBuilder sb, PropertyInfo property,
            bool stripNamespace = false, Func<Type, string, string> printType = null) =>
            sb.AppendTypeOf(property.DeclaringType, stripNamespace, printType)
              .Append(".GetTypeInfo().GetDeclaredProperty(\"").Append(property.Name).Append("\")");

        internal static StringBuilder AppendEnum<TEnum>(this StringBuilder sb, TEnum value,
            bool stripNamespace = false, Func<Type, string, string> printType = null) =>
            sb.Append(typeof(TEnum).ToCode(stripNamespace, printType)).Append('.')
              .Append(Enum.GetName(typeof(TEnum), value));

        private const string _nonPubStatMethods = "BindingFlags.NonPublic|BindingFlags.Static";
        private const string _nonPubInstMethods = "BindingFlags.NonPublic|BindingFlags.Instance";

        public static StringBuilder AppendMethod(this StringBuilder sb, MethodInfo method,
            bool stripNamespace = false, Func<Type, string, string> printType = null)
        {
            if (method == null)
                return sb.Append("null");

            sb.AppendTypeOf(method.DeclaringType, stripNamespace, printType);
            sb.Append(".GetMethods(");

            if (!method.IsPublic)
                sb.Append(method.IsStatic ? _nonPubStatMethods : _nonPubInstMethods);

            var mp = method.GetParameters();
            if (!method.IsGenericMethod)
            {
                sb.Append(").Single(x => !x.IsGenericMethod && x.Name == \"").Append(method.Name).Append("\" && ");
                return mp.Length == 0
                    ? sb.Append("x.GetParameters().Length == 0)")
                    : sb.Append("x.GetParameters().Select(y => y.ParameterType).SequenceEqual(new[] { ")
                        .AppendTypeOfList(mp.Select(x => x.ParameterType).ToArray(), stripNamespace, printType)
                        .Append(" }))");
            }

            var tp = method.GetGenericArguments();
            sb.Append(").Where(x => x.IsGenericMethod && x.Name == \"").Append(method.Name).Append("\" && ");
            if (mp.Length == 0)
            {
                sb.Append("x.GetParameters().Length == 0 && x.GetGenericArguments().Length == ").Append(tp.Length);
                sb.Append(").Select(x => x.IsGenericMethodDefinition ? x.MakeGenericMethod(").AppendTypeOfList(tp, stripNamespace, printType);
                return sb.Append(") : x).Single()");
            }

            sb.Append("x.GetGenericArguments().Length == ").Append(tp.Length);
            sb.Append(").Select(x => x.IsGenericMethodDefinition ? x.MakeGenericMethod(").AppendTypeOfList(tp, stripNamespace, printType);
            sb.Append(") : x).Single(x => x.GetParameters().Select(y => y.ParameterType).SequenceEqual(new[] { ");
            sb.AppendTypeOfList(mp.Select(x => x.ParameterType).ToArray(), stripNamespace, printType);
            return sb.Append(" }))");
        }

        internal static StringBuilder AppendName<T>(this StringBuilder sb, string name, string typeCode, T identity, string suffix = "") =>
            !string.IsNullOrWhiteSpace(name)
                ? sb.Append(name + suffix)
                : sb.Append(typeCode.Replace('.', '_').Replace('<', '_').Replace('>', '_').Replace(", ", "_").Replace("?", "").ToLowerInvariant())
                    .Append("__").Append(identity.GetHashCode())
                    .Append(suffix);

        internal static StringBuilder AppendName<T>(this StringBuilder sb, string name, Type type, T identity, string suffix = "") =>
            sb.AppendName(name, type.ToCode(stripNamespace: true), identity, suffix);

        // todo: @simplify add `addTypeof = false` or use `AppendTypeOf` generally
        /// <summary>Converts the <paramref name="type"/> into the proper C# representation.</summary>
        public static string ToCode(this Type type,
            bool stripNamespace = false, Func<Type, string, string> printType = null, bool printGenericTypeArgs = false)
        {
            if (type.IsGenericParameter)
                return !printGenericTypeArgs ? string.Empty : (printType?.Invoke(type, type.Name) ?? type.Name);

            if (Nullable.GetUnderlyingType(type) is Type nullableElementType && !type.IsGenericTypeDefinition)
            {
                var result = nullableElementType.ToCode(stripNamespace, printType, printGenericTypeArgs) + "?";
                return printType?.Invoke(type, result) ?? result;
            }

            Type arrayType = null;
            if (type.IsArray)
            {
                // store the original type for the later and process its element type further here
                arrayType = type;
                type = type.GetElementType();
            }

            // the default handling of the built-in types
            string buildInTypeString = null;
            if (type == typeof(void))
                buildInTypeString = "void";
            else if (type == typeof(object))
                buildInTypeString = "object";
            else if (type == typeof(bool))
                buildInTypeString = "bool";
            else if (type == typeof(int))
                buildInTypeString = "int";
            else if (type == typeof(short))
                buildInTypeString = "short";
            else if (type == typeof(byte))
                buildInTypeString = "byte";
            else if (type == typeof(double))
                buildInTypeString = "double";
            else if (type == typeof(float))
                buildInTypeString = "float";
            else if (type == typeof(char))
                buildInTypeString = "char";
            else if (type == typeof(string))
                buildInTypeString = "string";

            if (buildInTypeString != null)
            {
                if (arrayType != null)
                    buildInTypeString += "[]";
                return printType?.Invoke(arrayType ?? type, buildInTypeString) ?? buildInTypeString;
            }

            var parentCount = 0;
            for (var ti = type.GetTypeInfo(); ti.IsNested; ti = ti.DeclaringType.GetTypeInfo())
                ++parentCount;

            Type[] parentTypes = null;
            if (parentCount > 0)
            {
                parentTypes = new Type[parentCount];
                var pt = type.DeclaringType;
                for (var i = 0; i < parentTypes.Length; i++, pt = pt.DeclaringType)
                    parentTypes[i] = pt;
            }

            var typeInfo = type.GetTypeInfo();
            Type[] typeArgs = null;
            var isTypeClosedGeneric = false;
            if (type.IsGenericType)
            {
                isTypeClosedGeneric = !typeInfo.IsGenericTypeDefinition;
                typeArgs = isTypeClosedGeneric ? typeInfo.GenericTypeArguments : typeInfo.GenericTypeParameters;
            }

            var typeArgsConsumedByParentsCount = 0;
            var s = new StringBuilder();
            if (!stripNamespace && !string.IsNullOrEmpty(type.Namespace)) // for the auto-generated classes Namespace may be empty and in general it may be empty
                s.Append(type.Namespace).Append('.');

            if (parentTypes != null)
            {
                for (var p = parentTypes.Length - 1; p >= 0; --p)
                {
                    var parentType = parentTypes[p];
                    if (!parentType.IsGenericType)
                    {
                        s.Append(parentType.Name).Append('.');
                    }
                    else
                    {
                        var parentTypeInfo = parentType.GetTypeInfo();
                        Type[] parentTypeArgs = null;
                        if (parentTypeInfo.IsGenericTypeDefinition)
                        {
                            parentTypeArgs = parentTypeInfo.GenericTypeParameters;

                            // replace the open parent args with the closed child args,
                            // and close the parent
                            if (isTypeClosedGeneric)
                                for (var t = 0; t < parentTypeArgs.Length; ++t)
                                    parentTypeArgs[t] = typeArgs[t];

                            var parentTypeArgCount = parentTypeArgs.Length;
                            if (typeArgsConsumedByParentsCount > 0)
                            {
                                int ownArgCount = parentTypeArgCount - typeArgsConsumedByParentsCount;
                                if (ownArgCount == 0)
                                    parentTypeArgs = null;
                                else
                                {
                                    var ownArgs = new Type[ownArgCount];
                                    for (var a = 0; a < ownArgs.Length; ++a)
                                        ownArgs[a] = parentTypeArgs[a + typeArgsConsumedByParentsCount];
                                    parentTypeArgs = ownArgs;
                                }
                            }
                            typeArgsConsumedByParentsCount = parentTypeArgCount;
                        }
                        else
                        {
                            parentTypeArgs = parentTypeInfo.GenericTypeArguments;
                        }

                        var parentTickIndex = parentType.Name.IndexOf('`');
                        s.Append(parentType.Name.Substring(0, parentTickIndex));

                        // The owned parentTypeArgs maybe empty because all args are defined in the parent's parents
                        if (parentTypeArgs?.Length > 0)
                        {
                            s.Append('<');
                            for (var t = 0; t < parentTypeArgs.Length; ++t)
                                (t == 0 ? s : s.Append(", ")).Append(parentTypeArgs[t].ToCode(stripNamespace, printType, printGenericTypeArgs));
                            s.Append('>');
                        }
                        s.Append('.');
                    }
                }
            }
            var name = type.Name.TrimStart('<', '>').TrimEnd('&');

            if (typeArgs != null && typeArgsConsumedByParentsCount < typeArgs.Length)
            {
                var tickIndex = name.IndexOf('`');
                s.Append(name.Substring(0, tickIndex)).Append('<');
                for (var i = 0; i < typeArgs.Length - typeArgsConsumedByParentsCount; ++i)
                    (i == 0 ? s : s.Append(", ")).Append(typeArgs[i + typeArgsConsumedByParentsCount].ToCode(stripNamespace, printType, printGenericTypeArgs));
                s.Append('>');
            }
            else
            {
                s.Append(name);
            }

            if (arrayType != null)
                s.Append("[]");

            return printType?.Invoke(arrayType ?? type, s.ToString()) ?? s.ToString();
        }

        /// <summary>Prints valid C# Boolean</summary>
        public static string ToCode(this bool x) => x ? "true" : "false";

        /// <summary>Prints valid C# String escaping the things</summary>
        public static string ToCode(this string x) =>
            x == null ? "null" : $"\"{x.Replace("\"", "\\\"").Replace("\r", "\\r").Replace("\n", "\\n")}\"";

        private static readonly char[] _enumValueSeparators = new[] { ',', ' ' };

        /// <summary>Prints valid C# Enum literal</summary>
        public static string ToEnumValueCode(this Type enumType, object x,
            bool stripNamespace = false, Func<Type, string, string> printType = null)
        {
            var typeStr = enumType.ToCode(stripNamespace, printType);
            var valueStr = x.ToString();
            var flags = valueStr.Split(_enumValueSeparators, StringSplitOptions.RemoveEmptyEntries);
            if (flags.Length == 1)
            {
                if (int.TryParse(valueStr, out _))
                    return "(" + typeStr + ")" + valueStr;
                return typeStr + "." + valueStr;
            }
            var orTypeDot = "|" + typeStr + ".";
            return typeStr + "." + string.Join(orTypeDot, flags);
        }

        private static Type[] GetGenericTypeParametersOrArguments(this TypeInfo typeInfo) =>
            typeInfo.IsGenericTypeDefinition ? typeInfo.GenericTypeParameters : typeInfo.GenericTypeArguments;

        /// <summary>Custom handler for output the object in valid C#. Note, the `printGenericTypeArgs` is excluded because it cannot be a open-generic object.
        /// This handler is also used to allow user to fully control a Constant expression output</summary>
        public delegate string ObjectToCode(object x, bool stripNamespace = false, Func<Type, string, string> printType = null);

        /// <summary>Outputs the `default(Type)` for the unknown constant with the comment message</summary>
        public static readonly ObjectToCode DefaultNotRecognizedToCode = (x, stripNamespace, printType) =>
            "default(" + x.GetType().ToCode(stripNamespace, printType) + ")/*Please provide the non-default value for the constant!*/";

        /// <summary>Prints many code items as the array initializer.</summary>
        public static string ToCommaSeparatedCode(this IEnumerable items, ObjectToCode notRecognizedToCode,
            bool stripNamespace = false, Func<Type, string, string> printType = null)
        {
            var s = new StringBuilder();
            var first = true;
            foreach (var item in items)
            {
                if (!first)
                    s.Append(", ");
                first = false;
                s.Append(item.ToCode(notRecognizedToCode, stripNamespace, printType));
            }
            return s.ToString();
        }

        /// <summary>Prints many code items as array initializer.</summary>
        public static string ToArrayInitializerCode(this IEnumerable items, Type itemType, ObjectToCode notRecognizedToCode,
            bool stripNamespace = false, Func<Type, string, string> printType = null)
        {
            var s = new StringBuilder("new ");
            // todo: @simplify should we avoid type for the `new Type` because the values also will include the type?
            s.Append(itemType.ToCode(stripNamespace, printType));
            s.Append("[]{");
            s.Append(items.ToCommaSeparatedCode(notRecognizedToCode, stripNamespace, printType));
            s.Append('}');
            return s.ToString();
        }

        private static readonly Type[] TypesImplementedByArray =
            typeof(object[]).GetInterfaces().Where(t => t.GetTypeInfo().IsGenericType).Select(t => t.GetGenericTypeDefinition()).ToArray();

        // todo: @simplify convert to using StringBuilder and simplify usage call-sites, or ADD the method
        // todo: @simplify add `addTypeof = false`
        /// <summary>
        /// Prints a valid C# for known <paramref name="x"/>,
        /// otherwise uses passed <paramref name="notRecognizedToCode"/> or falls back to `ToString()`.
        /// </summary>
        public static string ToCode(this object x, ObjectToCode notRecognizedToCode,
            bool stripNamespace = false, Func<Type, string, string> printType = null)
        {
            if (x == null)
                return "null";

            if (x is bool b)
                return b.ToCode();

            if (x is int i)
                return i.ToString();

            if (x is double d)
                return d.ToString();

            if (x is string s)
                return s.ToCode();

            if (x is char c)
                return "'" + c + "'";

            if (x is Decimal m)
                return $"{m}m";

            if (x is Type t)
                return t.ToCode(stripNamespace, printType);

            if (x is Guid guid)
                return "Guid.Parse(" + guid.ToString().ToCode() + ")";

            if (x is DateTime date)
                return "DateTime.Parse(" + date.ToString().ToCode() + ")";

            if (x is TimeSpan time)
                return "TimeSpan.Parse(" + time.ToString().ToCode() + ")";

            var xType = x.GetType();
            var xTypeInfo = xType.GetTypeInfo();

            // check if item is implemented by array and then use the array initializer only for these types, 
            // otherwise we may produce the array initializer but it will be incompatible with e.g. `List<T>`
            if (xTypeInfo.IsArray ||
                xTypeInfo.IsGenericType && TypesImplementedByArray.Contains(xType.GetGenericTypeDefinition()))
            {
                var elemType = xTypeInfo.IsArray
                    ? xTypeInfo.GetElementType()
                    : xTypeInfo.GetGenericTypeParametersOrArguments().GetFirst();
                if (elemType != null && elemType != xType) // avoid self recurring types e.g. `class A : IEnumerable<A>`
                    return ((IEnumerable)x).ToArrayInitializerCode(elemType, notRecognizedToCode, stripNamespace, printType);
            }

            // unwrap the Nullable struct
            if (xTypeInfo.IsGenericType && xTypeInfo.GetGenericTypeDefinition() == typeof(Nullable<>))
            {
                xType = xTypeInfo.GetElementType();
                xTypeInfo = xType.GetTypeInfo();
            }

            if (xTypeInfo.IsEnum)
                return x.GetType().ToEnumValueCode(x, stripNamespace, printType);

            if (xTypeInfo.IsPrimitive) // output the primitive casted to the type
                return "(" + x.GetType().ToCode(true, null) + ")" + x.ToString();

            return notRecognizedToCode?.Invoke(x, stripNamespace, printType) ?? x.ToString();
        }

        internal static StringBuilder NewLineIdent(this StringBuilder sb, int lineIdent)
        {
            var originalLength = sb.Length;
            sb.AppendLineOnce();
            return originalLength == sb.Length ? sb : sb.Append(' ', lineIdent);
        }

        internal static StringBuilder NewLine(this StringBuilder sb, int lineIdent, int identSpaces) =>
            sb.AppendLine().Append(' ', Math.Max(lineIdent - identSpaces, 0));

        internal static StringBuilder NewLineIdentExpr(this StringBuilder sb,
            Expression expr, List<ParameterExpression> paramsExprs, List<Expression> uniqueExprs, List<LabelTarget> lts,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode)
        {
            sb.NewLineIdent(lineIdent);
            return expr?.ToExpressionString(sb, paramsExprs, uniqueExprs, lts,
                lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode) ?? sb.Append("null");
        }

        internal static StringBuilder NewLineIdentArgumentExprs<T>(this StringBuilder sb, IReadOnlyList<T> exprs,
            List<ParameterExpression> paramsExprs, List<Expression> uniqueExprs, List<LabelTarget> lts,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode)
            where T : Expression
        {
            if (exprs.Count == 0)
                return sb.Append(" new ").Append(typeof(T).ToCode(true)).Append("[0]");
            for (var i = 0; i < exprs.Count; i++)
                (i > 0 ? sb.Append(", ") : sb).NewLineIdentExpr(exprs[i],
                    paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
            return sb;
        }

        // todo: @improve figure how to avoid the duplication with the method above IReadOnlyList<T> exprs
        internal static StringBuilder NewLineIdentArgumentExprs<T>(this StringBuilder sb, SmallList2<T> exprs,
            List<ParameterExpression> paramsExprs, List<Expression> uniqueExprs, List<LabelTarget> lts,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode)
            where T : Expression
        {
            if (exprs.Count == 0)
                return sb.Append(" new ").Append(typeof(T).ToCode(true)).Append("[0]");
            for (var i = 0; i < exprs.Count; i++)
                (i > 0 ? sb.Append(", ") : sb).NewLineIdentExpr(exprs.GetSurePresentItemRef(i),
                    paramsExprs, uniqueExprs, lts, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode);
            return sb;
        }

        internal static StringBuilder NewLineIdentCs(this StringBuilder sb, Expression expr,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode) =>
            expr?.ToCSharpString(sb.NewLineIdent(lineIdent), lineIdent + identSpaces, stripNamespace, printType, identSpaces, notRecognizedToCode)
            ?? sb.Append("null");

        internal static StringBuilder NewLineIdentCs(this StringBuilder sb, Expression expr, ToCSharpPrinter.EnclosedIn enclosedIn,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces, CodePrinter.ObjectToCode notRecognizedToCode) =>
            expr?.ToCSharpString(sb.NewLineIdent(lineIdent), enclosedIn, lineIdent, stripNamespace, printType, identSpaces, notRecognizedToCode)
            ?? sb.Append("null");

        /// <summary>Helper method to find the number of lambdas in the C# `code` string</summary>
        public static int CountLambdas(string code)
        {
            int lambdaCount = 0, lambdaIndex = 0;
            while (true)
            {
                lambdaIndex = code.IndexOf("=>", lambdaIndex + 2);
                if (lambdaIndex == -1)
                    break;
                ++lambdaCount;
            }
            return lambdaCount;
        }
    }

    internal static class FecHelpers
    {
        public static int GetFirstIndexByReferenceEquals<T>(this IReadOnlyList<T> source, T item) where T : class
        {
            if (source.Count != 0)
                for (var i = 0; i < source.Count; ++i)
                    if (ReferenceEquals(source[i], item))
                        return i;
            return -1;
        }

        [MethodImpl((MethodImplOptions)256)]
        public static T GetArgument<T>(this IReadOnlyList<T> source, int index) => source[index];

        [MethodImpl((MethodImplOptions)256)]
        public static ParameterExpression GetParameter(this IReadOnlyList<PE> source, int index) => source[index];

#if LIGHT_EXPRESSION
        public static IReadOnlyList<PE> ToReadOnlyList(this IParameterProvider source)
        {
            var count = source.ParameterCount;
            var ps = new ParameterExpression[count];
            for (var i = 0; i < count; ++i)
                ps[i] = source.GetParameter(i);
            return ps;
        }

        public static int GetCount(this IParameterProvider p) => p.ParameterCount;
#else
        public static IReadOnlyList<PE> ToReadOnlyList(this IReadOnlyList<PE> source) => source;

        public static int GetCount(this IReadOnlyList<PE> p) => p.Count;
#endif

#if SUPPORTS_ARGUMENT_PROVIDER
        public static int GetCount(this IArgumentProvider p) => p.ArgumentCount;
#else
        public static int GetCount(this IReadOnlyList<Expression> p) => p.Count;
#endif
    }

    internal static class Trimming
    {
        public const string Message = "FastExpressionCompiler is not supported in trimming scenarios.";
    }
}

#if !NET5_0_OR_GREATER
namespace System.Diagnostics.CodeAnalysis
{
    internal sealed class RequiresUnreferencedCodeAttribute : Attribute
    {
        public string Message { get; }
        public RequiresUnreferencedCodeAttribute(string message)
        {
            Message = message;
        }
    }
}
#endif
